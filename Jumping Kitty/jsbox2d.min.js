!function () {
	Function.prototype._extend = function (a) {
		this.prototype.parent = a;
		for (var b in a.prototype) if (!this.prototype[b]) this.prototype[b] = a.prototype[b];
	};
	Function.prototype._implement = function (a) {
		return this._extend(a);
	};
	var a = function () {
		if ("undefined" === typeof performance) window.performance = {
			now: function () {
				return +new Date();
			}
		};
		function a(a, b) {
			this.name = a;
			this.parent = b;
			this.children = {};
			this.startTime = 0;
			this.elapsedTime = 0;
			this.totalTime = 0;
			this.running = false;
			this.childrenCount = 0;
		}
		a.prototype = {
			start: function () {
				this.startTime = performance.now();
				this.running = true;
			},
			stop: function (a) {
				if (!this.running) return;
				this.running = false;
				this.elapsedTime += performance.now() - this.startTime;
				if (a) this.start();
				for (var b in this.children) this.children[b].stop();
			},
			reset: function (a) {
				if (!a) {
					this.running = true;
					this.totalTime += this.elapsedTime;
					this.start();
				}
				this.elapsedTime = 0;
				for (var b in this.children) this.children[b].reset(true);
			}
		};
		var b = [];
		var c = new a("root");
		function d(c, d) {
			if (!b) throw new Error("late profile creation not allowed");
			var e = new a(c, d || "root");
			b.push(e);
			return e;
		}
		function e(a) {
			a.childrenCount--;
			delete a.children[a.name];
		}
		function f(a, b) {
			if (a.name === b.parent) return a;
			for (var c in a.children) {
				var d;
				if (d = f(a.children[c], b)) return d;
			}
			return null;
		}
		function g() {
			while (b.length) {
				var a = b.pop();
				if (!(a.parentNode = f(c, a))) b.unshift(a); else {
					a.parentNode.children[a.name] = a;
					a.parentNode.childrenCount++;
				}
			}
			b = null;
		}
		function h() {
			c.reset(true);
		}
		return {
			create: d,
			destroy: e,
			init: g,
			reset: h,
			profileRoot: c
		};
	}();
	var b = Number.MAX_VALUE;
	var c = 2.220446049250313e-16;
	var d = Math.PI;
	var e = 2;
	var f = 8;
	var g = .1;
	var h = 2;
	var i = .005;
	var j = 2 / 180 * d;
	var k = 2 * i;
	var l = 8;
	var m = 32;
	var n = 1;
	var o = .2;
	var p = 8 / 180 * d;
	var q = 2;
	var r = q * q;
	var s = .5 * d;
	var t = s * s;
	var u = .2;
	var v = .75;
	var w = .5;
	var x = .01;
	var y = 2 / 180 * d;
	function z(a, b, c) {
		this.major = a;
		this.minor = b;
		this.revision = c;
	}
	z.prototype = {
		toString: function () {
			return this.major + "." + this.minor + "." + this.revision;
		}
	};
	var A = new z(2, 3, 1);
	function B(a) {
		return isFinite(a) && !isNaN(a);
	}
	var C = Math.sqrt;
	var D = Math.atan2;
	var E = Math.sin;
	var F = Math.cos;
	var G = Math.floor;
	var H = Math.ceil;
	var I = C;
	var J = D;
	function K(a) {
		return 1 / C(a);
	}
	function L(a, b) {
		if ("undefined" !== typeof a) {
			this.x = a;
			this.y = b;
		} else this.x = this.y = 0;
	}
	L.prototype = {
		Clone: function () {
			return new L(this.x, this.y);
		},
		SetZero: function () {
			this.x = 0;
			this.y = 0;
			return this;
		},
		Set: function (a, b) {
			this.x = a;
			this.y = b;
			return this;
		},
		Assign: function (a) {
			this.x = a.x;
			this.y = a.y;
			return this;
		},
		Negate: function () {
			var a = new L();
			a.Set(-this.x, -this.y);
			return a;
		},
		get_i: function (a) {
			switch (a) {
				case 0:
					return this.x;

				case 1:
					return this.y;
			}
		},
		set_i: function (a, b) {
			switch (a) {
				case 0:
					return this.x = b;

				case 1:
					return this.y = b;
			}
		},
		Add: function (a) {
			this.x += a.x;
			this.y += a.y;
			return this;
		},
		Subtract: function (a) {
			this.x -= a.x;
			this.y -= a.y;
			return this;
		},
		Multiply: function (a) {
			this.x *= a;
			this.y *= a;
			return this;
		},
		Length: function () {
			return I(this.x * this.x + this.y * this.y);
		},
		LengthSquared: function () {
			return this.x * this.x + this.y * this.y;
		},
		Normalize: function () {
			var a = this.Length();
			if (a < c) return 0;
			var b = 1 / a;
			this.x *= b;
			this.y *= b;
			return a;
		},
		IsValid: function () {
			return B(this.x) && B(this.y);
		},
		Skew: function () {
			return new L(-this.y, this.x);
		},
		_serialize: function (a) {
			var b = a || [];
			b[0] = this.x;
			b[1] = this.y;
			return b;
		},
		_deserialize: function (a) {
			this.x = a[0];
			this.y = a[1];
		}
	};
	L.Add = function (a, b) {
		return new L(a.x + b.x, a.y + b.y);
	};
	L.Subtract = function (a, b) {
		return new L(a.x - b.x, a.y - b.y);
	};
	L.Equals = function (a, b) {
		return a.x == b.x && a.y == b.y;
	};
	L.Multiply = function (a, b) {
		return new L(a * b.x, a * b.y);
	};
	L.Negate = function (a) {
		return new L(-a.x, -a.y);
	};
	function M(a, b, c) {
		if ("undefined" !== typeof a) {
			this.x = a;
			this.y = b;
			this.z = c;
		}
	}
	M.prototype = {
		Clone: function () {
			return new M(this.x, this.y, this.z);
		},
		SetZero: function () {
			this.x = 0;
			this.y = 0;
			this.z = 0;
		},
		Set: function (a, b, c) {
			this.x = a;
			this.y = b;
			this.z = c;
		},
		Negate: function () {
			var a = new M();
			a.Set(-this.x, -this.y, -this.z);
			return a;
		},
		Add: function (a) {
			this.x += a.x;
			this.y += a.y;
			this.z += a.z;
		},
		Subtract: function (a) {
			this.x -= a.x;
			this.y -= a.y;
			this.z -= a.z;
		},
		Multiply: function (a) {
			this.x *= a;
			this.y *= a;
			this.z *= a;
		},
		x: 0,
		y: 0,
		z: 0
	};
	M.Multiply = function (a, b) {
		return new M(a * b.x, a * b.y, a * b.z);
	};
	M.Add = function (a, b) {
		return new M(a.x + b.x, a.y + b.y, a.z + b.z);
	};
	M.Subtract = function (a, b) {
		return new M(a.x - b.x, a.y - b.y, a.z - b.z);
	};
	function N(a, b) {
		this.ex = a ? a.Clone() : new L();
		this.ey = b ? b.Clone() : new L();
	}
	N.prototype = {
		Set: function (a, b) {
			this.ex.Assign(a);
			this.ey.Assign(b);
		},
		Assign: function (a) {
			this.ex.Assign(a.ex);
			this.ey.Assign(a.ey);
		},
		SetIdentity: function () {
			this.ex.x = 1;
			this.ey.x = 0;
			this.ex.y = 0;
			this.ey.y = 1;
		},
		SetZero: function () {
			this.ex.x = 0;
			this.ey.x = 0;
			this.ex.y = 0;
			this.ey.y = 0;
		},
		GetInverse: function () {
			var a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;
			var e = new N();
			var f = a * d - b * c;
			if (0 != f) f = 1 / f;
			e.ex.x = f * d;
			e.ey.x = -f * b;
			e.ex.y = -f * c;
			e.ey.y = f * a;
			return e;
		},
		Solve: function (a) {
			var b = this.ex.x, c = this.ey.x, d = this.ex.y, e = this.ey.y;
			var f = b * e - c * d;
			if (0 != f) f = 1 / f;
			var g = new L();
			g.x = f * (e * a.x - c * a.y);
			g.y = f * (b * a.y - d * a.x);
			return g;
		}
	};
	N.Add = function (a, b) {
		return new N(L.Add(a.ex, b.ex), L.Add(a.ey, b.ey));
	};
	function O(a, b, c) {
		this.ex = a ? a.Clone() : new M();
		this.ey = b ? b.Clone() : new M();
		this.ez = c ? c.Clone() : new M();
	}
	O.prototype = {
		SetZero: function () {
			this.ex.SetZero();
			this.ey.SetZero();
			this.ez.SetZero();
		},
		Solve33: function (a) {
			var b = $(this.ex, _(this.ey, this.ez));
			if (0 != b) b = 1 / b;
			var c = new M();
			c.x = b * $(a, _(this.ey, this.ez));
			c.y = b * $(this.ex, _(a, this.ez));
			c.z = b * $(this.ex, _(this.ey, a));
			return c;
		},
		Solve22: function (a) {
			var b = this.ex.x, c = this.ey.x, d = this.ex.y, e = this.ey.y;
			var f = b * e - c * d;
			if (0 != f) f = 1 / f;
			var g = new L();
			g.x = f * (e * a.x - c * a.y);
			g.y = f * (b * a.y - d * a.x);
			return g;
		},
		GetInverse22: function (a) {
			var b = this.ex.x, c = this.ey.x, d = this.ex.y, e = this.ey.y;
			var f = b * e - c * d;
			if (0 != f) f = 1 / f;
			a.ex.x = f * e;
			a.ey.x = -f * c;
			a.ex.z = 0;
			a.ex.y = -f * d;
			a.ey.y = f * b;
			a.ey.z = 0;
			a.ez.x = 0;
			a.ez.y = 0;
			a.ez.z = 0;
		},
		GetSymInverse33: function (a) {
			var b = $(this.ex, _(this.ey, this.ez));
			if (0 != b) b = 1 / b;
			var c = this.ex.x, d = this.ey.x, e = this.ez.x;
			var f = this.ey.y, g = this.ez.y;
			var h = this.ez.z;
			a.ex.x = b * (f * h - g * g);
			a.ex.y = b * (e * g - d * h);
			a.ex.z = b * (d * g - e * f);
			a.ey.x = a.ex.y;
			a.ey.y = b * (c * h - e * e);
			a.ey.z = b * (e * d - c * g);
			a.ez.x = a.ex.z;
			a.ez.y = a.ey.z;
			a.ez.z = b * (c * f - d * d);
		}
	};
	function P(a, b) {
		if ("undefined" !== typeof b) {
			this.s = a;
			this.c = b;
		} else if ("undefined" !== typeof a) this.Set(a);
	}
	P.prototype = {
		Clone: function () {
			return new P(this.s, this.c);
		},
		Assign: function (a) {
			this.s = a.s;
			this.c = a.c;
		},
		Set: function (a) {
			this.s = E(a);
			this.c = F(a);
		},
		SetIdentity: function () {
			this.s = 0;
			this.c = 1;
		},
		GetAngle: function () {
			return J(this.s, this.c);
		},
		GetXAxis: function () {
			return new L(this.c, this.s);
		},
		GetYAxis: function () {
			return new L(-this.s, this.c);
		},
		s: 0,
		c: 1
	};
	function Q(a, b) {
		this.p = new L();
		this.q = new P();
		if (a) {
			this.p.Assign(a);
			this.q.Assign(b);
		}
	}
	Q.prototype = {
		Clone: function () {
			var a = new Q(this.p, this.q);
			return a;
		},
		Assign: function (a) {
			this.p.Assign(a.p);
			this.q.Assign(a.q);
		},
		SetIdentity: function () {
			this.p.SetZero();
			this.q.SetIdentity();
		},
		Set: function (a, b) {
			this.p.Assign(a);
			this.q.Set(b);
		}
	};
	function R() {
		this.localCenter = new L();
		this.c0 = new L();
		this.c = new L();
	}
	R.prototype = {
		Assign: function (a) {
			this.localCenter.Assign(a.localCenter);
			this.c0.Assign(a.c0);
			this.c.Assign(a.c);
			this.a = a.a;
			this.a0 = a.a0;
			this.alpha0 = a.alpha0;
		},
		Clone: function () {
			var a = new R();
			a.localCenter.Assign(this.localCenter);
			a.c0.Assign(this.c0);
			a.c.Assign(this.c);
			a.a = this.a;
			a.a0 = this.a0;
			a.alpha0 = this.alpha0;
			return a;
		},
		GetTransform: function (a, b) {
			a.p.x = (1 - b) * this.c0.x + b * this.c.x;
			a.p.y = (1 - b) * this.c0.y + b * this.c.y;
			var c = (1 - b) * this.a0 + b * this.a;
			a.q.Set(c);
			a.p.x -= a.q.c * this.localCenter.x - a.q.s * this.localCenter.y;
			a.p.y -= a.q.s * this.localCenter.x + a.q.c * this.localCenter.y;
		},
		Advance: function (a) {
			var b = (a - this.alpha0) / (1 - this.alpha0);
			this.c0.Add(L.Multiply(b, L.Subtract(this.c, this.c0)));
			this.a0 += b * (this.a - this.a0);
			this.alpha0 = a;
		},
		Normalize: function () {
			var a = 2 * d;
			var b = a * G(this.a0 / a);
			this.a0 -= b;
			this.a -= b;
		},
		a0: 0,
		a: 0,
		alpha0: 0
	};
	function S(a, b) {
		return a.x * b.x + a.y * b.y;
	}
	function T(a, b) {
		return a.x * b.y - a.y * b.x;
	}
	function U(a, b) {
		return new L(b * a.y, -b * a.x);
	}
	function V(a, b) {
		return new L(-a * b.y, a * b.x);
	}
	function W(a, b) {
		return new L(a.ex.x * b.x + a.ey.x * b.y, a.ex.y * b.x + a.ey.y * b.y);
	}
	function X(a, b) {
		return new L(S(b, a.ex), S(b, a.ey));
	}
	function Y(a, b) {
		var c = L.Subtract(a, b);
		return c.Length();
	}
	function Z(a, b) {
		var c = L.Subtract(a, b);
		return S(c, c);
	}
	function $(a, b) {
		return a.x * b.x + a.y * b.y + a.z * b.z;
	}
	function _(a, b) {
		return new M(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
	}
	function ab(a, b) {
		return new N(W(a, b.ex), W(a, b.ey));
	}
	function bb(a, b) {
		var c = new L(S(a.ex, b.ex), S(a.ey, b.ex));
		var d = new L(S(a.ex, b.ey), S(a.ey, b.ey));
		return new N(c, d);
	}
	function cb(a, b) {
		return M.Add(M.Add(M.Multiply(b.x, a.ex), M.Multiply(b.y, a.ey)), M.Multiply(b.z, a.ez));
	}
	function db(a, b) {
		return new L(a.ex.x * b.x + a.ey.x * b.y, a.ex.y * b.x + a.ey.y * b.y);
	}
	function eb(a, b) {
		var c = new P();
		c.s = a.s * b.c + a.c * b.s;
		c.c = a.c * b.c - a.s * b.s;
		return c;
	}
	function fb(a, b) {
		var c = new P();
		c.s = a.c * b.s - a.s * b.c;
		c.c = a.c * b.c + a.s * b.s;
		return c;
	}
	function gb(a, b) {
		return new L(a.c * b.x - a.s * b.y, a.s * b.x + a.c * b.y);
	}
	function hb(a, b) {
		return new L(a.c * b.x + a.s * b.y, -a.s * b.x + a.c * b.y);
	}
	function ib(a, b) {
		return new L(a.q.c * b.x - a.q.s * b.y + a.p.x, a.q.s * b.x + a.q.c * b.y + a.p.y);
	}
	function jb(a, b) {
		var c = b.x - a.p.x;
		var d = b.y - a.p.y;
		var e = a.q.c * c + a.q.s * d;
		var f = -a.q.s * c + a.q.c * d;
		return new L(e, f);
	}
	function kb(a, b) {
		var c = new Q();
		c.q = eb(a.q, b.q);
		c.p = L.Add(gb(a.q, b.p), a.p);
		return c;
	}
	function lb(a, b) {
		var c = new Q();
		c.q = fb(a.q, b.q);
		var d = b.p.x - a.p.x;
		var e = b.p.y - a.p.y;
		c.p.x = a.q.c * d + a.q.s * e;
		c.p.y = -a.q.s * d + a.q.c * e;
		return c;
	}
	var mb = Math.abs;
	function nb(a) {
		return new L(mb(a.x), mb(a.y));
	}
	function ob(a) {
		return new N(nb(a.ex), nb(a.ey));
	}
	var pb = Math.min;
	function qb(a, b) {
		return new L(pb(a.x, b.x), pb(a.y, b.y));
	}
	var rb = Math.max;
	function sb(a, b) {
		return new L(rb(a.x, b.x), rb(a.y, b.y));
	}
	function tb(a, b, c) {
		return rb(b, pb(a, c));
	}
	function ub(a, b, c) {
		return sb(b, qb(a, c));
	}
	function vb(a) {
		a |= a >> 1;
		a |= a >> 2;
		a |= a >> 4;
		a |= a >> 8;
		a |= a >> 16;
		return a + 1;
	}
	function wb(a) {
		var b = a > 0 && 0 == (a & a - 1);
		return b;
	}
	var xb = 32767;
	function yb(a, b) {
		var c = Math.random();
		if ("undefined" !== typeof a) c = (b - a) * c + a; else c = 2 * c - 1;
		return c;
	}
	function zb(a, b, c) {
		this.r = a || 0;
		this.g = b || 0;
		this.b = c || 0;
	}
	zb.prototype = {
		Set: function (a, b, c) {
			this.r = a;
			this.g = b;
			this.b = c;
		}
	};
	function Ab() { }
	Ab.prototype = {
		SetFlags: function (a) {
			this.m_drawFlags = a;
		},
		GetFlags: function () {
			return this.m_drawFlags;
		},
		AppendFlags: function (a) {
			this.m_drawFlags |= a;
		},
		ClearFlags: function (a) {
			this.m_drawFlags &= ~a;
		},
		ToggleFlags: function (a) {
			this.m_drawFlags ^= a;
		},
		DrawPolygon: function (a, b, c) { },
		DrawSolidPolygon: function (a, b, c) { },
		DrawCircle: function (a, b, c) { },
		DrawSolidCircle: function (a, b, c, d) { },
		DrawSegment: function (a, b, c) { },
		DrawTransform: function (a) { },
		m_drawFlags: 0
	};
	Ab.e_shapeBit = 1;
	Ab.e_jointBit = 2;
	Ab.e_aabbBit = 4;
	Ab.e_centerOfMassBit = 8;
	Ab.e_contactPoints = 16;
	Ab.e_contactNormals = 32;
	Ab.e_contactImpulses = 64;
	Ab.e_frictionImpulses = 128;
	Ab.e_statistics = 256;
	Ab.e_profile = 512;
	Ab.e_pairBit = 1024;
	if ("undefined" === typeof performance) window.performance = {
		now: function () {
			return +new Date();
		}
	};
	function Bb() {
		this.Reset();
	}
	Bb.prototype = {
		Reset: function () {
			this.m_start = performance.now();
		},
		GetMilliseconds: function () {
			return performance.now() - this.m_start;
		}
	};
	function Cb() {
		this.mass = 0;
		this.center = new L();
		this.I = 0;
	}
	function Db() {
		this.m_type = 0;
		this.m_radius = 0;
	}
	Db.prototype = {
		Clone: function () { },
		GetType: function () {
			return this.m_type;
		},
		GetChildCount: function () { },
		TestPoint: function (a, b) { },
		RayCast: function (a, b, c, d) { },
		ComputeAABB: function (a, b, c) { },
		ComputeMass: function (a, b) { },
		_serialize: function (a) {
			var b = a || {};
			b.m_type = this.m_type;
			b.m_radius = this.m_radius;
			return b;
		},
		_deserialize: function (a) {
			this.m_radius = a.m_radius;
		}
	};
	Db.e_circle = 0;
	Db.e_edge = 1;
	Db.e_polygon = 2;
	Db.e_chain = 3;
	Db.e_typeCount = 4;
	function Eb() {
		this.parent.call(this);
		this.m_type = Db.e_circle;
		this.m_radius = 0;
		this.m_p = new L();
		Object.seal(this);
	}
	Eb.prototype = {
		Clone: function () {
			var a = new Eb();
			a.m_radius = this.m_radius;
			a.m_p = this.m_p.Clone();
			return a;
		},
		GetChildCount: function () {
			return 1;
		},
		TestPoint: function (a, b) {
			var c = L.Add(a.p, gb(a.q, this.m_p));
			var d = L.Subtract(b, c);
			return S(d, d) <= this.m_radius * this.m_radius;
		},
		RayCast: function (a, b, d, e) {
			var f = L.Add(d.p, gb(d.q, this.m_p));
			var g = L.Subtract(b.p1, f);
			var h = S(g, g) - this.m_radius * this.m_radius;
			var i = L.Subtract(b.p2, b.p1);
			var j = S(g, i);
			var k = S(i, i);
			var l = j * j - k * h;
			if (l < 0 || k < c) return false;
			var m = -(j + I(l));
			if (0 <= m && m <= b.maxFraction * k) {
				m /= k;
				a.fraction = m;
				a.normal = L.Add(g, L.Multiply(m, i));
				a.normal.Normalize();
				return true;
			}
			return false;
		},
		ComputeAABB: function (a, b, c) {
			var d = b.p.x + (b.q.c * this.m_p.x - b.q.s * this.m_p.y);
			var e = b.p.y + (b.q.s * this.m_p.x + b.q.c * this.m_p.y);
			a.lowerBound.x = d - this.m_radius;
			a.lowerBound.y = e - this.m_radius;
			a.upperBound.x = d + this.m_radius;
			a.upperBound.y = e + this.m_radius;
		},
		ComputeMass: function (a, b) {
			a.mass = b * d * this.m_radius * this.m_radius;
			a.center = this.m_p;
			a.I = a.mass * (.5 * this.m_radius * this.m_radius + S(this.m_p, this.m_p));
		},
		GetSupport: function (a) {
			return 0;
		},
		GetSupportVertex: function (a) {
			return this.m_p;
		},
		GetVertexCount: function () {
			return 1;
		},
		GetVertex: function (a) {
			return this.m_p;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.m_p = this.m_p._serialize();
			return b;
		},
		_deserialize: function (a) {
			this.parent.prototype._deserialize.call(this, a);
			this.m_p._deserialize(a.m_p);
		}
	};
	Eb._extend(Db);
	function Fb() {
		this.parent.call(this);
		this.m_type = Db.e_edge;
		this.m_radius = k;
		this.m_vertex0 = new L();
		this.m_vertex1 = new L();
		this.m_vertex2 = new L();
		this.m_vertex3 = new L();
		this.m_hasVertex0 = false;
		this.m_hasVertex3 = false;
		Object.seal(this);
	}
	Fb.prototype = {
		Set: function (a, b) {
			this.m_vertex1.Assign(a);
			this.m_vertex2.Assign(b);
			this.m_hasVertex0 = false;
			this.m_hasVertex3 = false;
		},
		Clone: function () {
			var a = new Fb();
			a.m_vertex0 = this.m_vertex0.Clone();
			a.m_vertex1 = this.m_vertex1.Clone();
			a.m_vertex2 = this.m_vertex2.Clone();
			a.m_vertex3 = this.m_vertex3.Clone();
			a.m_hasVertex0 = this.m_hasVertex0;
			a.m_hasVertex3 = this.m_hasVertex3;
			return a;
		},
		GetChildCount: function () {
			return 1;
		},
		TestPoint: function (a, b) {
			return false;
		},
		RayCast: function (a, b, c, d) {
			var e = hb(c.q, L.Subtract(b.p1, c.p));
			var f = hb(c.q, L.Subtract(b.p2, c.p));
			var g = L.Subtract(f, e);
			var h = this.m_vertex1;
			var i = this.m_vertex2;
			var j = L.Subtract(i, h);
			var k = new L(j.y, -j.x);
			k.Normalize();
			var l = S(k, L.Subtract(h, e));
			var m = S(k, g);
			if (0 == m) return false;
			var n = l / m;
			if (n < 0 || b.maxFraction < n) return false;
			var o = L.Add(e, L.Multiply(n, g));
			var p = L.Subtract(i, h);
			var q = S(p, p);
			if (0 == q) return false;
			var r = S(L.Subtract(o, h), p) / q;
			if (r < 0 || 1 < r) return false;
			a.fraction = n;
			if (l > 0) a.normal = gb(c.q, k).Negate(); else a.normal = gb(c.q, k);
			return true;
		},
		ComputeAABB: function (a, b, c) {
			var d = b.q.c * this.m_vertex1.x - b.q.s * this.m_vertex1.y + b.p.x;
			var e = b.q.s * this.m_vertex1.x + b.q.c * this.m_vertex1.y + b.p.y;
			var f = b.q.c * this.m_vertex2.x - b.q.s * this.m_vertex2.y + b.p.x;
			var g = b.q.s * this.m_vertex2.x + b.q.c * this.m_vertex2.y + b.p.y;
			var h = pb(d, f);
			var i = pb(e, g);
			var j = rb(d, f);
			var k = rb(e, g);
			a.lowerBound.x = h - this.m_radius;
			a.lowerBound.y = i - this.m_radius;
			a.upperBound.x = j + this.m_radius;
			a.upperBound.y = k + this.m_radius;
		},
		ComputeMass: function (a, b) {
			a.mass = 0;
			a.center = L.Multiply(.5, L.Add(this.m_vertex1, this.m_vertex2));
			a.I = 0;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.m_vertex1 = this.m_vertex1._serialize();
			b.m_vertex2 = this.m_vertex2._serialize();
			b.m_hasVertex0 = this.m_hasVertex0;
			if (this.m_hasVertex0) b.m_vertex0 = this.m_vertex0._serialize();
			b.m_hasVertex3 = this.m_hasVertex3;
			if (this.m_hasVertex3) b.m_vertex3 = this.m_vertex3._serialize();
			return b;
		},
		_deserialize: function (a) {
			this.parent.prototype._deserialize.call(this, a);
			this.m_vertex1._deserialize(a.m_vertex1);
			this.m_vertex2._deserialize(a.m_vertex2);
			this.m_hasVertex0 = a.m_hasVertex0;
			if (this.m_hasVertex0) this.m_vertex0._deserialize(a.m_vertex0);
			this.m_hasVertex3 = a.m_hasVertex3;
			if (this.m_hasVertex3) this.m_vertex3._deserialize(a.m_vertex3);
		}
	};
	Fb._extend(Db);
	function Gb() {
		this.parent.call(this);
		this.m_type = Db.e_chain;
		this.m_radius = k;
		this.m_vertices = null;
		this.m_count = 0;
		this.m_prevVertex = new L();
		this.m_nextVertex = new L();
		this.m_hasPrevVertex = false;
		this.m_hasNextVertex = false;
		Object.seal(this);
	}
	Gb.prototype = {
		CreateLoop: function (a, b) {
			for (var c = 1; c < b; ++c) {
				var d = a[c - 1];
				var e = a[c];
			}
			this.m_count = b + 1;
			this.m_vertices = new Array(this.m_count);
			for (var c = 0; c < b; ++c) this.m_vertices[c] = a[c].Clone();
			this.m_vertices[b] = this.m_vertices[0].Clone();
			this.m_prevVertex.Assign(this.m_vertices[this.m_count - 2]);
			this.m_nextVertex.Assign(this.m_vertices[1]);
			this.m_hasPrevVertex = true;
			this.m_hasNextVertex = true;
		},
		CreateChain: function (a, b) {
			for (var c = 1; c < b; ++c) {
				var d = a[c - 1];
				var e = a[c];
			}
			this.m_count = b;
			this.m_vertices = new Array(b);
			for (var c = 0; c < b; ++c) this.m_vertices[c] = a[c].Clone();
			this.m_hasPrevVertex = false;
			this.m_hasNextVertex = false;
			this.m_prevVertex.SetZero();
			this.m_nextVertex.SetZero();
		},
		SetPrevVertex: function (a) {
			this.m_prevVertex.Assign(a);
			this.m_hasPrevVertex = true;
		},
		SetNextVertex: function (a) {
			this.m_nextVertex.Assign(a);
			this.m_hasNextVertex = true;
		},
		Clone: function () {
			var a = new Gb();
			a.m_count = this.m_count;
			a.m_vertices = new Array(this.m_count);
			for (var b = 0; b < this.m_count; ++b) a.m_vertices[b] = this.m_vertices[b].Clone();
			a.m_prevVertex = this.m_prevVertex.Clone();
			a.m_nextVertex = this.m_nextVertex.Clone();
			a.m_hasPrevVertex = this.m_hasPrevVertex;
			a.m_hasNextVertex = this.m_hasNextVertex;
			return a;
		},
		GetChildCount: function () {
			return this.m_count - 1;
		},
		GetChildEdge: function (a, b) {
			a.m_type = Db.e_edge;
			a.m_radius = this.m_radius;
			a.m_vertex1 = this.m_vertices[b + 0];
			a.m_vertex2 = this.m_vertices[b + 1];
			if (b > 0) {
				a.m_vertex0 = this.m_vertices[b - 1];
				a.m_hasVertex0 = true;
			} else {
				a.m_vertex0 = this.m_prevVertex;
				a.m_hasVertex0 = this.m_hasPrevVertex;
			}
			if (b < this.m_count - 2) {
				a.m_vertex3 = this.m_vertices[b + 2];
				a.m_hasVertex3 = true;
			} else {
				a.m_vertex3 = this.m_nextVertex;
				a.m_hasVertex3 = this.m_hasNextVertex;
			}
		},
		TestPoint: function (a, b) {
			return false;
		},
		RayCast: function (a, b, c, d) {
			var e = new Fb();
			var f = d;
			var g = d + 1;
			if (g == this.m_count) g = 0;
			e.m_vertex1 = this.m_vertices[f].Clone();
			e.m_vertex2 = this.m_vertices[g].Clone();
			return e.RayCast(a, b, c, 0);
		},
		ComputeAABB: function (a, b, c) {
			var d = c;
			var e = c + 1;
			if (e == this.m_count) e = 0;
			var f = b.q.c * this.m_vertices[d].x - b.q.s * this.m_vertices[d].y + b.p.x;
			var g = b.q.s * this.m_vertices[d].x + b.q.c * this.m_vertices[d].y + b.p.y;
			var h = b.q.c * this.m_vertices[e].x - b.q.s * this.m_vertices[e].y + b.p.x;
			var i = b.q.s * this.m_vertices[e].x + b.q.c * this.m_vertices[e].y + b.p.y;
			a.lowerBound.x = pb(f, h);
			a.lowerBound.y = pb(g, i);
			a.upperBound.x = rb(f, h);
			a.upperBound.y = rb(g, i);
		},
		ComputeMass: function (a, b) {
			a.mass = 0;
			a.center.SetZero();
			a.I = 0;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.m_count = this.m_count;
			b.m_vertices = [];
			for (var c = 0; c < this.m_count; ++c) b.m_vertices.push(this.m_vertices[c]._serialize());
			b.m_hasPrevVertex = this.m_hasPrevVertex;
			if (this.m_hasPrevVertex) b.m_prevVertex = this.m_prevVertex._serialize();
			b.m_hasNextVertex = this.m_hasNextVertex;
			if (this.m_hasNextVertex) b.m_nextVertex = this.m_nextVertex._serialize();
			return b;
		},
		_deserialize: function (a) {
			this.parent.prototype._deserialize.call(this, a);
			this.m_count = a.m_count;
			this.m_vertices = [];
			for (var b = 0; b < this.m_count; ++b) {
				this.m_vertices[b] = new L();
				this.m_vertices[b]._deserialize(a.m_vertices[b]);
			}
			this.m_hasPrevVertex = a.m_hasPrevVertex;
			if (this.m_hasPrevVertex) this.m_prevVertex._deserialize(a.m_prevVertex);
			this.m_hasNextVertex = a.m_hasNextVertex;
			if (this.m_hasNextVertex) this.m_nextVertex._deserialize(a.m_nextVertex);
		}
	};
	Gb._extend(Db);
	function Hb() {
		this.parent.call(this);
		this.m_type = Db.e_polygon;
		this.m_radius = k;
		this.m_count = 0;
		this.m_centroid = new L();
		this.m_vertices = new Array(f);
		this.m_normals = new Array(f);
		Object.seal(this);
	}
	Hb.prototype = {
		Clone: function () {
			var a = new Hb();
			a.m_count = this.m_count;
			a.m_centroid = this.m_centroid.Clone();
			for (var b = 0; b < this.m_count; ++b) {
				a.m_vertices[b] = this.m_vertices[b].Clone();
				a.m_normals[b] = this.m_normals[b].Clone();
			}
			return a;
		},
		GetChildCount: function () {
			return 1;
		},
		Set: function (a, b) {
			if (b < 3) {
				this.SetAsBox(1, 1);
				return;
			}
			var c = pb(b, f);
			var d = new Array(f);
			var e = 0;
			for (var g = 0; g < c; ++g) {
				var h = a[g];
				var j = true;
				for (var k = 0; k < e; ++k) if (Z(h, d[k]) < .5 * i) {
					j = false;
					break;
				}
				if (j) d[e++] = h.Clone();
			}
			c = e;
			if (c < 3) {
				this.SetAsBox(1, 1);
				return;
			}
			var l = 0;
			var m = d[0].x;
			for (g = 1; g < c; ++g) {
				var n = d[g].x;
				if (n > m || n == m && d[g].y < d[l].y) {
					l = g;
					m = n;
				}
			}
			var o = new Array(f);
			var p = 0;
			var q = l;
			for (; ;) {
				o[p] = q;
				var r = 0;
				for (k = 1; k < c; ++k) {
					if (r == q) {
						r = k;
						continue;
					}
					var s = L.Subtract(d[r], d[o[p]]);
					var h = L.Subtract(d[k], d[o[p]]);
					var t = T(s, h);
					if (t < 0) r = k;
					if (0 == t && h.LengthSquared() > s.LengthSquared()) r = k;
				}
				++p;
				q = r;
				if (r == l) break;
			}
			this.m_count = p;
			for (g = 0; g < p; ++g) this.m_vertices[g] = d[o[g]].Clone();
			for (g = 0; g < p; ++g) {
				var u = g;
				var v = g + 1 < p ? g + 1 : 0;
				var w = L.Subtract(this.m_vertices[v], this.m_vertices[u]);
				this.m_normals[g] = U(w, 1).Clone();
				this.m_normals[g].Normalize();
			}
			this.m_centroid = Hb.ComputeCentroid(this.m_vertices, p);
		},
		SetAsBox: function (a, b, c, d) {
			this.m_count = 4;
			this.m_vertices[0] = new L(-a, -b);
			this.m_vertices[1] = new L(a, -b);
			this.m_vertices[2] = new L(a, b);
			this.m_vertices[3] = new L(-a, b);
			this.m_normals[0] = new L(0, -1);
			this.m_normals[1] = new L(1, 0);
			this.m_normals[2] = new L(0, 1);
			this.m_normals[3] = new L(-1, 0);
			if (!c) return;
			this.m_centroid.Assign(c);
			var e = new Q();
			e.p = c;
			e.q.Set(d);
			for (var f = 0; f < this.m_count; ++f) {
				this.m_vertices[f].Assign(ib(e, this.m_vertices[f]));
				this.m_normals[f].Assign(gb(e.q, this.m_normals[f]));
			}
		},
		TestPoint: function (a, b) {
			var c = hb(a.q, L.Subtract(b, a.p));
			for (var d = 0; d < this.m_count; ++d) {
				var e = S(this.m_normals[d], L.Subtract(c, this.m_vertices[d]));
				if (e > 0) return false;
			}
			return true;
		},
		RayCast: function (a, b, c, d) {
			var e = hb(c.q, L.Subtract(b.p1, c.p));
			var f = hb(c.q, L.Subtract(b.p2, c.p));
			var g = L.Subtract(f, e);
			var h = 0, i = b.maxFraction;
			var j = -1;
			for (var k = 0; k < this.m_count; ++k) {
				var l = S(this.m_normals[k], L.Subtract(this.m_vertices[k], e));
				var m = S(this.m_normals[k], g);
				if (0 == m) {
					if (l < 0) return false;
				} else if (m < 0 && l < h * m) {
					h = l / m;
					j = k;
				} else if (m > 0 && l < i * m) i = l / m;
				if (i < h) return false;
			}
			if (j >= 0) {
				a.fraction = h;
				a.normal = gb(c.q, this.m_normals[j]);
				return true;
			}
			return false;
		},
		ComputeAABB: function (a, b, c) {
			var d = b.q.c * this.m_vertices[0].x - b.q.s * this.m_vertices[0].y + b.p.x;
			var e = b.q.s * this.m_vertices[0].x + b.q.c * this.m_vertices[0].y + b.p.y;
			var f = d;
			var g = e;
			for (var h = 1; h < this.m_count; ++h) {
				var i = b.q.c * this.m_vertices[h].x - b.q.s * this.m_vertices[h].y + b.p.x;
				var j = b.q.s * this.m_vertices[h].x + b.q.c * this.m_vertices[h].y + b.p.y;
				d = pb(d, i);
				e = pb(e, j);
				f = rb(f, i);
				g = rb(g, j);
			}
			a.lowerBound.x = d - this.m_radius;
			a.lowerBound.y = e - this.m_radius;
			a.upperBound.x = f + this.m_radius;
			a.upperBound.y = g + this.m_radius;
		},
		ComputeMass: function (a, b) {
			var c = new L(0, 0);
			var d = 0;
			var e = 0;
			var f = new L(0, 0);
			for (var g = 0; g < this.m_count; ++g) f.Add(this.m_vertices[g]);
			f.Multiply(1 / this.m_count);
			var h = 1 / 3;
			for (var g = 0; g < this.m_count; ++g) {
				var i = L.Subtract(this.m_vertices[g], f);
				var j = g + 1 < this.m_count ? L.Subtract(this.m_vertices[g + 1], f) : L.Subtract(this.m_vertices[0], f);
				var k = T(i, j);
				var l = .5 * k;
				d += l;
				c.Add(L.Multiply(l * h, L.Add(i, j)));
				var m = i.x, n = i.y;
				var o = j.x, p = j.y;
				var q = m * m + o * m + o * o;
				var r = n * n + p * n + p * p;
				e += .25 * h * k * (q + r);
			}
			a.mass = b * d;
			c.Multiply(1 / d);
			a.center = L.Add(c, f);
			a.I = b * e;
			a.I += a.mass * (S(a.center, a.center) - S(c, c));
		},
		GetVertexCount: function () {
			return this.m_count;
		},
		GetVertex: function (a) {
			return this.m_vertices[a];
		},
		Validate: function () {
			for (var a = 0; a < this.m_count; ++a) {
				var b = a;
				var c = a < this.m_count - 1 ? b + 1 : 0;
				var d = this.m_vertices[b];
				var e = L.Subtract(this.m_vertices[c], d);
				for (var f = 0; f < this.m_count; ++f) {
					if (f == b || f == c) continue;
					var g = L.Subtract(this.m_vertices[f], d);
					var h = T(e, g);
					if (h < 0) return false;
				}
			}
			return true;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.m_count = this.m_count;
			b.m_centroid = this.m_centroid._serialize();
			b.m_vertices = [];
			b.m_normals = [];
			for (var c = 0; c < this.m_count; ++c) {
				b.m_vertices.push(this.m_vertices[c]._serialize());
				b.m_normals.push(this.m_normals[c]._serialize());
			}
			return b;
		},
		_deserialize: function (a) {
			this.parent.prototype._deserialize.call(this, a);
			this.m_count = a.m_count;
			this.m_centroid._deserialize(a.m_centroid);
			this.m_vertices = [];
			this.m_normals = [];
			for (var b = 0; b < this.m_count; ++b) {
				this.m_vertices[b] = new L();
				this.m_vertices[b]._deserialize(a.m_vertices[b]);
				this.m_normals[b] = new L();
				this.m_normals[b]._deserialize(a.m_normals[b]);
			}
		}
	};
	Hb.ComputeCentroid = function (a, b) {
		var c = new L();
		var d = 0;
		var e = new L(0, 0);
		var f = 1 / 3;
		for (var g = 0; g < b; ++g) {
			var h = e;
			var i = a[g];
			var j = g + 1 < b ? a[g + 1] : a[0];
			var k = L.Subtract(i, h);
			var l = L.Subtract(j, h);
			var m = T(k, l);
			var n = .5 * m;
			d += n;
			c.Add(L.Multiply(n, L.Multiply(f, L.Add(L.Add(h, i), j))));
		}
		c.Multiply(1 / d);
		return c;
	};
	Hb._extend(Db);
	function Ib() {
		this.proxyIdA = 0;
		this.proxyIdB = 0;
	}
	function Jb(a, b) {
		if (a.proxyIdA == b.proxyIdA) return a.proxyIdB - b.proxyIdB;
		return a.proxyIdA - b.proxyIdA;
	}
	function Kb() {
		this.m_tree = new tc();
		this.m_queryProxyId = 0;
		this.m_proxyCount = 0;
		this.m_pairCount = 0;
		this.m_pairBuffer = [];
		this.m_moveCount = 0;
		this.m_moveBuffer = [];
	}
	Kb.prototype = {
		CreateProxy: function (a, b) {
			var c = this.m_tree.CreateProxy(a, b);
			++this.m_proxyCount;
			this.BufferMove(c);
			return c;
		},
		DestroyProxy: function (a) {
			this.UnBufferMove(a);
			--this.m_proxyCount;
			this.m_tree.DestroyProxy(a);
		},
		MoveProxy: function (a, b, c) {
			var d = this.m_tree.MoveProxy(a, b, c);
			if (d) this.BufferMove(a);
		},
		TouchProxy: function (a) {
			this.BufferMove(a);
		},
		GetFatAABB: function (a) {
			return this.m_tree.GetFatAABB(a);
		},
		GetUserData: function (a) {
			return this.m_tree.GetUserData(a);
		},
		TestOverlap: function (a, b) {
			var c = this.m_tree.GetFatAABB(a);
			var d = this.m_tree.GetFatAABB(b);
			return qc(c, d);
		},
		GetProxyCount: function () {
			return this.m_proxyCount;
		},
		UpdatePairs: function (a) {
			this.m_pairCount = 0;
			this.m_pairBuffer.length = 0;
			for (var b = 0; b < this.m_moveCount; ++b) {
				this.m_queryProxyId = this.m_moveBuffer[b];
				if (this.m_queryProxyId == Kb.e_nullProxy) continue;
				var c = this.m_tree.GetFatAABB(this.m_queryProxyId);
				this.m_tree.Query(this, c);
			}
			this.m_moveCount = 0;
			this.m_pairBuffer.sort(Jb);
			var b = 0;
			while (b < this.m_pairCount) {
				var d = this.m_pairBuffer[b];
				var e = this.m_tree.GetUserData(d.proxyIdA);
				var f = this.m_tree.GetUserData(d.proxyIdB);
				a.AddPair(e, f);
				++b;
				while (b < this.m_pairCount) {
					var g = this.m_pairBuffer[b];
					if (g.proxyIdA != d.proxyIdA || g.proxyIdB != d.proxyIdB) break;
					++b;
				}
			}
		},
		Query: function (a, b) {
			this.m_tree.Query(a, b);
		},
		RayCast: function (a, b) {
			this.m_tree.RayCast(a, b);
		},
		GetTreeHeight: function () {
			return this.m_tree.GetHeight();
		},
		GetTreeBalance: function () {
			return this.m_tree.GetMaxBalance();
		},
		GetTreeQuality: function () {
			return this.m_tree.GetAreaRatio();
		},
		ShiftOrigin: function (a) {
			this.m_tree.ShiftOrigin(a);
		},
		BufferMove: function (a) {
			this.m_moveBuffer[this.m_moveCount] = a;
			++this.m_moveCount;
		},
		UnBufferMove: function (a) {
			for (var b = 0; b < this.m_moveCount; ++b) if (this.m_moveBuffer[b] == a) this.m_moveBuffer[b] = Kb.e_nullProxy;
		},
		QueryCallback: function (a) {
			if (a == this.m_queryProxyId) return true;
			this.m_pairBuffer[this.m_pairCount] = new Ib();
			this.m_pairBuffer[this.m_pairCount].proxyIdA = pb(a, this.m_queryProxyId);
			this.m_pairBuffer[this.m_pairCount].proxyIdB = rb(a, this.m_queryProxyId);
			++this.m_pairCount;
			return true;
		}
	};
	Kb.e_nullProxy = -1;
	function Lb() {
		this.m_vertices = null;
		this.m_count = 0;
		this.m_radius = 0;
	}
	Lb.prototype = {
		Assign: function (a) {
			this.m_vertices = a.m_vertices;
			this.m_count = a.m_count;
			this.m_radius = a.m_radius;
		},
		Set: function (a, b) {
			switch (a.GetType()) {
				case Db.e_circle:
					var c = a;
					this.m_vertices = [c.m_p];
					this.m_count = 1;
					this.m_radius = c.m_radius;
					break;

				case Db.e_polygon:
					var d = a;
					this.m_vertices = d.m_vertices;
					this.m_count = d.m_count;
					this.m_radius = d.m_radius;
					break;

				case Db.e_chain:
					var e = a;
					this.m_vertices = [e.m_vertices[b]];
					if (b + 1 < e.m_count) this.m_vertices[1] = e.m_vertices[b + 1]; else this.m_vertices[1] = e.m_vertices[0];
					this.m_count = 2;
					this.m_radius = e.m_radius;
					break;

				case Db.e_edge:
					var f = a;
					this.m_vertices = [f.m_vertex1, f.m_vertex2];
					this.m_count = 2;
					this.m_radius = f.m_radius;
			}
		},
		GetSupport: function (a, b) {
			var c = 0;
			var d = this.m_vertices[0].x * a + this.m_vertices[0].y * b;
			for (var e = 1; e < this.m_count; ++e) {
				var f = this.m_vertices[e].x * a + this.m_vertices[e].y * b;
				if (f > d) {
					c = e;
					d = f;
				}
			}
			return c;
		},
		GetSupportVertex: function (a, b) {
			return this.m_vertices[this.GetSupport(a, b)];
		},
		GetVertexCount: function () {
			return this.m_count;
		},
		GetVertex: function (a) {
			return this.m_vertices[a];
		}
	};
	function Mb() {
		this.metric = 0;
		this.count = 0;
		this.indexA = [0, 0, 0];
		this.indexB = [0, 0, 0];
	}
	function Nb() {
		this.proxyA = new Lb();
		this.proxyB = new Lb();
		this.transformA = new Q();
		this.transformB = new Q();
		this.useRadii = false;
	}
	function Ob() {
		this.pointA = new L();
		this.pointB = new L();
		this.distance = 0;
		this.iterations = 0;
	}
	function Pb() {
		this.wA = new L();
		this.wB = new L();
		this.w = new L();
		this.a = 0;
		this.indexA = 0;
		this.indexB = 0;
	}
	Pb.prototype = {
		Assign: function (a) {
			this.wA.x = a.wA.x;
			this.wA.y = a.wA.y;
			this.wB.x = a.wB.x;
			this.wB.y = a.wB.y;
			this.w.x = a.w.x;
			this.w.y = a.w.y;
			this.a = a.a;
			this.indexA = a.indexA;
			this.indexB = a.indexB;
		}
	};
	function Qb() {
		this.m_v = [new Pb(), new Pb(), new Pb()];
		this.m_count = 0;
	}
	Qb.prototype = {
		ReadCache: function (a, b, d, e, f) {
			this.m_count = a.count;
			var g = this.m_v;
			for (var h = 0; h < this.m_count; ++h) {
				var i = g[h];
				i.indexA = a.indexA[h];
				i.indexB = a.indexB[h];
				var j = b.GetVertex(i.indexA);
				var k = e.GetVertex(i.indexB);
				i.wA.x = d.q.c * j.x - d.q.s * j.y + d.p.x;
				i.wA.y = d.q.s * j.x + d.q.c * j.y + d.p.y;
				i.wB.x = f.q.c * k.x - f.q.s * k.y + f.p.x;
				i.wB.y = f.q.s * k.x + f.q.c * k.y + f.p.y;
				i.w.x = i.wB.x - i.wA.x;
				i.w.y = i.wB.y - i.wA.y;
				i.a = 0;
			}
			if (this.m_count > 1) {
				var l = a.metric;
				var m = this.GetMetric();
				if (m < .5 * l || 2 * l < m || m < c) this.m_count = 0;
			}
			if (0 == this.m_count) {
				var i = g[0];
				i.indexA = 0;
				i.indexB = 0;
				var j = b.GetVertex(0);
				var k = e.GetVertex(0);
				i.wA.x = d.q.c * j.x - d.q.s * j.y + d.p.x;
				i.wA.y = d.q.s * j.x + d.q.c * j.y + d.p.y;
				i.wB.x = f.q.c * k.x - f.q.s * k.y + f.p.x;
				i.wB.y = f.q.s * k.x + f.q.c * k.y + f.p.y;
				i.w.x = i.wB.x - i.wA.x;
				i.w.y = i.wB.y - i.wA.y;
				i.a = 1;
				this.m_count = 1;
			}
		},
		WriteCache: function (a) {
			a.metric = this.GetMetric();
			a.count = this.m_count;
			var b = this.m_v;
			for (var c = 0; c < this.m_count; ++c) {
				a.indexA[c] = b[c].indexA;
				a.indexB[c] = b[c].indexB;
			}
		},
		GetSearchDirection: function (a) {
			switch (this.m_count) {
				case 1:
					a.x = -this.m_v[0].w.x;
					a.y = -this.m_v[0].w.y;
					break;

				case 2:
					var b = this.m_v[1].w.x - this.m_v[0].w.x;
					var c = this.m_v[1].w.y - this.m_v[0].w.y;
					var d = b * -this.m_v[0].w.y - c * -this.m_v[0].w.x;
					if (d > 0) {
						a.x = -1 * c;
						a.y = 1 * b;
					} else {
						a.x = 1 * c;
						a.y = -1 * b;
					}
			}
		},
		GetClosestPoint: function (a) {
			switch (this.m_count) {
				case 1:
					a.x = this.m_v[0].w.x;
					a.y = this.m_v[0].w.y;
					break;

				case 2:
					a.x = this.m_v[0].a * this.m_v[0].w.x + this.m_v[1].a * this.m_v[1].w.x;
					a.y = this.m_v[0].a * this.m_v[0].w.y + this.m_v[1].a * this.m_v[1].w.y;
					break;

				case 3:
					a.x = a.y = 0;
			}
		},
		GetWitnessPoints: function (a, b) {
			switch (this.m_count) {
				case 1:
					a.x = this.m_v[0].wA.x;
					a.y = this.m_v[0].wA.y;
					b.x = this.m_v[0].wB.x;
					b.y = this.m_v[0].wB.y;
					break;

				case 2:
					a.x = this.m_v[0].a * this.m_v[0].wA.x + this.m_v[1].a * this.m_v[1].wA.x;
					a.y = this.m_v[0].a * this.m_v[0].wA.y + this.m_v[1].a * this.m_v[1].wA.y;
					b.x = this.m_v[0].a * this.m_v[0].wB.x + this.m_v[1].a * this.m_v[1].wB.x;
					b.y = this.m_v[0].a * this.m_v[0].wB.y + this.m_v[1].a * this.m_v[1].wB.y;
					break;

				case 3:
					a.x = (this.m_v[0].a, this.m_v[0].wA.x) + (this.m_v[1].a, this.m_v[1].wA.x) + (this.m_v[2].a,
						this.m_v[2].wA.x);
					a.y = (this.m_v[0].a, this.m_v[0].wA.y) + (this.m_v[1].a, this.m_v[1].wA.y) + (this.m_v[2].a,
						this.m_v[2].wA.y);
					b.x = a.x;
					b.y = a.y;
			}
		},
		GetMetric: function () {
			switch (this.m_count) {
				case 1:
					return 0;

				case 2:
					return Y(this.m_v[0].w, this.m_v[1].w);

				case 3:
					return (this.m_v[1].w.x - this.m_v[0].w.x) * (this.m_v[2].w.y - this.m_v[0].w.y) - (this.m_v[1].w.y - this.m_v[0].w.y) * (this.m_v[2].w.x - this.m_v[0].w.x);
			}
		},
		Solve2: function () {
			var a = this.m_v[0].w;
			var b = this.m_v[1].w;
			var c = b.x - a.x;
			var d = b.y - a.y;
			var e = -(a.x * c + a.y * d);
			if (e <= 0) {
				this.m_v[0].a = 1;
				this.m_count = 1;
				return;
			}
			var f = b.x * c + b.y * d;
			if (f <= 0) {
				this.m_v[1].a = 1;
				this.m_count = 1;
				this.m_v[0].Assign(this.m_v[1]);
				return;
			}
			var g = 1 / (f + e);
			this.m_v[0].a = f * g;
			this.m_v[1].a = e * g;
			this.m_count = 2;
		},
		Solve3: function () {
			var a = this.m_v[0].w;
			var b = this.m_v[1].w;
			var c = this.m_v[2].w;
			var d = b.x - a.x;
			var e = b.y - a.y;
			var f = a.x * d + a.y * e;
			var g = b.x * d + b.y * e;
			var h = g;
			var i = -f;
			var j = c.x - a.x;
			var k = c.y - a.y;
			var l = a.x * j + a.y * k;
			var m = c.x * j + c.y * k;
			var n = m;
			var o = -l;
			var p = c.x - b.x;
			var q = c.y - b.y;
			var r = b.x * p + b.y * q;
			var s = c.x * p + c.y * q;
			var t = s;
			var u = -r;
			var v = d * k - e * j;
			var w = v * (b.x * c.y - b.y * c.x);
			var x = v * (c.x * a.y - c.y * a.x);
			var y = v * (a.x * b.y - a.y * b.x);
			if (i <= 0 && o <= 0) {
				this.m_v[0].a = 1;
				this.m_count = 1;
				return;
			}
			if (h > 0 && i > 0 && y <= 0) {
				var z = 1 / (h + i);
				this.m_v[0].a = h * z;
				this.m_v[1].a = i * z;
				this.m_count = 2;
				return;
			}
			if (n > 0 && o > 0 && x <= 0) {
				var A = 1 / (n + o);
				this.m_v[0].a = n * A;
				this.m_v[2].a = o * A;
				this.m_count = 2;
				this.m_v[1].Assign(this.m_v[2]);
				return;
			}
			if (h <= 0 && u <= 0) {
				this.m_v[1].a = 1;
				this.m_count = 1;
				this.m_v[0].Assign(this.m_v[1]);
				return;
			}
			if (n <= 0 && t <= 0) {
				this.m_v[2].a = 1;
				this.m_count = 1;
				this.m_v[0].Assign(this.m_v[2]);
				return;
			}
			if (t > 0 && u > 0 && w <= 0) {
				var B = 1 / (t + u);
				this.m_v[1].a = t * B;
				this.m_v[2].a = u * B;
				this.m_count = 2;
				this.m_v[0].Assign(this.m_v[2]);
				return;
			}
			var C = 1 / (w + x + y);
			this.m_v[0].a = w * C;
			this.m_v[1].a = x * C;
			this.m_v[2].a = y * C;
			this.m_count = 3;
		}
	};
	var Rb = new Qb();
	var Sb = new L();
	var Tb = new L();
	function Ub(a, d, e) {
		++Ub.b2_gjkCalls;
		var f = e.proxyA;
		var g = e.proxyB;
		var h = e.transformA;
		var i = e.transformB;
		Rb.ReadCache(d, f, h, g, i);
		var j = Rb.m_v;
		var k = 20;
		var l = [0, 0, 0], m = [0, 0, 0];
		var n = 0;
		var o = b;
		var p = o;
		var q = 0;
		while (q < k) {
			n = Rb.m_count;
			for (var r = 0; r < n; ++r) {
				l[r] = j[r].indexA;
				m[r] = j[r].indexB;
			}
			switch (Rb.m_count) {
				case 1:
					break;

				case 2:
					Rb.Solve2();
					break;

				case 3:
					Rb.Solve3();
			}
			if (3 == Rb.m_count) break;
			Rb.GetClosestPoint(Tb);
			p = Tb.LengthSquared();
			if (p >= o);
			o = p;
			Rb.GetSearchDirection(Tb);
			if (Tb.LengthSquared() < c * c) break;
			var s = j[Rb.m_count];
			s.indexA = f.GetSupport(h.q.c * -Tb.x + h.q.s * -Tb.y, -h.q.s * -Tb.x + h.q.c * -Tb.y);
			var t = f.GetVertex(s.indexA);
			s.wA.x = h.q.c * t.x - h.q.s * t.y + h.p.x;
			s.wA.y = h.q.s * t.x + h.q.c * t.y + h.p.y;
			s.indexB = g.GetSupport(i.q.c * Tb.x + i.q.s * Tb.y, -i.q.s * Tb.x + i.q.c * Tb.y);
			var u = g.GetVertex(s.indexB);
			s.wB.x = i.q.c * u.x - i.q.s * u.y + i.p.x;
			s.wB.y = i.q.s * u.x + i.q.c * u.y + i.p.y;
			s.w.x = s.wB.x - s.wA.x;
			s.w.y = s.wB.y - s.wA.y;
			++q;
			++Ub.b2_gjkIters;
			var v = false;
			for (var r = 0; r < n; ++r) if (s.indexA == l[r] && s.indexB == m[r]) {
				v = true;
				break;
			}
			if (v) break;
			++Rb.m_count;
		}
		Ub.b2_gjkMaxIters = rb(Ub.b2_gjkMaxIters, q);
		Rb.GetWitnessPoints(a.pointA, a.pointB);
		a.distance = Y(a.pointA, a.pointB);
		a.iterations = q;
		Rb.WriteCache(d);
		if (e.useRadii) {
			var w = f.m_radius;
			var x = g.m_radius;
			if (a.distance > w + x && a.distance > c) {
				a.distance -= w + x;
				Sb.x = a.pointB.x - a.pointA.x;
				Sb.y = a.pointB.y - a.pointA.y;
				Sb.Normalize();
				a.pointA.x += w * Sb.x;
				a.pointA.y += w * Sb.y;
				a.pointB.x -= x * Sb.x;
				a.pointB.y -= x * Sb.y;
			} else {
				var y = .5 * (a.pointA.x + a.pointB.x);
				var z = .5 * (a.pointA.y + a.pointB.y);
				a.pointA.x = y;
				a.pointA.y = z;
				a.pointB.x = y;
				a.pointB.y = z;
				a.distance = 0;
			}
		}
	}
	Ub.b2_gjkCalls = 0;
	Ub.b2_gjkIters = 0;
	Ub.b2_gjkMaxIters = 0;
	var Vb = 255;
	function Wb() { }
	Wb.prototype = {
		indexA: 0,
		indexB: 0,
		typeA: 0,
		typeB: 0,
		Reset: function () {
			this.indexA = this.indexB = this.typeA = this.typeB = 0;
		},
		Get: function () {
			return this.indexA | this.indexB << 8 | this.typeA << 16 | this.typeB << 24;
		},
		Assign: function (a) {
			this.indexA = a.indexA;
			this.indexB = a.indexB;
			this.typeA = a.typeA;
			this.typeB = a.typeB;
		}
	};
	Wb.e_vertex = 0;
	Wb.e_face = 1;
	function Xb() {
		this.localPoint = new L();
		this.normalImpulse = 0;
		this.tangentImpulse = 0;
		this.id = new Wb();
	}
	Xb.prototype = {
		Clone: function () {
			var a = new Xb();
			a.localPoint.x = this.localPoint.x;
			a.localPoint.y = this.localPoint.y;
			a.normalImpulse = this.normalImpulse;
			a.tangentImpulse = this.tangentImpulse;
			a.id.Assign(this.id);
			return a;
		}
	};
	function Yb() {
		this.points = new Array(e);
		this.localNormal = new L();
		this.localPoint = new L();
		this.type = 0;
		this.pointCount = 0;
	}
	Yb.prototype = {
		Clone: function () {
			var a = new Yb();
			a.pointCount = this.pointCount;
			a.type = this.type;
			a.localPoint.x = this.localPoint.x;
			a.localPoint.y = this.localPoint.y;
			a.localNormal.x = this.localNormal.x;
			a.localNormal.y = this.localNormal.y;
			for (var b = 0; b < this.pointCount; ++b) a.points[b] = this.points[b].Clone();
			return a;
		},
		Assign: function (a) {
			this.pointCount = a.pointCount;
			this.type = a.type;
			this.localPoint.x = a.localPoint.x;
			this.localPoint.y = a.localPoint.y;
			this.localNormal.x = a.localNormal.x;
			this.localNormal.y = a.localNormal.y;
			for (var b = 0; b < this.pointCount; ++b) this.points[b] = a.points[b].Clone();
		}
	};
	Yb.e_circles = 0;
	Yb.e_faceA = 1;
	Yb.e_faceB = 2;
	Yb.b2_nullState = 0;
	Yb.b2_addState = 1;
	Yb.b2_persistState = 2;
	Yb.b2_removeState = 3;
	function Zb() {
		this.normal = new L();
		this.points = new Array(e);
		this.separations = new Array(e);
	}
	Zb.prototype = {
		Initialize: function (a, b, d, e, f) {
			if (0 == a.pointCount) return;
			switch (a.type) {
				case Yb.e_circles:
					this.normal.x = 1;
					this.normal.y = 0;
					var g = b.q.c * a.localPoint.x - b.q.s * a.localPoint.y + b.p.x;
					var h = b.q.s * a.localPoint.x + b.q.c * a.localPoint.y + b.p.y;
					var i = e.q.c * a.points[0].localPoint.x - e.q.s * a.points[0].localPoint.y + e.p.x;
					var j = e.q.s * a.points[0].localPoint.x + e.q.c * a.points[0].localPoint.y + e.p.y;
					var k = g - i;
					var l = h - j;
					if (k * k + l * l > c * c) {
						this.normal.x = i - g;
						this.normal.y = j - h;
						this.normal.Normalize();
					}
					var m = g + d * this.normal.x;
					var n = h + d * this.normal.y;
					var o = i - f * this.normal.x;
					var p = j - f * this.normal.y;
					this.points[0] = new L(.5 * (m + o), .5 * (n + p));
					this.separations[0] = (o - m) * this.normal.x + (p - n) * this.normal.y;
					break;

				case Yb.e_faceA:
					this.normal.x = b.q.c * a.localNormal.x - b.q.s * a.localNormal.y;
					this.normal.y = b.q.s * a.localNormal.x + b.q.c * a.localNormal.y;
					var q = b.q.c * a.localPoint.x - b.q.s * a.localPoint.y + b.p.x;
					var r = b.q.s * a.localPoint.x + b.q.c * a.localPoint.y + b.p.y;
					for (var s = 0; s < a.pointCount; ++s) {
						var t = e.q.c * a.points[s].localPoint.x - e.q.s * a.points[s].localPoint.y + e.p.x;
						var u = e.q.s * a.points[s].localPoint.x + e.q.c * a.points[s].localPoint.y + e.p.y;
						var v = (t - q) * this.normal.x + (u - r) * this.normal.y;
						var m = t + (d - v) * this.normal.x;
						var n = u + (d - v) * this.normal.y;
						var o = t - f * this.normal.x;
						var p = u - f * this.normal.y;
						this.points[s] = new L(.5 * (m + o), .5 * (n + p));
						this.separations[s] = (o - m) * this.normal.x + (p - n) * this.normal.y;
					}
					break;

				case Yb.e_faceB:
					this.normal.x = e.q.c * a.localNormal.x - e.q.s * a.localNormal.y;
					this.normal.y = e.q.s * a.localNormal.x + e.q.c * a.localNormal.y;
					var q = e.q.c * a.localPoint.x - e.q.s * a.localPoint.y + e.p.x;
					var r = e.q.s * a.localPoint.x + e.q.c * a.localPoint.y + e.p.y;
					for (var s = 0; s < a.pointCount; ++s) {
						var t = b.q.c * a.points[s].localPoint.x - b.q.s * a.points[s].localPoint.y + b.p.x;
						var u = b.q.s * a.points[s].localPoint.x + b.q.c * a.points[s].localPoint.y + b.p.y;
						var v = (t - q) * this.normal.x + (u - r) * this.normal.y;
						var o = t + (f - v) * this.normal.x;
						var p = u + (f - v) * this.normal.y;
						var m = t - d * this.normal.x;
						var n = u - d * this.normal.y;
						this.points[s] = new L(.5 * (m + o), .5 * (n + p));
						this.separations[s] = (m - o) * this.normal.x + (n - p) * this.normal.y;
					}
					this.normal.x = -this.normal.x;
					this.normal.y = -this.normal.y;
			}
		}
	};
	function $b(a, b, c, d) {
		for (var f = 0; f < e; ++f) {
			a[f] = Yb.b2_nullState;
			b[f] = Yb.b2_nullState;
		}
		for (var f = 0; f < c.pointCount; ++f) {
			var g = c.points[f].id;
			a[f] = Yb.b2_removeState;
			for (var h = 0; h < d.pointCount; ++h) if (d.points[h].id.Get() == g.Get()) {
				a[f] = Yb.b2_persistState;
				break;
			}
		}
		for (var f = 0; f < d.pointCount; ++f) {
			var g = d.points[f].id;
			b[f] = Yb.b2_addState;
			for (var h = 0; h < c.pointCount; ++h) if (c.points[h].id.Get() == g.Get()) {
				b[f] = Yb.b2_persistState;
				break;
			}
		}
	}
	function _b() {
		this.v = new L();
		this.id = new Wb();
	}
	function ac() {
		this.p1 = new L(), this.p2 = new L();
		this.maxFraction = 0;
	}
	function bc() {
		this.normal = new L();
		this.fraction = 0;
	}
	function cc() {
		this.lowerBound = new L();
		this.upperBound = new L();
	}
	cc.prototype = {
		Assign: function (a) {
			this.lowerBound.x = a.lowerBound.x;
			this.lowerBound.y = a.lowerBound.y;
			this.upperBound.x = a.upperBound.x;
			this.upperBound.y = a.upperBound.y;
		},
		Clone: function () {
			var a = new cc();
			a.lowerBound.x = this.lowerBound.x;
			a.lowerBound.y = this.lowerBound.y;
			a.lowerBound.x = this.lowerBound.x;
			a.lowerBound.y = this.lowerBound.y;
			return a;
		},
		IsValid: function () {
			return this.upperBound.x - this.lowerBound.x >= 0 && this.upperBound.y - this.lowerBound.y >= 0 && this.lowerBound.IsValid() && this.upperBound.IsValid();
		},
		GetCenter: function () {
			return new L(.5 * (this.lowerBound.x + this.upperBound.x), .5 * (this.lowerBound.y + this.upperBound.y));
		},
		GetExtents: function () {
			return new L(.5 * (this.upperBound.x - this.lowerBound.x), .5 * (this.upperBound.y - this.lowerBound.y));
		},
		GetPerimeter: function () {
			return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y));
		},
		Combine: function (a, b) {
			if (b) {
				this.lowerBound.x = pb(a.lowerBound.x, b.lowerBound.x);
				this.lowerBound.y = pb(a.lowerBound.y, b.lowerBound.y);
				this.upperBound.x = rb(a.upperBound.x, b.upperBound.x);
				this.upperBound.y = rb(a.upperBound.y, b.upperBound.y);
			} else {
				this.lowerBound.x = pb(this.lowerBound.x, a.lowerBound.x);
				this.lowerBound.y = pb(this.lowerBound.y, a.lowerBound.y);
				this.upperBound.x = rb(this.upperBound.x, a.upperBound.x);
				this.upperBound.y = rb(this.upperBound.y, a.upperBound.y);
			}
		},
		Contains: function (a) {
			return this.lowerBound.x <= a.lowerBound.x && this.lowerBound.y <= a.lowerBound.y && a.upperBound.x <= this.upperBound.x && a.upperBound.y <= this.upperBound.y;
		},
		RayCast: function (a, d) {
			var e = -b;
			var f = b;
			var g = d.p1;
			var h = L.Subtract(d.p2, d.p1);
			var i = nb(h);
			var j = new L();
			for (var k = 0; k < 2; ++k) if (i.get_i(k) < c) {
				if (g.get_i(k) < this.lowerBound.get_i(k) || this.upperBound.get_i(k) < g.get_i(k)) return false;
			} else {
				var l = 1 / h.get_i(k);
				var m = (this.lowerBound.get_i(k) - g.get_i(k)) * l;
				var n = (this.upperBound.get_i(k) - g.get_i(k)) * l;
				var o = -1;
				if (m > n) {
					var p = n;
					n = m;
					m = p;
					o = 1;
				}
				if (m > e) {
					j.x = j.y = 0;
					j.set_i(k, o);
					e = m;
				}
				f = pb(f, n);
				if (e > f) return false;
			}
			if (e < 0 || d.maxFraction < e) return false;
			a.fraction = e;
			a.normal.x = j.x;
			a.normal.y = j.y;
			return true;
		}
	};
	function dc(a, b, c, d, e) {
		a.pointCount = 0;
		var f = ib(c, b.m_p);
		var g = ib(e, d.m_p);
		var h = g.x - f.x;
		var i = g.y - f.y;
		var j = h * h + i * i;
		var k = b.m_radius, l = d.m_radius;
		var m = k + l;
		if (j > m * m) return;
		a.type = Yb.e_circles;
		a.localPoint.x = b.m_p.x;
		a.localPoint.y = b.m_p.y;
		a.localNormal.x = a.localNormal.y = 0;
		a.pointCount = 1;
		a.points[0] = new Xb();
		a.points[0].localPoint.x = d.m_p.x;
		a.points[0].localPoint.y = d.m_p.y;
		a.points[0].id.Reset();
	}
	function ec(a, d, e, f, g) {
		a.pointCount = 0;
		var h = ib(g, f.m_p);
		var i = jb(e, h);
		var j = 0;
		var k = -b;
		var l = d.m_radius + f.m_radius;
		var m = d.m_count;
		var n = d.m_vertices;
		var o = d.m_normals;
		for (var p = 0; p < m; ++p) {
			var q = o[p].x * (i.x - n[p].x) + o[p].y * (i.y - n[p].y);
			if (q > l) return;
			if (q > k) {
				k = q;
				j = p;
			}
		}
		var r = j;
		var s = r + 1 < m ? r + 1 : 0;
		var t = n[r];
		var u = n[s];
		if (k < c) {
			a.pointCount = 1;
			a.type = Yb.e_faceA;
			a.localNormal.x = o[j].x;
			a.localNormal.y = o[j].y;
			a.localPoint.x = .5 * (t.x + u.x);
			a.localPoint.y = .5 * (t.y + u.y);
			a.points[0] = new Xb();
			a.points[0].localPoint.x = f.m_p.x;
			a.points[0].localPoint.y = f.m_p.y;
			a.points[0].id.Reset();
			return;
		}
		var v = (i.x - t.x) * (u.x - t.x) + (i.y - t.y) * (u.y - t.y);
		var w = (i.x - u.x) * (t.x - u.x) + (i.y - u.y) * (t.y - u.y);
		if (v <= 0) {
			if (Z(i, t) > l * l) return;
			a.pointCount = 1;
			a.type = Yb.e_faceA;
			a.localNormal.x = i.x - t.x;
			a.localNormal.y = i.y - t.y;
			a.localNormal.Normalize();
			a.localPoint.x = t.x;
			a.localPoint.y = t.y;
			a.points[0] = new Xb();
			a.points[0].localPoint.x = f.m_p.x;
			a.points[0].localPoint.y = f.m_p.y;
			a.points[0].id.Reset();
		} else if (w <= 0) {
			if (Z(i, u) > l * l) return;
			a.pointCount = 1;
			a.type = Yb.e_faceA;
			a.localNormal.x = i.x - u.x;
			a.localNormal.y = i.y - u.y;
			a.localNormal.Normalize();
			a.localPoint.x = u.x;
			a.localPoint.y = u.y;
			a.points[0] = new Xb();
			a.points[0].localPoint.x = f.m_p.x;
			a.points[0].localPoint.y = f.m_p.y;
			a.points[0].id.Reset();
		} else {
			var x = .5 * (t.x + u.x);
			var y = .5 * (t.y + u.y);
			var k = (i.x - x) * o[r].x + (i.y - y) * o[r].y;
			if (k > l) return;
			a.pointCount = 1;
			a.type = Yb.e_faceA;
			a.localNormal.x = o[r].x;
			a.localNormal.y = o[r].y;
			a.localPoint.x = x;
			a.localPoint.y = y;
			a.points[0] = new Xb();
			a.points[0].localPoint.x = f.m_p.x;
			a.points[0].localPoint.y = f.m_p.y;
			a.points[0].id.Reset();
		}
	}
	function fc(a, c, d, e, f) {
		var g = c.m_count;
		var h = e.m_count;
		var i = c.m_normals;
		var j = c.m_vertices;
		var k = e.m_vertices;
		var l = lb(f, d);
		var m = 0;
		var n = -b;
		for (var o = 0; o < g; ++o) {
			var p = l.q.c * i[o].x - l.q.s * i[o].y;
			var q = l.q.s * i[o].x + l.q.c * i[o].y;
			var r = l.q.c * j[o].x - l.q.s * j[o].y + l.p.x;
			var s = l.q.s * j[o].x + l.q.c * j[o].y + l.p.y;
			var t = b;
			for (var u = 0; u < h; ++u) {
				var v = p * (k[u].x - r) + q * (k[u].y - s);
				if (v < t) t = v;
			}
			if (t > n) {
				n = t;
				m = o;
			}
		}
		a[0] = m;
		return n;
	}
	function gc(a, c, d, e, f, g) {
		var h = c.m_normals;
		var i = f.m_count;
		var j = f.m_vertices;
		var k = f.m_normals;
		var l = d.q.c * h[e].x - d.q.s * h[e].y;
		var m = d.q.s * h[e].x + d.q.c * h[e].y;
		var n = g.q.c * l + g.q.s * m;
		var o = -g.q.s * l + g.q.c * m;
		var p = 0;
		var q = b;
		for (var r = 0; r < i; ++r) {
			var s = n * k[r].x + o * k[r].y;
			if (s < q) {
				q = s;
				p = r;
			}
		}
		var t = p;
		var u = t + 1 < i ? t + 1 : 0;
		a[0].v.x = g.q.c * j[t].x - g.q.s * j[t].y + g.p.x;
		a[0].v.y = g.q.s * j[t].x + g.q.c * j[t].y + g.p.y;
		a[0].id.indexA = e;
		a[0].id.indexB = t;
		a[0].id.typeA = Wb.e_face;
		a[0].id.typeB = Wb.e_vertex;
		a[1].v.x = g.q.c * j[u].x - g.q.s * j[u].y + g.p.x;
		a[1].v.y = g.q.s * j[u].x + g.q.c * j[u].y + g.p.y;
		a[1].id.indexA = e;
		a[1].id.indexB = u;
		a[1].id.typeA = Wb.e_face;
		a[1].id.typeB = Wb.e_vertex;
	}
	function hc(a, b, c, d, f) {
		a.pointCount = 0;
		var g = b.m_radius + d.m_radius;
		var h = [0];
		var j = fc(h, b, c, d, f);
		if (j > g) return;
		var k = [0];
		var l = fc(k, d, f, b, c);
		if (l > g) return;
		var m;
		var n;
		var o, p;
		var q = 0;
		var r = 0;
		var s = .1 * i;
		if (l > j + s) {
			m = d;
			n = b;
			o = f;
			p = c;
			q = k[0];
			a.type = Yb.e_faceB;
			r = 1;
		} else {
			m = b;
			n = d;
			o = c;
			p = f;
			q = h[0];
			a.type = Yb.e_faceA;
			r = 0;
		}
		gc(hc._local_incidentEdges, m, o, q, n, p);
		var t = m.m_count;
		var u = m.m_vertices;
		var v = q;
		var w = q + 1 < t ? q + 1 : 0;
		var x = u[v];
		var y = u[w];
		hc._localTangent.x = y.x - x.x;
		hc._localTangent.y = y.y - x.y;
		hc._localTangent.Normalize();
		var z = 1 * hc._localTangent.y;
		var A = -1 * hc._localTangent.x;
		var B = .5 * (x.x + y.x);
		var C = .5 * (x.y + y.y);
		var D = o.q.c * hc._localTangent.x - o.q.s * hc._localTangent.y;
		var E = o.q.s * hc._localTangent.x + o.q.c * hc._localTangent.y;
		var F = 1 * E;
		var G = -1 * D;
		x = ib(o, x);
		y = ib(o, y);
		var H = F * x.x + G * x.y;
		var I = -(D * x.x + E * x.y) + g;
		var J = D * y.x + E * y.y + g;
		var K = new Array(2);
		var L = new Array(2);
		var M;
		M = oc(K, hc._local_incidentEdges, -D, -E, I, v);
		if (M < 2) return;
		M = oc(L, K, D, E, J, w);
		if (M < 2) return;
		a.localNormal.x = z;
		a.localNormal.y = A;
		a.localPoint.x = B;
		a.localPoint.y = C;
		var N = 0;
		for (var O = 0; O < e; ++O) {
			var P = F * L[O].v.x + G * L[O].v.y - H;
			if (P <= g) {
				var Q = a.points[N] = new Xb();
				Q.localPoint.Assign(jb(p, L[O].v));
				Q.id.Assign(L[O].id);
				if (r) {
					var R = new Wb();
					R.Assign(Q.id);
					Q.id.indexA = R.indexB;
					Q.id.indexB = R.indexA;
					Q.id.typeA = R.typeB;
					Q.id.typeB = R.typeA;
				}
				++N;
			}
		}
		a.pointCount = N;
	}
	hc._localTangent = new L();
	hc._local_incidentEdges = [new _b(), new _b()];
	function ic(a, b, c, d, e) {
		a.pointCount = 0;
		var f = jb(c, ib(e, d.m_p));
		var g = b.m_vertex1, h = b.m_vertex2;
		var i = h.x - g.x;
		var j = h.y - g.y;
		var k = i * (h.x - f.x) + j * (h.y - f.y);
		var l = i * (f.x - g.x) + j * (f.y - g.y);
		var m = b.m_radius + d.m_radius;
		var n = new Wb();
		n.indexB = 0;
		n.typeB = Wb.e_vertex;
		if (l <= 0) {
			var o = g;
			var p = f.x - o.x;
			var q = f.y - o.y;
			var r = p * p + q * q;
			if (r > m * m) return;
			if (b.m_hasVertex0) {
				var s = b.m_vertex0;
				var t = g;
				var u = t.x - s.x;
				var v = t.y - s.y;
				var w = u * (t.x - f.x) + v * (t.y - f.y);
				if (w > 0) return;
			}
			n.indexA = 0;
			n.typeA = Wb.e_vertex;
			a.pointCount = 1;
			a.type = Yb.e_circles;
			a.localNormal.x = a.localNormal.y = 0;
			a.localPoint.x = o.x;
			a.localPoint.y = o.y;
			a.points[0] = new Xb();
			a.points[0].id.Assign(n);
			a.points[0].localPoint.x = d.m_p.x;
			a.points[0].localPoint.y = d.m_p.y;
			return;
		}
		if (k <= 0) {
			var o = h;
			var p = f.x - o.x;
			var q = f.y - o.y;
			var r = p * p + q * q;
			if (r > m * m) return;
			if (b.m_hasVertex3) {
				var x = b.m_vertex3;
				var y = h;
				var z = x.x - y.x;
				var A = x.y - y.y;
				var B = z * (f.x - y.x) + A * (f.y - y.y);
				if (B > 0) return;
			}
			n.indexA = 1;
			n.typeA = Wb.e_vertex;
			a.pointCount = 1;
			a.type = Yb.e_circles;
			a.localNormal.x = a.localNormal.y = 0;
			a.localPoint.x = o.x;
			a.localPoint.y = o.y;
			a.points[0] = new Xb();
			a.points[0].id.Assign(n);
			a.points[0].localPoint.x = d.m_p.x;
			a.points[0].localPoint.y = d.m_p.y;
			return;
		}
		var C = i * i + j * j;
		var D = 1 / C * (k * g.x + l * h.x);
		var E = 1 / C * (k * g.y + l * h.y);
		var p = f.x - D;
		var q = f.y - E;
		var r = p * p + q * q;
		if (r > m * m) return;
		var F = -j;
		var G = i;
		if (F * (f.x - g.x) + G * (f.y - g.y) < 0) {
			F = -F;
			G = -G;
		}
		n.indexA = 0;
		n.typeA = Wb.e_face;
		a.pointCount = 1;
		a.type = Yb.e_faceA;
		a.localNormal.x = F;
		a.localNormal.y = G;
		a.localNormal.Normalize();
		a.localPoint.x = g.x;
		a.localPoint.y = g.y;
		a.points[0] = new Xb();
		a.points[0].id.Assign(n);
		a.points[0].localPoint.x = d.m_p.x;
		a.points[0].localPoint.y = d.m_p.y;
	}
	function jc() {
		this.type = 0;
		this.index = 0;
		this.separation = 0;
	}
	jc.e_unknown = 0;
	jc.e_edgeA = 1;
	jc.e_edgeB = 2;
	function kc() {
		this.vertices = new Array(f);
		this.normals = new Array(f);
		this.count = 0;
	}
	function lc() {
		this.i1 = 0, this.i2 = 0;
		this.v1 = new L(), this.v2 = new L();
		this.normal = new L();
		this.sideNormal1 = new L();
		this.sideOffset1 = 0;
		this.sideNormal2 = new L();
		this.sideOffset2 = 0;
	}
	function mc() {
		this.m_polygonB = new kc();
		this.m_xf = new Q();
		this.m_centroidB = new L();
		this.m_v0 = new L(), this.m_v1 = new L(), this.m_v2 = new L(), this.m_v3 = new L();
		this.m_normal0 = new L(), this.m_normal1 = new L(), this.m_normal2 = new L();
		this.m_normal = new L();
		this.m_type1 = 0, this.m_type2 = 0;
		this.m_lowerLimit = new L(), this.m_upperLimit = new L();
		this.m_radius = 0;
		this.m_front = false;
	}
	mc._temp_edge = new L();
	mc._temp_edge0 = new L();
	mc._temp_edge2 = new L();
	mc.prototype = {
		Collide: function (a, b, c, d, f) {
			this.m_xf.Assign(lb(c, f));
			this.m_centroidB.x = this.m_xf.q.c * d.m_centroid.x - this.m_xf.q.s * d.m_centroid.y + this.m_xf.p.x;
			this.m_centroidB.y = this.m_xf.q.s * d.m_centroid.x + this.m_xf.q.c * d.m_centroid.y + this.m_xf.p.y;
			this.m_v0.x = b.m_vertex0.x;
			this.m_v0.y = b.m_vertex0.y;
			this.m_v1.x = b.m_vertex1.x;
			this.m_v1.y = b.m_vertex1.y;
			this.m_v2.x = b.m_vertex2.x;
			this.m_v2.y = b.m_vertex2.y;
			this.m_v3.x = b.m_vertex3.x;
			this.m_v3.y = b.m_vertex3.y;
			var g = b.m_hasVertex0;
			var h = b.m_hasVertex3;
			mc._temp_edge.x = this.m_v2.x - this.m_v1.x;
			mc._temp_edge.y = this.m_v2.y - this.m_v1.y;
			mc._temp_edge.Normalize();
			this.m_normal1.x = mc._temp_edge.y;
			this.m_normal1.y = -mc._temp_edge.x;
			var i = this.m_normal1.x * (this.m_centroidB.x - this.m_v1.x) + this.m_normal1.y * (this.m_centroidB.y - this.m_v1.y);
			var j = 0, l = 0;
			var m = false, n = false;
			if (g) {
				mc._temp_edge0.x = this.m_v1.x - this.m_v0.x;
				mc._temp_edge0.y = this.m_v1.y - this.m_v0.y;
				mc._temp_edge0.Normalize();
				this.m_normal0.x = mc._temp_edge0.y;
				this.m_normal0.y = -mc._temp_edge0.x;
				m = mc._temp_edge0.x * mc._temp_edge.y - mc._temp_edge0.y * mc._temp_edge.x >= 0;
				j = this.m_normal0.x * (this.m_centroidB.x - this.m_v0.x) + this.m_normal0.y * (this.m_centroidB.y - this.m_v0.y);
			}
			if (h) {
				mc._temp_edge2.x = this.m_v3.x - this.m_v2.x;
				mc._temp_edge2.y = this.m_v3.y - this.m_v2.y;
				mc._temp_edge2.Normalize();
				this.m_normal2.x = mc._temp_edge2.y;
				this.m_normal2.y = -mc._temp_edge2.x;
				n = mc._temp_edge.x * mc._temp_edge2.y - mc._temp_edge.y * mc._temp_edge2.x > 0;
				l = this.m_normal2.x * (this.m_centroidB.x - this.m_v2.x) + this.m_normal2.y * (this.m_centroidB.y - this.m_v2.y);
			}
			if (g && h) if (m && n) {
				this.m_front = j >= 0 || i >= 0 || l >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal0.x;
					this.m_lowerLimit.y = this.m_normal0.y;
					this.m_upperLimit.x = this.m_normal2.x;
					this.m_upperLimit.y = this.m_normal2.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal1.x;
					this.m_lowerLimit.y = -this.m_normal1.y;
					this.m_upperLimit.x = -this.m_normal1.x;
					this.m_upperLimit.y = -this.m_normal1.y;
				}
			} else if (m) {
				this.m_front = j >= 0 || i >= 0 && l >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal0.x;
					this.m_lowerLimit.y = this.m_normal0.y;
					this.m_upperLimit.x = this.m_normal1.x;
					this.m_upperLimit.y = this.m_normal1.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal2.x;
					this.m_lowerLimit.y = -this.m_normal2.y;
					this.m_upperLimit.x = -this.m_normal1.x;
					this.m_upperLimit.y = -this.m_normal1.y;
				}
			} else if (n) {
				this.m_front = l >= 0 || j >= 0 && i >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal1.x;
					this.m_lowerLimit.y = this.m_normal1.y;
					this.m_upperLimit.x = this.m_normal2.x;
					this.m_upperLimit.y = this.m_normal2.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal1.x;
					this.m_lowerLimit.y = -this.m_normal1.y;
					this.m_upperLimit.x = -this.m_normal0.x;
					this.m_upperLimit.y = -this.m_normal0.y;
				}
			} else {
				this.m_front = j >= 0 && i >= 0 && l >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal1.x;
					this.m_lowerLimit.y = this.m_normal1.y;
					this.m_upperLimit.x = this.m_normal1.x;
					this.m_upperLimit.y = this.m_normal1.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal2.x;
					this.m_lowerLimit.y = -this.m_normal2.y;
					this.m_upperLimit.x = -this.m_normal0.x;
					this.m_upperLimit.y = -this.m_normal0.y;
				}
			} else if (g) if (m) {
				this.m_front = j >= 0 || i >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal0.x;
					this.m_lowerLimit.y = this.m_normal0.y;
					this.m_upperLimit.x = -this.m_normal1.x;
					this.m_upperLimit.y = -this.m_normal1.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal1.x;
					this.m_lowerLimit.y = this.m_normal1.y;
					this.m_upperLimit.x = -this.m_normal1.x;
					this.m_upperLimit.y = -this.m_normal1.y;
				}
			} else {
				this.m_front = j >= 0 && i >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal1.x;
					this.m_lowerLimit.y = this.m_normal1.y;
					this.m_upperLimit.x = -this.m_normal1.x;
					this.m_upperLimit.y = -this.m_normal1.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal1.x;
					this.m_lowerLimit.y = this.m_normal1.y;
					this.m_upperLimit.x = -this.m_normal0.x;
					this.m_upperLimit.y = -this.m_normal0.y;
				}
			} else if (h) if (n) {
				this.m_front = i >= 0 || l >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal1.x;
					this.m_lowerLimit.y = -this.m_normal1.y;
					this.m_upperLimit.x = this.m_normal2.x;
					this.m_upperLimit.y = this.m_normal2.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal1.x;
					this.m_lowerLimit.y = -this.m_normal1.y;
					this.m_upperLimit.x = this.m_normal1.x;
					this.m_upperLimit.y = this.m_normal1.y;
				}
			} else {
				this.m_front = i >= 0 && l >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal1.x;
					this.m_lowerLimit.y = -this.m_normal1.y;
					this.m_upperLimit.x = this.m_normal1.x;
					this.m_upperLimit.y = this.m_normal1.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal2.x;
					this.m_lowerLimit.y = -this.m_normal2.y;
					this.m_upperLimit.x = this.m_normal1.x;
					this.m_upperLimit.y = this.m_normal1.y;
				}
			} else {
				this.m_front = i >= 0;
				if (this.m_front) {
					this.m_normal.x = this.m_normal1.x;
					this.m_normal.y = this.m_normal1.y;
					this.m_lowerLimit.x = -this.m_normal1.x;
					this.m_lowerLimit.y = -this.m_normal1.y;
					this.m_upperLimit.x = -this.m_normal1.x;
					this.m_upperLimit.y = -this.m_normal1.y;
				} else {
					this.m_normal.x = -this.m_normal1.x;
					this.m_normal.y = -this.m_normal1.y;
					this.m_lowerLimit.x = this.m_normal1.x;
					this.m_lowerLimit.y = this.m_normal1.y;
					this.m_upperLimit.x = this.m_normal1.x;
					this.m_upperLimit.y = this.m_normal1.y;
				}
			}
			this.m_polygonB.count = d.m_count;
			for (var o = 0; o < d.m_count; ++o) {
				this.m_polygonB.vertices[o] = ib(this.m_xf, d.m_vertices[o]);
				this.m_polygonB.normals[o] = gb(this.m_xf.q, d.m_normals[o]);
			}
			this.m_radius = 2 * k;
			a.pointCount = 0;
			var p = this.ComputeEdgeSeparation();
			if (p.type == jc.e_unknown) return;
			if (p.separation > this.m_radius) return;
			var q = this.ComputePolygonSeparation();
			if (q.type != jc.e_unknown && q.separation > this.m_radius) return;
			var r = .98;
			var s = .001;
			var t = new jc();
			if (q.type == jc.e_unknown) t = p; else if (q.separation > r * p.separation + s) t = q; else t = p;
			var u = new Array(2);
			var v = new lc();
			if (t.type == jc.e_edgeA) {
				a.type = Yb.e_faceA;
				var w = 0;
				var x = this.m_normal.x * this.m_polygonB.normals[0].x + this.m_normal.y * this.m_polygonB.normals[0].y;
				for (var o = 1; o < this.m_polygonB.count; ++o) {
					var y = this.m_normal.x * this.m_polygonB.normals[o].x + this.m_normal.y * this.m_polygonB.normals[o].y;
					if (y < x) {
						x = y;
						w = o;
					}
				}
				var z = w;
				var A = z + 1 < this.m_polygonB.count ? z + 1 : 0;
				u[0] = new _b();
				u[0].v.x = this.m_polygonB.vertices[z].x;
				u[0].v.y = this.m_polygonB.vertices[z].y;
				u[0].id.indexA = 0;
				u[0].id.indexB = z;
				u[0].id.typeA = Wb.e_face;
				u[0].id.typeB = Wb.e_vertex;
				u[1] = new _b();
				u[1].v.x = this.m_polygonB.vertices[A].x;
				u[1].v.y = this.m_polygonB.vertices[A].y;
				u[1].id.indexA = 0;
				u[1].id.indexB = A;
				u[1].id.typeA = Wb.e_face;
				u[1].id.typeB = Wb.e_vertex;
				if (this.m_front) {
					v.i1 = 0;
					v.i2 = 1;
					v.v1.x = this.m_v1.x;
					v.v1.y = this.m_v1.y;
					v.v2.x = this.m_v2.x;
					v.v2.y = this.m_v2.y;
					v.normal.x = this.m_normal1.x;
					v.normal.y = this.m_normal1.y;
				} else {
					v.i1 = 1;
					v.i2 = 0;
					v.v1.x = this.m_v2.x;
					v.v1.y = this.m_v2.y;
					v.v2.x = this.m_v1.x;
					v.v2.y = this.m_v1.y;
					v.normal.x = -this.m_normal1.x;
					v.normal.y = -this.m_normal1.y;
				}
			} else {
				a.type = Yb.e_faceB;
				u[0] = new _b();
				u[0].v = this.m_v1;
				u[0].id.indexA = 0;
				u[0].id.indexB = t.index;
				u[0].id.typeA = Wb.e_vertex;
				u[0].id.typeB = Wb.e_face;
				u[1] = new _b();
				u[1].v = this.m_v2;
				u[1].id.indexA = 0;
				u[1].id.indexB = t.index;
				u[1].id.typeA = Wb.e_vertex;
				u[1].id.typeB = Wb.e_face;
				v.i1 = t.index;
				v.i2 = v.i1 + 1 < this.m_polygonB.count ? v.i1 + 1 : 0;
				v.v1.x = this.m_polygonB.vertices[v.i1].x;
				v.v1.y = this.m_polygonB.vertices[v.i1].y;
				v.v2.x = this.m_polygonB.vertices[v.i2].x;
				v.v2.y = this.m_polygonB.vertices[v.i2].y;
				v.normal.x = this.m_polygonB.normals[v.i1].x;
				v.normal.y = this.m_polygonB.normals[v.i1].y;
			}
			v.sideNormal1.x = v.normal.y;
			v.sideNormal1.y = -v.normal.x;
			v.sideNormal2.x = -v.sideNormal1.x;
			v.sideNormal2.y = -v.sideNormal1.y;
			v.sideOffset1 = v.sideNormal1.x * v.v1.x + v.sideNormal1.y * v.v1.y;
			v.sideOffset2 = v.sideNormal2.x * v.v2.x + v.sideNormal2.y * v.v2.y;
			var B = new Array(2);
			var C = new Array(2);
			var D;
			D = oc(B, u, v.sideNormal1.x, v.sideNormal1.y, v.sideOffset1, v.i1);
			if (D < e) return;
			D = oc(C, B, v.sideNormal2.x, v.sideNormal2.y, v.sideOffset2, v.i2);
			if (D < e) return;
			if (t.type == jc.e_edgeA) {
				a.localNormal.x = v.normal.x;
				a.localNormal.y = v.normal.y;
				a.localPoint.x = v.v1.x;
				a.localPoint.y = v.v1.y;
			} else {
				a.localNormal.x = d.m_normals[v.i1].x;
				a.localNormal.y = d.m_normals[v.i1].y;
				a.localPoint.x = d.m_vertices[v.i1].x;
				a.localPoint.y = d.m_vertices[v.i1].y;
			}
			var E = 0;
			for (var o = 0; o < e; ++o) {
				var F = v.normal.x * (C[o].v.x - v.v1.x) + v.normal.y * (C[o].v.y - v.v1.y);
				if (F <= this.m_radius) {
					var G = a.points[E] = new Xb();
					if (t.type == jc.e_edgeA) {
						G.localPoint.Assign(jb(this.m_xf, C[o].v));
						G.id.Assign(C[o].id);
					} else {
						G.localPoint.x = C[o].v.x;
						G.localPoint.y = C[o].v.y;
						G.id.typeA = C[o].id.typeB;
						G.id.typeB = C[o].id.typeA;
						G.id.indexA = C[o].id.indexB;
						G.id.indexB = C[o].id.indexA;
					}
					++E;
				}
			}
			a.pointCount = E;
		},
		ComputeEdgeSeparation: function () {
			var a = new jc();
			a.type = jc.e_edgeA;
			a.index = this.m_front ? 0 : 1;
			a.separation = Number.MAX_VALUE;
			for (var b = 0; b < this.m_polygonB.count; ++b) {
				var c = this.m_normal.x * (this.m_polygonB.vertices[b].x - this.m_v1.x) + this.m_normal.y * (this.m_polygonB.vertices[b].y - this.m_v1.y);
				if (c < a.separation) a.separation = c;
			}
			return a;
		},
		ComputePolygonSeparation: function () {
			var a = new jc();
			a.type = jc.e_unknown;
			a.index = -1;
			a.separation = -Number.MAX_VALUE;
			var b = -this.m_normal.y;
			var c = this.m_normal.x;
			for (var d = 0; d < this.m_polygonB.count; ++d) {
				var e = -this.m_polygonB.normals[d].x;
				var f = -this.m_polygonB.normals[d].y;
				var g = e * (this.m_polygonB.vertices[d].x - this.m_v1.x) + f * (this.m_polygonB.vertices[d].y - this.m_v1.y);
				var h = e * (this.m_polygonB.vertices[d].x - this.m_v2.x) + f * (this.m_polygonB.vertices[d].y - this.m_v2.y);
				var i = pb(g, h);
				if (i > this.m_radius) {
					a.type = jc.e_edgeB;
					a.index = d;
					a.separation = i;
					return a;
				}
				if (e * b + f * c >= 0) {
					if ((e - this.m_upperLimit.x) * this.m_normal.x + (f - this.m_upperLimit.y) * this.m_normal.y < -j) continue;
				} else if ((e - this.m_lowerLimit.x) * this.m_normal.x + (f - this.m_lowerLimit.y) * this.m_normal.y < -j) continue;
				if (i > a.separation) {
					a.type = jc.e_edgeB;
					a.index = d;
					a.separation = i;
				}
			}
			return a;
		}
	};
	mc.e_isolated = 0;
	mc.e_concave = 1;
	mc.e_convex = 2;
	function nc(a, b, c, d, e) {
		nc.collider.Collide(a, b, c, d, e);
	}
	nc.collider = new mc();
	function oc(a, b, c, d, e, f) {
		var g = 0;
		var h = c * b[0].v.x + d * b[0].v.y - e;
		var i = c * b[1].v.x + d * b[1].v.y - e;
		if (h <= 0) a[g++] = b[0];
		if (i <= 0) a[g++] = b[1];
		if (h * i < 0) {
			var j = h / (h - i);
			a[g] = new _b();
			a[g].v.x = b[0].v.x + j * (b[1].v.x - b[0].v.x);
			a[g].v.y = b[0].v.y + j * (b[1].v.y - b[0].v.y);
			a[g].id.indexA = f;
			a[g].id.indexB = b[0].id.indexB;
			a[g].id.typeA = Wb.e_vertex;
			a[g].id.typeB = Wb.e_face;
			++g;
		}
		return g;
	}
	function pc(a, b, d, e, f, g) {
		pc.input.proxyA.Set(a, b);
		pc.input.proxyB.Set(d, e);
		pc.input.transformA = f;
		pc.input.transformB = g;
		pc.input.useRadii = true;
		pc.cache.count = 0;
		Ub(pc.output, pc.cache, pc.input);
		return pc.output.distance < 10 * c;
	}
	pc.input = new Nb();
	pc.cache = new Mb();
	pc.output = new Ob();
	function qc(a, b) {
		return !(b.lowerBound.x - a.upperBound.x > 0 || b.lowerBound.y - a.upperBound.y > 0 || a.lowerBound.x - b.upperBound.x > 0 || a.lowerBound.y - b.upperBound.y > 0);
	}
	var rc = -1;
	function sc() {
		this.aabb = new cc();
		this.userData = null;
		this.parent = 0;
		this.child1 = this.child2 = this.height = 0;
	}
	sc.prototype = {
		IsLeaf: function () {
			return this.child1 == rc;
		}
	};
	function tc() {
		this.m_root = rc;
		this.m_nodeCapacity = 16;
		this.m_nodeCount = 0;
		this.m_nodes = new Array(this.m_nodeCapacity);
		for (var a = 0; a < this.m_nodeCapacity - 1; ++a) {
			this.m_nodes[a] = new sc();
			this.m_nodes[a].parent = a + 1;
			this.m_nodes[a].height = -1;
		}
		this.m_nodes[this.m_nodeCapacity - 1] = new sc();
		this.m_nodes[this.m_nodeCapacity - 1].parent = rc;
		this.m_nodes[this.m_nodeCapacity - 1].height = -1;
		this.m_freeList = 0;
		this.m_path = 0;
		this.m_insertionCount = 0;
	}
	tc.aabbExtensionFattener = new L(g, g);
	tc.prototype = {
		CreateProxy: function (a, b) {
			var c = this.AllocateNode();
			this.m_nodes[c].aabb.lowerBound.Assign(L.Subtract(a.lowerBound, tc.aabbExtensionFattener));
			this.m_nodes[c].aabb.upperBound.Assign(L.Add(a.upperBound, tc.aabbExtensionFattener));
			this.m_nodes[c].userData = b;
			this.m_nodes[c].height = 0;
			this.InsertLeaf(c);
			return c;
		},
		DestroyProxy: function (a) {
			this.RemoveLeaf(a);
			this.FreeNode(a);
		},
		MoveProxy: function (a, b, c) {
			if (this.m_nodes[a].aabb.Contains(b)) return false;
			this.RemoveLeaf(a);
			this.m_nodes[a].aabb.Assign(b);
			this.m_nodes[a].aabb.lowerBound.Subtract(tc.aabbExtensionFattener);
			this.m_nodes[a].aabb.upperBound.Add(tc.aabbExtensionFattener);
			var d = L.Multiply(h, c);
			if (d.x < 0) this.m_nodes[a].aabb.lowerBound.x += d.x; else this.m_nodes[a].aabb.upperBound.x += d.x;
			if (d.y < 0) this.m_nodes[a].aabb.lowerBound.y += d.y; else this.m_nodes[a].aabb.upperBound.y += d.y;
			this.InsertLeaf(a);
			return true;
		},
		GetUserData: function (a) {
			return this.m_nodes[a].userData;
		},
		GetFatAABB: function (a) {
			return this.m_nodes[a].aabb;
		},
		Query: function (a, b) {
			var c = [];
			c.push(this.m_root);
			while (c.length > 0) {
				var d = c.pop();
				if (d == rc) continue;
				var e = this.m_nodes[d];
				if (qc(e.aabb, b)) if (e.IsLeaf()) {
					var f = a.QueryCallback(d);
					if (false == f) return;
				} else {
					c.push(e.child1);
					c.push(e.child2);
				}
			}
		},
		RayCast: function (a, b) {
			var c = b.p1;
			var d = b.p2;
			var e = L.Subtract(d, c);
			e.Normalize();
			var f = V(1, e);
			var g = nb(f);
			var h = b.maxFraction;
			var i = new cc();
			var j = L.Add(c, L.Multiply(h, L.Subtract(d, c)));
			i.lowerBound.Assign(qb(c, j));
			i.upperBound.Assign(sb(c, j));
			var k = [];
			k.push(this.m_root);
			while (k.length > 0) {
				var l = k.pop();
				if (l == rc) continue;
				var m = this.m_nodes[l];
				if (false == qc(m.aabb, i)) continue;
				var n = m.aabb.GetCenter();
				var o = m.aabb.GetExtents();
				var p = mb(S(f, L.Subtract(c, n))) - S(g, o);
				if (p > 0) continue;
				if (m.IsLeaf()) {
					var q = new ac();
					q.p1.Assign(b.p1);
					q.p2.Assign(b.p2);
					q.maxFraction = h;
					var r = a.RayCastCallback(q, l);
					if (0 == r) return;
					if (r > 0) {
						h = r;
						var j = L.Add(c, L.Multiply(h, L.Subtract(d, c)));
						i.lowerBound.Assign(qb(c, j));
						i.upperBound.Assign(sb(c, j));
					}
				} else {
					k.push(m.child1);
					k.push(m.child2);
				}
			}
		},
		Validate: function () {
			this.ValidateStructure(this.m_root);
			this.ValidateMetrics(this.m_root);
			var a = 0;
			var b = this.m_freeList;
			while (b != rc) {
				b = this.m_nodes[b].parent;
				++a;
			}
		},
		GetHeight: function () {
			if (this.m_root == rc) return 0;
			return this.m_nodes[this.m_root].height;
		},
		GetMaxBalance: function () {
			var a = 0;
			for (var b = 0; b < this.m_nodeCapacity; ++b) {
				var c = this.m_nodes[b];
				if (c.height <= 1) continue;
				var d = c.child1;
				var e = c.child2;
				var f = mb(this.m_nodes[e].height - this.m_nodes[d].height);
				a = rb(a, f);
			}
			return a;
		},
		GetAreaRatio: function () {
			if (this.m_root == rc) return 0;
			var a = this.m_nodes[this.m_root];
			var b = a.aabb.GetPerimeter();
			var c = 0;
			for (var d = 0; d < this.m_nodeCapacity; ++d) {
				var e = this.m_nodes[d];
				if (e.height < 0) continue;
				c += e.aabb.GetPerimeter();
			}
			return c / b;
		},
		RebuildBottomUp: function () {
			var a = new Array(this.m_nodeCount);
			var c = 0;
			for (var d = 0; d < this.m_nodeCapacity; ++d) {
				if (this.m_nodes[d].height < 0) continue;
				if (this.m_nodes[d].IsLeaf()) {
					this.m_nodes[d].parent = rc;
					a[c] = d;
					++c;
				} else this.FreeNode(d);
			}
			while (c > 1) {
				var e = b;
				var f = -1, g = -1;
				for (d = 0; d < c; ++d) {
					var h = this.m_nodes[a[d]].aabb;
					for (var i = d + 1; i < c; ++i) {
						var j = this.m_nodes[a[i]].aabb;
						var k = new cc();
						k.Combine(h, j);
						var l = k.GetPerimeter();
						if (l < e) {
							f = d;
							g = i;
							e = l;
						}
					}
				}
				var m = a[f];
				var n = a[g];
				var o = this.m_nodes[m];
				var p = this.m_nodes[n];
				var q = this.AllocateNode();
				var r = this.m_nodes[q];
				r.child1 = m;
				r.child2 = n;
				r.height = 1 + rb(o.height, p.height);
				r.aabb.Combine(o.aabb, p.aabb);
				r.parent = rc;
				o.parent = q;
				p.parent = q;
				a[g] = a[c - 1];
				a[f] = q;
				--c;
			}
			this.m_root = a[0];
			this.Validate();
		},
		ShiftOrigin: function (a) {
			for (var b = 0; b < this.m_nodeCapacity; ++b) {
				this.m_nodes[b].aabb.lowerBound.Subtract(a);
				this.m_nodes[b].aabb.upperBound.Subtract(a);
			}
		},
		AllocateNode: function () {
			if (this.m_freeList == rc) {
				var a = this.m_nodes;
				this.m_nodeCapacity *= 2;
				this.m_nodes = a.concat(new Array(this.m_nodeCapacity - this.m_nodeCount));
				for (var b = this.m_nodeCount; b < this.m_nodeCapacity - 1; ++b) {
					this.m_nodes[b] = new sc();
					this.m_nodes[b].parent = b + 1;
					this.m_nodes[b].height = -1;
				}
				this.m_nodes[this.m_nodeCapacity - 1] = new sc();
				this.m_nodes[this.m_nodeCapacity - 1].parent = rc;
				this.m_nodes[this.m_nodeCapacity - 1].height = -1;
				this.m_freeList = this.m_nodeCount;
			}
			var c = this.m_freeList;
			this.m_freeList = this.m_nodes[c].parent;
			this.m_nodes[c].parent = rc;
			this.m_nodes[c].child1 = rc;
			this.m_nodes[c].child2 = rc;
			this.m_nodes[c].height = 0;
			this.m_nodes[c].userData = null;
			++this.m_nodeCount;
			return c;
		},
		FreeNode: function (a) {
			this.m_nodes[a].parent = this.m_freeList;
			this.m_nodes[a].height = -1;
			this.m_freeList = a;
			--this.m_nodeCount;
		},
		InsertLeaf: function (a) {
			++this.m_insertionCount;
			if (this.m_root == rc) {
				this.m_root = a;
				this.m_nodes[this.m_root].parent = rc;
				return;
			}
			var b = this.m_nodes[a].aabb;
			var c = this.m_root;
			while (false == this.m_nodes[c].IsLeaf()) {
				var d = this.m_nodes[c].child1;
				var e = this.m_nodes[c].child2;
				var f = this.m_nodes[c].aabb.GetPerimeter();
				var g = new cc();
				g.Combine(this.m_nodes[c].aabb, b);
				var h = g.GetPerimeter();
				var i = 2 * h;
				var j = 2 * (h - f);
				var k;
				var l;
				if (this.m_nodes[d].IsLeaf()) {
					l = new cc();
					l.Combine(b, this.m_nodes[d].aabb);
					k = l.GetPerimeter() + j;
				} else {
					l = new cc();
					l.Combine(b, this.m_nodes[d].aabb);
					var m = this.m_nodes[d].aabb.GetPerimeter();
					var n = l.GetPerimeter();
					k = n - m + j;
				}
				var o;
				if (this.m_nodes[e].IsLeaf()) {
					l = new cc();
					l.Combine(b, this.m_nodes[e].aabb);
					o = l.GetPerimeter() + j;
				} else {
					l = new cc();
					l.Combine(b, this.m_nodes[e].aabb);
					var m = this.m_nodes[e].aabb.GetPerimeter();
					var n = l.GetPerimeter();
					o = n - m + j;
				}
				if (i < k && i < o) break;
				if (k < o) c = d; else c = e;
			}
			var p = c;
			var q = this.m_nodes[p].parent;
			var r = this.AllocateNode();
			this.m_nodes[r].parent = q;
			this.m_nodes[r].userData = null;
			this.m_nodes[r].aabb.Combine(b, this.m_nodes[p].aabb);
			this.m_nodes[r].height = this.m_nodes[p].height + 1;
			if (q != rc) {
				if (this.m_nodes[q].child1 == p) this.m_nodes[q].child1 = r; else this.m_nodes[q].child2 = r;
				this.m_nodes[r].child1 = p;
				this.m_nodes[r].child2 = a;
				this.m_nodes[p].parent = r;
				this.m_nodes[a].parent = r;
			} else {
				this.m_nodes[r].child1 = p;
				this.m_nodes[r].child2 = a;
				this.m_nodes[p].parent = r;
				this.m_nodes[a].parent = r;
				this.m_root = r;
			}
			c = this.m_nodes[a].parent;
			while (c != rc) {
				c = this.Balance(c);
				var d = this.m_nodes[c].child1;
				var e = this.m_nodes[c].child2;
				this.m_nodes[c].height = 1 + rb(this.m_nodes[d].height, this.m_nodes[e].height);
				this.m_nodes[c].aabb.Combine(this.m_nodes[d].aabb, this.m_nodes[e].aabb);
				c = this.m_nodes[c].parent;
			}
		},
		RemoveLeaf: function (a) {
			if (a == this.m_root) {
				this.m_root = rc;
				return;
			}
			var b = this.m_nodes[a].parent;
			var c = this.m_nodes[b].parent;
			var d;
			if (this.m_nodes[b].child1 == a) d = this.m_nodes[b].child2; else d = this.m_nodes[b].child1;
			if (c != rc) {
				if (this.m_nodes[c].child1 == b) this.m_nodes[c].child1 = d; else this.m_nodes[c].child2 = d;
				this.m_nodes[d].parent = c;
				this.FreeNode(b);
				var e = c;
				while (e != rc) {
					e = this.Balance(e);
					var f = this.m_nodes[e].child1;
					var g = this.m_nodes[e].child2;
					this.m_nodes[e].aabb.Combine(this.m_nodes[f].aabb, this.m_nodes[g].aabb);
					this.m_nodes[e].height = 1 + rb(this.m_nodes[f].height, this.m_nodes[g].height);
					e = this.m_nodes[e].parent;
				}
			} else {
				this.m_root = d;
				this.m_nodes[d].parent = rc;
				this.FreeNode(b);
			}
		},
		Balance: function (a) {
			var b = this.m_nodes[a];
			if (b.IsLeaf() || b.height < 2) return a;
			var c = b.child1;
			var d = b.child2;
			var e = this.m_nodes[c];
			var f = this.m_nodes[d];
			var g = f.height - e.height;
			if (g > 1) {
				var h = f.child1;
				var i = f.child2;
				var j = this.m_nodes[h];
				var k = this.m_nodes[i];
				f.child1 = a;
				f.parent = b.parent;
				b.parent = d;
				if (f.parent != rc) if (this.m_nodes[f.parent].child1 == a) this.m_nodes[f.parent].child1 = d; else this.m_nodes[f.parent].child2 = d; else this.m_root = d;
				if (j.height > k.height) {
					f.child2 = h;
					b.child2 = i;
					k.parent = a;
					b.aabb.Combine(e.aabb, k.aabb);
					f.aabb.Combine(b.aabb, j.aabb);
					b.height = 1 + rb(e.height, k.height);
					f.height = 1 + rb(b.height, j.height);
				} else {
					f.child2 = i;
					b.child2 = h;
					j.parent = a;
					b.aabb.Combine(e.aabb, j.aabb);
					f.aabb.Combine(b.aabb, k.aabb);
					b.height = 1 + rb(e.height, j.height);
					f.height = 1 + rb(b.height, k.height);
				}
				return d;
			}
			if (g < -1) {
				var l = e.child1;
				var m = e.child2;
				var n = this.m_nodes[l];
				var o = this.m_nodes[m];
				e.child1 = a;
				e.parent = b.parent;
				b.parent = c;
				if (e.parent != rc) if (this.m_nodes[e.parent].child1 == a) this.m_nodes[e.parent].child1 = c; else this.m_nodes[e.parent].child2 = c; else this.m_root = c;
				if (n.height > o.height) {
					e.child2 = l;
					b.child1 = m;
					o.parent = a;
					b.aabb.Combine(f.aabb, o.aabb);
					e.aabb.Combine(b.aabb, n.aabb);
					b.height = 1 + rb(f.height, o.height);
					e.height = 1 + rb(b.height, n.height);
				} else {
					e.child2 = m;
					b.child1 = l;
					n.parent = a;
					b.aabb.Combine(f.aabb, n.aabb);
					e.aabb.Combine(b.aabb, o.aabb);
					b.height = 1 + rb(f.height, n.height);
					e.height = 1 + rb(b.height, o.height);
				}
				return c;
			}
			return a;
		},
		ComputeHeight: function (a) {
			if ("undefined" === typeof a) a = this.m_root;
			var b = this.m_nodes[a];
			if (b.IsLeaf()) return 0;
			var c = this.ComputeHeight(b.child1);
			var d = this.ComputeHeight(b.child2);
			return 1 + rb(c, d);
		},
		ValidateStructure: function (a) {
			if (a == rc) return;
			var b = this.m_nodes[a];
			var c = b.child1;
			var d = b.child2;
			if (b.IsLeaf()) return;
			this.ValidateStructure(c);
			this.ValidateStructure(d);
		},
		ValidateMetrics: function (a) {
			if (a == rc) return;
			var b = this.m_nodes[a];
			var c = b.child1;
			var d = b.child2;
			if (b.IsLeaf()) return;
			var e = this.m_nodes[c].height;
			var f = this.m_nodes[d].height;
			var g;
			g = 1 + rb(e, f);
			var h = new cc();
			h.Combine(this.m_nodes[c].aabb, this.m_nodes[d].aabb);
			this.ValidateMetrics(c);
			this.ValidateMetrics(d);
		}
	};
	function uc() {
		this.proxyA = new Lb();
		this.proxyB = new Lb();
		this.sweepA = new R();
		this.sweepB = new R();
		this.tMax = 0;
	}
	function vc() {
		this.state = 0;
		this.t = 0;
	}
	vc.e_unknown = 0;
	vc.e_failed = 1;
	vc.e_overlapped = 2;
	vc.e_touching = 3;
	vc.e_separated = 4;
	function wc() {
		this.m_proxyA = null;
		this.m_proxyB = null;
		this.m_sweepA = null;
		this.m_sweepB = null;
		this.m_type = 0;
		this.m_localPoint = new L();
		this.m_axis = new L();
	}
	var xc = new Q();
	var yc = new Q();
	wc.prototype = {
		Initialize: function (a, b, c, d, e, f) {
			this.m_proxyA = b;
			this.m_proxyB = d;
			var g = a.count;
			this.m_sweepA = c;
			this.m_sweepB = e;
			this.m_sweepA.GetTransform(xc, f);
			this.m_sweepB.GetTransform(yc, f);
			if (1 == g) {
				this.m_type = wc.e_points;
				var h = this.m_proxyA.GetVertex(a.indexA[0]);
				var i = this.m_proxyB.GetVertex(a.indexB[0]);
				var j = xc.q.c * h.x - xc.q.s * h.y + xc.p.x;
				var k = xc.q.s * h.x + xc.q.c * h.y + xc.p.y;
				var l = yc.q.c * i.x - yc.q.s * i.y + yc.p.x;
				var m = yc.q.s * i.x + yc.q.c * i.y + yc.p.y;
				this.m_axis.x = l - j;
				this.m_axis.y = m - k;
				var n = this.m_axis.Normalize();
				return n;
			} else if (a.indexA[0] == a.indexA[1]) {
				this.m_type = wc.e_faceB;
				var o = d.GetVertex(a.indexB[0]);
				var p = d.GetVertex(a.indexB[1]);
				this.m_axis.x = 1 * (p.y - o.y);
				this.m_axis.y = -1 * (p.x - o.x);
				this.m_axis.Normalize();
				var q = yc.q.c * this.m_axis.x - yc.q.s * this.m_axis.y;
				var r = yc.q.s * this.m_axis.x + yc.q.c * this.m_axis.y;
				this.m_localPoint.x = .5 * (o.x + p.x);
				this.m_localPoint.y = .5 * (o.y + p.y);
				var l = yc.q.c * this.m_localPoint.x - yc.q.s * this.m_localPoint.y + yc.p.x;
				var m = yc.q.s * this.m_localPoint.x + yc.q.c * this.m_localPoint.y + yc.p.y;
				var h = b.GetVertex(a.indexA[0]);
				var j = xc.q.c * h.x - xc.q.s * h.y + xc.p.x;
				var k = xc.q.s * h.x + xc.q.c * h.y + xc.p.y;
				var n = (j - l) * q + (k - m) * r;
				if (n < 0) {
					this.m_axis.x = -this.m_axis.x;
					this.m_axis.y = -this.m_axis.y;
					n = -n;
				}
				return n;
			} else {
				this.m_type = wc.e_faceA;
				var s = this.m_proxyA.GetVertex(a.indexA[0]);
				var t = this.m_proxyA.GetVertex(a.indexA[1]);
				this.m_axis.x = 1 * (t.y - s.y);
				this.m_axis.y = -1 * (t.x - s.x);
				this.m_axis.Normalize();
				var q = xc.q.c * this.m_axis.x - xc.q.s * this.m_axis.y;
				var r = xc.q.s * this.m_axis.x + xc.q.c * this.m_axis.y;
				this.m_localPoint.x = .5 * (s.x + t.x);
				this.m_localPoint.y = .5 * (s.y + t.y);
				var j = xc.q.c * this.m_localPoint.x - xc.q.s * this.m_localPoint.y + xc.p.x;
				var k = xc.q.s * this.m_localPoint.x + xc.q.c * this.m_localPoint.y + xc.p.y;
				var i = this.m_proxyB.GetVertex(a.indexB[0]);
				var l = yc.q.c * i.x - yc.q.s * i.y + yc.p.x;
				var m = yc.q.s * i.x + yc.q.c * i.y + yc.p.y;
				var n = (l - j) * q + (m - k) * r;
				if (n < 0) {
					this.m_axis.x = -this.m_axis.x;
					this.m_axis.y = -this.m_axis.y;
					n = -n;
				}
				return n;
			}
		},
		FindMinSeparation: function (a, b) {
			this.m_sweepA.GetTransform(xc, b);
			this.m_sweepB.GetTransform(yc, b);
			switch (this.m_type) {
				case wc.e_points:
					var c = xc.q.c * this.m_axis.x + xc.q.s * this.m_axis.y;
					var d = -xc.q.s * this.m_axis.x + xc.q.c * this.m_axis.y;
					var e = yc.q.c * -this.m_axis.x + yc.q.s * -this.m_axis.y;
					var f = -yc.q.s * -this.m_axis.x + yc.q.c * -this.m_axis.y;
					a[0] = this.m_proxyA.GetSupport(c, d);
					a[1] = this.m_proxyB.GetSupport(e, f);
					var g = this.m_proxyA.GetVertex(a[0]);
					var h = this.m_proxyB.GetVertex(a[1]);
					var i = xc.q.c * g.x - xc.q.s * g.y + xc.p.x;
					var j = xc.q.s * g.x + xc.q.c * g.y + xc.p.y;
					var k = yc.q.c * h.x - yc.q.s * h.y + yc.p.x;
					var l = yc.q.s * h.x + yc.q.c * h.y + yc.p.y;
					return (k - i) * this.m_axis.x + (l - j) * this.m_axis.y;

				case wc.e_faceA:
					var m = xc.q.c * this.m_axis.x - xc.q.s * this.m_axis.y;
					var n = xc.q.s * this.m_axis.x + xc.q.c * this.m_axis.y;
					var i = xc.q.c * this.m_localPoint.x - xc.q.s * this.m_localPoint.y + xc.p.x;
					var j = xc.q.s * this.m_localPoint.x + xc.q.c * this.m_localPoint.y + xc.p.y;
					var e = yc.q.c * -m + yc.q.s * -n;
					var f = -yc.q.s * -m + yc.q.c * -n;
					a[0] = -1;
					a[1] = this.m_proxyB.GetSupport(e, f);
					var h = this.m_proxyB.GetVertex(a[1]);
					var k = yc.q.c * h.x - yc.q.s * h.y + yc.p.x;
					var l = yc.q.s * h.x + yc.q.c * h.y + yc.p.y;
					return (k - i) * m + (l - j) * n;

				case wc.e_faceB:
					var m = yc.q.c * this.m_axis.x - yc.q.s * this.m_axis.y;
					var n = yc.q.s * this.m_axis.x + yc.q.c * this.m_axis.y;
					var k = yc.q.c * this.m_localPoint.x - yc.q.s * this.m_localPoint.y + yc.p.x;
					var l = yc.q.s * this.m_localPoint.x + yc.q.c * this.m_localPoint.y + yc.p.y;
					var c = xc.q.c * -m + xc.q.s * -n;
					var f = -xc.q.s * -m + xc.q.c * -n;
					a[1] = -1;
					a[0] = this.m_proxyA.GetSupport(c, f);
					var g = this.m_proxyA.GetVertex(a[0]);
					var i = xc.q.c * g.x - xc.q.s * g.y + xc.p.x;
					var j = xc.q.s * g.x + xc.q.c * g.y + xc.p.y;
					return (i - k) * m + (j - l) * n;
			}
		},
		Evaluate: function (a, b, c) {
			this.m_sweepA.GetTransform(xc, c);
			this.m_sweepB.GetTransform(yc, c);
			switch (this.m_type) {
				case wc.e_points:
					var d = this.m_proxyA.GetVertex(a);
					var e = this.m_proxyB.GetVertex(b);
					var f = xc.q.c * d.x - xc.q.s * d.y + xc.p.x;
					var g = xc.q.s * d.x + xc.q.c * d.y + xc.p.y;
					var h = yc.q.c * e.x - yc.q.s * e.y + yc.p.x;
					var i = yc.q.s * e.x + yc.q.c * e.y + yc.p.y;
					var j = (h - f) * this.m_axis.x + (i - g) * this.m_axis.y;
					return j;

				case wc.e_faceA:
					var k = xc.q.c * this.m_axis.x - xc.q.s * this.m_axis.y;
					var l = xc.q.s * this.m_axis.x + xc.q.c * this.m_axis.y;
					var f = xc.q.c * this.m_localPoint.x - xc.q.s * this.m_localPoint.y + xc.p.x;
					var g = xc.q.s * this.m_localPoint.x + xc.q.c * this.m_localPoint.y + xc.p.y;
					var e = this.m_proxyB.GetVertex(b);
					var h = yc.q.c * e.x - yc.q.s * e.y + yc.p.x;
					var i = yc.q.s * e.x + yc.q.c * e.y + yc.p.y;
					var j = (h - f) * k + (i - g) * l;
					return j;

				case wc.e_faceB:
					var k = yc.q.c * this.m_axis.x - yc.q.s * this.m_axis.y;
					var l = yc.q.s * this.m_axis.x + yc.q.c * this.m_axis.y;
					var h = yc.q.c * this.m_localPoint.x - yc.q.s * this.m_localPoint.y + yc.p.x;
					var i = yc.q.s * this.m_localPoint.x + yc.q.c * this.m_localPoint.y + yc.p.y;
					var d = this.m_proxyA.GetVertex(a);
					var f = xc.q.c * d.x - xc.q.s * d.y + xc.p.x;
					var g = xc.q.s * d.x + xc.q.c * d.y + xc.p.y;
					var j = (f - h) * k + (g - i) * l;
					return j;
			}
		}
	};
	wc.e_points = 0;
	wc.e_faceA = 1;
	wc.e_faceB = 2;
	var zc = a.create("toi", "solveTOI");
	function Ac(a, b) {
		zc.start();
		++Ac.b2_toiCalls;
		a.state = vc.e_unknown;
		a.t = b.tMax;
		var c = b.proxyA;
		var d = b.proxyB;
		Ac._temp_sweepA.Assign(b.sweepA);
		Ac._temp_sweepB.Assign(b.sweepB);
		Ac._temp_sweepA.Normalize();
		Ac._temp_sweepB.Normalize();
		var e = b.tMax;
		var g = c.m_radius + d.m_radius;
		var h = rb(i, g - 3 * i);
		var j = .25 * i;
		var k = 0;
		var l = 20;
		var m = 0;
		var n = new Mb();
		n.count = 0;
		var o = new Nb();
		o.proxyA.Assign(b.proxyA);
		o.proxyB.Assign(b.proxyB);
		o.useRadii = false;
		for (; ;) {
			Ac._temp_sweepA.GetTransform(o.transformA, k);
			Ac._temp_sweepB.GetTransform(o.transformB, k);
			var p = new Ob();
			Ub(p, n, o);
			if (p.distance <= 0) {
				a.state = vc.e_overlapped;
				a.t = 0;
				break;
			}
			if (p.distance < h + j) {
				a.state = vc.e_touching;
				a.t = k;
				break;
			}
			var q = new wc();
			q.Initialize(n, c, Ac._temp_sweepA, d, Ac._temp_sweepB, k);
			var r = false;
			var s = e;
			var t = 0;
			for (; ;) {
				var u = [];
				var v = q.FindMinSeparation(u, s);
				if (v > h + j) {
					a.state = vc.e_separated;
					a.t = e;
					r = true;
					break;
				}
				if (v > h - j) {
					k = s;
					break;
				}
				var w = q.Evaluate(u[0], u[1], k);
				if (w < h - j) {
					a.state = vc.e_failed;
					a.t = k;
					r = true;
					break;
				}
				if (w <= h + j) {
					a.state = vc.e_touching;
					a.t = k;
					r = true;
					break;
				}
				var x = 0;
				var y = k, z = s;
				for (; ;) {
					var A;
					if (1 & x) A = y + (h - w) * (z - y) / (v - w); else A = .5 * (y + z);
					++x;
					++Ac.b2_toiRootIters;
					var B = q.Evaluate(u[0], u[1], A);
					if (mb(B - h) < j) {
						s = A;
						break;
					}
					if (B > h) {
						y = A;
						w = B;
					} else {
						z = A;
						v = B;
					}
					if (50 == x) break;
				}
				Ac.b2_toiMaxRootIters = rb(Ac.b2_toiMaxRootIters, x);
				++t;
				if (t == f) break;
			}
			++m;
			++Ac.b2_toiIters;
			if (r) break;
			if (m == l) {
				a.state = vc.e_failed;
				a.t = k;
				break;
			}
		}
		Ac.b2_toiMaxIters = rb(Ac.b2_toiMaxIters, m);
		zc.stop();
		Ac.b2_toiMaxTime = rb(Ac.b2_toiMaxTime, zc.elapsedTime);
		Ac.b2_toiTime += zc.elapsedTime;
	}
	Ac._temp_sweepA = new R();
	Ac._temp_sweepB = new R();
	Ac.b2_toiTime = 0;
	Ac.b2_toiMaxTime = 0;
	Ac.b2_toiCalls = 0;
	Ac.b2_toiIters = 0;
	Ac.b2_toiMaxIters = 0;
	Ac.b2_toiRootIters = 0;
	Ac.b2_toiMaxRootIters = 0;
	function Bc() {
		this.type = Cc.b2_staticBody;
		this.position = new L(0, 0);
		this.angle = 0;
		this.linearVelocity = new L(0, 0);
		this.angularVelocity = 0;
		this.linearDamping = 0;
		this.angularDamping = 0;
		this.allowSleep = true;
		this.awake = true;
		this.fixedRotation = false;
		this.bullet = false;
		this.active = true;
		this.userData = null;
		this.gravityScale = 1;
		Object.seal(this);
	}
	Bc.prototype = {
		_deserialize: function (a) {
			this.type = a.type;
			this.position._deserialize(a.position);
			this.angle = a.angle;
			this.linearVelocity._deserialize(a.linearVelocity);
			this.angularVelocity = a.angularVelocity;
			this.linearDamping = a.linearDamping;
			this.angularDamping = a.angularDamping;
			this.allowSleep = a.allowSleep;
			this.awake = a.awake;
			this.fixedRotation = a.fixedRotation;
			this.bullet = a.bullet;
			this.active = a.active;
			this.gravityScale = a.gravityScale;
		}
	};
	function Cc(a, b) {
		this.m_islandIndex = 0;
		this.m_flags = 0;
		if (a.bullet) this.m_flags |= Cc.e_bulletFlag;
		if (a.fixedRotation) this.m_flags |= Cc.e_fixedRotationFlag;
		if (a.allowSleep) this.m_flags |= Cc.e_autoSleepFlag;
		if (a.awake) this.m_flags |= Cc.e_awakeFlag;
		if (a.active) this.m_flags |= Cc.e_activeFlag;
		this.m_world = b;
		this.m_xf = new Q();
		this.m_xf.p.Assign(a.position);
		this.m_xf.q.Set(a.angle);
		this.m_sweep = new R();
		this.m_sweep.localCenter.SetZero();
		this.m_sweep.c0.Assign(this.m_xf.p);
		this.m_sweep.c.Assign(this.m_xf.p);
		this.m_sweep.a0 = a.angle;
		this.m_sweep.a = a.angle;
		this.m_sweep.alpha0 = 0;
		this.m_jointList = null;
		this.m_contactList = null;
		this.m_prev = null;
		this.m_next = null;
		this.m_linearVelocity = a.linearVelocity.Clone();
		this.m_angularVelocity = a.angularVelocity;
		this.m_linearDamping = a.linearDamping;
		this.m_angularDamping = a.angularDamping;
		this.m_gravityScale = a.gravityScale;
		this.m_force = new L();
		this.m_torque = 0;
		this.m_sleepTime = 0;
		this.m_type = a.type;
		if (this.m_type == Cc.b2_dynamicBody) {
			this.m_mass = 1;
			this.m_invMass = 1;
		} else {
			this.m_mass = 0;
			this.m_invMass = 0;
		}
		this.m_I = 0;
		this.m_invI = 0;
		this.m_userData = a.userData;
		this.m_fixtureList = null;
		this.m_fixtureCount = 0;
	}
	Cc.b2_staticBody = 0;
	Cc.b2_kinematicBody = 1;
	Cc.b2_dynamicBody = 2;
	Cc.e_islandFlag = 1;
	Cc.e_awakeFlag = 2;
	Cc.e_autoSleepFlag = 4;
	Cc.e_bulletFlag = 8;
	Cc.e_fixedRotationFlag = 16;
	Cc.e_activeFlag = 32;
	Cc.e_toiFlag = 64;
	Cc.m_local_oldCenter = new L();
	Cc.m_local_xf1 = new Q();
	Cc.prototype = {
		CreateFixture: function (a, b) {
			if ("undefined" !== typeof b) {
				var c = new Ec();
				c.shape = a;
				c.density = b;
				return this.CreateFixture(c);
			}
			if (true == this.m_world.IsLocked()) return null;
			var d = new Gc();
			d.Create(this, a);
			if (this.m_flags & Cc.e_activeFlag) {
				var e = this.m_world.m_contactManager.m_broadPhase;
				d.CreateProxies(e, this.m_xf);
			}
			d.m_next = this.m_fixtureList;
			this.m_fixtureList = d;
			++this.m_fixtureCount;
			d.m_body = this;
			if (d.m_density > 0) this.ResetMassData();
			this.m_world.m_flags |= Wc.e_newFixture;
			return d;
		},
		DestroyFixture: function (a) {
			if (true == this.m_world.IsLocked()) return;
			var b = this.m_fixtureList;
			var c = false;
			while (null != b) {
				if (b == a) {
					this.m_fixtureList = b = a.m_next;
					c = true;
					break;
				}
				b = b.m_next;
			}
			var d = this.m_contactList;
			while (d) {
				var e = d.contact;
				d = d.next;
				var f = e.GetFixtureA();
				var g = e.GetFixtureB();
				if (a == f || a == g) this.m_world.m_contactManager.Destroy(e);
			}
			if (this.m_flags & Cc.e_activeFlag) {
				var h = this.m_world.m_contactManager.m_broadPhase;
				a.DestroyProxies(h);
			}
			a.Destroy();
			a.m_body = null;
			a.m_next = null;
			--this.m_fixtureCount;
			this.ResetMassData();
		},
		SetTransform: function (a, b) {
			if (true == this.m_world.IsLocked()) return;
			this.m_xf.q.Set(b);
			this.m_xf.p.Assign(a);
			this.m_sweep.c.Assign(ib(this.m_xf, this.m_sweep.localCenter));
			this.m_sweep.a = b;
			this.m_sweep.c0.Assign(this.m_sweep.c);
			this.m_sweep.a0 = b;
			var c = this.m_world.m_contactManager.m_broadPhase;
			for (var d = this.m_fixtureList; d; d = d.m_next) d.Synchronize(c, this.m_xf, this.m_xf);
		},
		GetTransform: function () {
			return this.m_xf;
		},
		GetPosition: function () {
			return this.m_xf.p;
		},
		GetAngle: function () {
			return this.m_sweep.a;
		},
		GetWorldCenter: function () {
			return this.m_sweep.c;
		},
		GetLocalCenter: function () {
			return this.m_sweep.localCenter;
		},
		SetLinearVelocity: function (a) {
			if (this.m_type == Cc.b2_staticBody) return;
			if (S(a, a) > 0) this.SetAwake(true);
			this.m_linearVelocity = a;
		},
		GetLinearVelocity: function () {
			return this.m_linearVelocity;
		},
		SetAngularVelocity: function (a) {
			if (this.m_type == Cc.b2_staticBody) return;
			if (a * a > 0) this.SetAwake(true);
			this.m_angularVelocity = a;
		},
		GetAngularVelocity: function () {
			return this.m_angularVelocity;
		},
		ApplyForce: function (a, b, c) {
			if (this.m_type != Cc.b2_dynamicBody) return;
			if (c && 0 == (this.m_flags & Cc.e_awakeFlag)) this.SetAwake(true);
			if (this.m_flags & Cc.e_awakeFlag) {
				this.m_force.Add(a);
				this.m_torque += T(L.Subtract(b, this.m_sweep.c), a);
			}
		},
		ApplyForceToCenter: function (a, b) {
			if (this.m_type != Cc.b2_dynamicBody) return;
			if (b && 0 == (this.m_flags & Cc.e_awakeFlag)) this.SetAwake(true);
			if (this.m_flags & Cc.e_awakeFlag) this.m_force.Add(a);
		},
		ApplyTorque: function (a, b) {
			if (this.m_type != Cc.b2_dynamicBody) return;
			if (b && 0 == (this.m_flags & Cc.e_awakeFlag)) this.SetAwake(true);
			if (this.m_flags & Cc.e_awakeFlag) this.m_torque += a;
		},
		ApplyLinearImpulse: function (a, b, c) {
			if (this.m_type != Cc.b2_dynamicBody) return;
			if (c && 0 == (this.m_flags & Cc.e_awakeFlag)) this.SetAwake(true);
			if (this.m_flags & Cc.e_awakeFlag) {
				this.m_linearVelocity.Add(L.Multiply(this.m_invMass, a));
				this.m_angularVelocity += this.m_invI * T(L.Subtract(b, this.m_sweep.c), a);
			}
		},
		ApplyAngularImpulse: function (a, b) {
			if (this.m_type != Cc.b2_dynamicBody) return;
			if (b && 0 == (this.m_flags & Cc.e_awakeFlag)) this.SetAwake(true);
			if (this.m_flags & Cc.e_awakeFlag) this.m_angularVelocity += this.m_invI * a;
		},
		GetMass: function () {
			return this.m_mass;
		},
		GetInertia: function () {
			return this.m_I + this.m_mass * S(this.m_sweep.localCenter, this.m_sweep.localCenter);
		},
		GetMassData: function (a) {
			a.mass = this.m_mass;
			a.I = this.m_I + this.m_mass * S(this.m_sweep.localCenter, this.m_sweep.localCenter);
			a.center = this.m_sweep.localCenter;
		},
		SetMassData: function (a) {
			if (true == this.m_world.IsLocked()) return;
			if (this.m_type != Cc.b2_dynamicBody) return;
			this.m_invMass = 0;
			this.m_I = 0;
			this.m_invI = 0;
			this.m_mass = a.mass;
			if (this.m_mass <= 0) this.m_mass = 1;
			this.m_invMass = 1 / this.m_mass;
			if (a.I > 0 && 0 == (this.m_flags & Cc.e_fixedRotationFlag)) {
				this.m_I = a.I - this.m_mass * S(a.center, a.center);
				this.m_invI = 1 / this.m_I;
			}
			Cc.m_local_oldCenter.Assign(this.m_sweep.c);
			this.m_sweep.localCenter.Assign(a.center);
			this.m_sweep.c0.Assign(ib(this.m_xf, this.m_sweep.localCenter));
			this.m_sweep.c.Assign(this.m_sweep.c0);
			this.m_linearVelocity.Add(V(this.m_angularVelocity, L.Subtract(this.m_sweep.c, Cc.m_local_oldCenter)));
		},
		ResetMassData: function () {
			this.m_mass = 0;
			this.m_invMass = 0;
			this.m_I = 0;
			this.m_invI = 0;
			this.m_sweep.localCenter.SetZero();
			if (this.m_type == Cc.b2_staticBody || this.m_type == Cc.b2_kinematicBody) {
				this.m_sweep.c0.Assign(this.m_xf.p);
				this.m_sweep.c.Assign(this.m_xf.p);
				this.m_sweep.a0 = this.m_sweep.a;
				return;
			}
			var a = new L(0, 0);
			for (var b = this.m_fixtureList; b; b = b.m_next) {
				if (0 == b.m_density) continue;
				var c = new Cb();
				b.GetMassData(c);
				this.m_mass += c.mass;
				a.Add(L.Multiply(c.mass, c.center));
				this.m_I += c.I;
			}
			if (this.m_mass > 0) {
				this.m_invMass = 1 / this.m_mass;
				a.Multiply(this.m_invMass);
			} else {
				this.m_mass = 1;
				this.m_invMass = 1;
			}
			if (this.m_I > 0 && 0 == (this.m_flags & Cc.e_fixedRotationFlag)) {
				this.m_I -= this.m_mass * S(a, a);
				this.m_invI = 1 / this.m_I;
			} else {
				this.m_I = 0;
				this.m_invI = 0;
			}
			Cc.m_local_oldCenter.Assign(this.m_sweep.c);
			this.m_sweep.localCenter.Assign(a);
			this.m_sweep.c0.Assign(ib(this.m_xf, this.m_sweep.localCenter));
			this.m_sweep.c.Assign(this.m_sweep.c0);
			this.m_linearVelocity.Add(V(this.m_angularVelocity, L.Subtract(this.m_sweep.c, Cc.m_local_oldCenter)));
		},
		GetWorldPoint: function (a) {
			return ib(this.m_xf, a);
		},
		GetWorldVector: function (a) {
			return gb(this.m_xf.q, a);
		},
		GetLocalPoint: function (a) {
			return jb(this.m_xf, a);
		},
		GetLocalVector: function (a) {
			return hb(this.m_xf.q, a);
		},
		GetLinearVelocityFromWorldPoint: function (a) {
			return L.Add(this.m_linearVelocity, V(this.m_angularVelocity, L.Subtract(a, this.m_sweep.c)));
		},
		GetLinearVelocityFromLocalPoint: function (a) {
			return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(a));
		},
		GetLinearDamping: function () {
			return this.m_linearDamping;
		},
		SetLinearDamping: function (a) {
			this.m_linearDamping = a;
		},
		GetAngularDamping: function () {
			return this.m_angularDamping;
		},
		SetAngularDamping: function (a) {
			this.m_angularDamping = a;
		},
		GetGravityScale: function () {
			return this.m_gravityScale;
		},
		SetGravityScale: function (a) {
			this.m_gravityScale = a;
		},
		SetType: function (a) {
			if (true == this.m_world.IsLocked()) return;
			if (this.m_type == a) return;
			this.m_type = a;
			this.ResetMassData();
			if (this.m_type == Cc.b2_staticBody) {
				this.m_linearVelocity.SetZero();
				this.m_angularVelocity = 0;
				this.m_sweep.a0 = this.m_sweep.a;
				this.m_sweep.c0.Assign(this.m_sweep.c);
				this.SynchronizeFixtures();
			}
			this.SetAwake(true);
			this.m_force.SetZero();
			this.m_torque = 0;
			var b = this.m_contactList;
			while (b) {
				var c = b;
				b = b.next;
				this.m_world.m_contactManager.Destroy(c.contact);
			}
			this.m_contactList = null;
			var d = this.m_world.m_contactManager.m_broadPhase;
			for (var e = this.m_fixtureList; e; e = e.m_next) {
				var f = e.m_proxyCount;
				for (var g = 0; g < f; ++g) d.TouchProxy(e.m_proxies[g].proxyId);
			}
		},
		GetType: function () {
			return this.m_type;
		},
		SetBullet: function (a) {
			if (a) this.m_flags |= Cc.e_bulletFlag; else this.m_flags &= ~Cc.e_bulletFlag;
		},
		IsBullet: function () {
			return (this.m_flags & Cc.e_bulletFlag) == Cc.e_bulletFlag;
		},
		SetSleepingAllowed: function (a) {
			if (a) this.m_flags |= Cc.e_autoSleepFlag; else {
				this.m_flags &= ~Cc.e_autoSleepFlag;
				this.SetAwake(true);
			}
		},
		IsSleepingAllowed: function () {
			return (this.m_flags & Cc.e_autoSleepFlag) == Cc.e_autoSleepFlag;
		},
		SetAwake: function (a) {
			if (a) {
				if (0 == (this.m_flags & Cc.e_awakeFlag)) {
					this.m_flags |= Cc.e_awakeFlag;
					this.m_sleepTime = 0;
				}
			} else {
				this.m_flags &= ~Cc.e_awakeFlag;
				this.m_sleepTime = 0;
				this.m_linearVelocity.SetZero();
				this.m_angularVelocity = 0;
				this.m_force.SetZero();
				this.m_torque = 0;
			}
		},
		IsAwake: function () {
			return (this.m_flags & Cc.e_awakeFlag) == Cc.e_awakeFlag;
		},
		SetActive: function (a) {
			if (a == this.IsActive()) return;
			if (a) {
				this.m_flags |= Cc.e_activeFlag;
				var b = this.m_world.m_contactManager.m_broadPhase;
				for (var c = this.m_fixtureList; c; c = c.m_next) c.CreateProxies(b, this.m_xf);
			} else {
				this.m_flags &= ~Cc.e_activeFlag;
				var b = this.m_world.m_contactManager.m_broadPhase;
				for (var c = this.m_fixtureList; c; c = c.m_next) c.DestroyProxies(b);
				var d = this.m_contactList;
				while (d) {
					var e = d;
					d = d.next;
					this.m_world.m_contactManager.Destroy(e.contact);
				}
				this.m_contactList = null;
			}
		},
		IsActive: function () {
			return (this.m_flags & Cc.e_activeFlag) == Cc.e_activeFlag;
		},
		SetFixedRotation: function (a) {
			var b = (this.m_flags & Cc.e_fixedRotationFlag) == Cc.e_fixedRotationFlag;
			if (b == a) return;
			if (a) this.m_flags |= Cc.e_fixedRotationFlag; else this.m_flags &= ~Cc.e_fixedRotationFlag;
			this.m_angularVelocity = 0;
			this.ResetMassData();
		},
		IsFixedRotation: function () {
			return (this.m_flags & Cc.e_fixedRotationFlag) == Cc.e_fixedRotationFlag;
		},
		GetFixtureList: function () {
			return this.m_fixtureList;
		},
		GetJointList: function () {
			return this.m_jointList;
		},
		GetContactList: function () {
			return this.m_contactList;
		},
		GetNext: function () {
			return this.m_next;
		},
		GetUserData: function () {
			return this.m_userData;
		},
		SetUserData: function (a) {
			this.m_userData = a;
		},
		GetWorld: function () {
			return this.m_world;
		},
		SynchronizeFixtures: function () {
			Cc.m_local_xf1.q.Set(this.m_sweep.a0);
			Cc.m_local_xf1.p.Assign(L.Subtract(this.m_sweep.c0, gb(Cc.m_local_xf1.q, this.m_sweep.localCenter)));
			var a = this.m_world.m_contactManager.m_broadPhase;
			for (var b = this.m_fixtureList; b; b = b.m_next) b.Synchronize(a, Cc.m_local_xf1, this.m_xf);
		},
		SynchronizeTransform: function () {
			this.m_xf.q.Set(this.m_sweep.a);
			this.m_xf.p.Assign(L.Subtract(this.m_sweep.c, gb(this.m_xf.q, this.m_sweep.localCenter)));
		},
		ShouldCollide: function (a) {
			if (this.m_type != Cc.b2_dynamicBody && a.m_type != Cc.b2_dynamicBody) return false;
			for (var b = this.m_jointList; b; b = b.next) if (b.other == a) if (false == b.joint.m_collideConnected) return false;
			return true;
		},
		Advance: function (a) {
			this.m_sweep.Advance(a);
			this.m_sweep.c.Assign(this.m_sweep.c0);
			this.m_sweep.a = this.m_sweep.a0;
			this.m_xf.q.Set(this.m_sweep.a);
			this.m_xf.p.Assign(L.Subtract(this.m_sweep.c, gb(this.m_xf.q, this.m_sweep.localCenter)));
		},
		_serialize: function (a) {
			var b = a || {};
			b.fixtures = null;
			b.type = this.m_type;
			b.position = this.GetPosition()._serialize();
			b.angle = this.GetAngle();
			b.linearVelocity = this.GetLinearVelocity()._serialize();
			b.angularVelocity = this.GetAngularVelocity();
			b.linearDamping = this.GetLinearDamping();
			b.angularDamping = this.GetAngularDamping();
			b.allowSleep = this.IsSleepingAllowed();
			b.awake = this.IsAwake();
			b.fixedRotation = this.IsFixedRotation();
			b.bullet = this.IsBullet();
			b.active = this.IsActive();
			b.gravityScale = this.GetGravityScale();
			return b;
		}
	};
	function Dc() {
		this.categoryBits = 1;
		this.maskBits = 65535;
		this.groupIndex = 0;
	}
	Dc.prototype = {
		Clone: function () {
			var a = new Dc();
			a.categoryBits = this.categoryBits;
			a.maskBits = this.maskBits;
			a.groupIndex = this.groupIndex;
			return a;
		},
		Assign: function (a) {
			this.categoryBits = a.categoryBits;
			this.maskBits = a.maskBits;
			this.groupIndex = a.groupIndex;
		},
		_serialize: function (a) {
			var b = a || {};
			b.categoryBits = this.categoryBits;
			b.maskBits = this.maskBits;
			b.groupIndex = this.groupIndex;
			return b;
		},
		_deserialize: function (a) {
			this.categoryBits = a.categoryBits;
			this.maskBits = a.maskBits;
			this.groupIndex = a.groupIndex;
		}
	};
	function Ec() {
		this.shape = null;
		this.userData = null;
		this.friction = .2;
		this.restitution = 0;
		this.density = 0;
		this.isSensor = false;
		this.filter = new Dc();
		Object.seal(this);
	}
	Ec.prototype = {
		_deserialize: function (a) {
			this.friction = a.friction;
			this.restitution = a.restitution;
			this.density = a.density;
			this.isSensor = a.isSensor;
			this.filter._deserialize(a.filter);
		}
	};
	function Fc() {
		this.aabb = new cc();
		this.fixture = null;
		this.childIndex = 0;
		this.proxyId = 0;
	}
	function Gc() {
		this.m_userData = null;
		this.m_body = null;
		this.m_next = null;
		this.m_proxies = null;
		this.m_proxyCount = 0;
		this.m_shape = null;
		this.m_density = 0;
		this.m_filter = new Dc();
		this.m_isSensor = false;
		this.m_friction = 0;
		this.m_restitution = 0;
	}
	Gc.prototype = {
		GetType: function () {
			return this.m_shape.GetType();
		},
		GetShape: function () {
			return this.m_shape;
		},
		SetSensor: function (a) {
			if (a != this.m_isSensor) {
				this.m_body.SetAwake(true);
				this.m_isSensor = a;
			}
		},
		IsSensor: function () {
			return this.m_isSensor;
		},
		SetFilterData: function (a) {
			this.m_filter = a;
			this.Refilter();
		},
		GetFilterData: function () {
			return this.m_filter;
		},
		Refilter: function () {
			if (null == this.m_body) return;
			var a = this.m_body.GetContactList();
			while (a) {
				var b = a.contact;
				var c = b.GetFixtureA();
				var d = b.GetFixtureB();
				if (c == this || d == this) b.FlagForFiltering();
				a = a.next;
			}
			var e = this.m_body.GetWorld();
			if (null == e) return;
			var f = e.m_contactManager.m_broadPhase;
			for (var g = 0; g < this.m_proxyCount; ++g) f.TouchProxy(this.m_proxies[g].proxyId);
		},
		GetBody: function () {
			return this.m_body;
		},
		GetNext: function () {
			return this.m_next;
		},
		GetUserData: function () {
			return this.m_userData;
		},
		SetUserData: function (a) {
			this.m_userData = a;
		},
		TestPoint: function (a) {
			return this.m_shape.TestPoint(this.m_body.GetTransform(), a);
		},
		RayCast: function (a, b, c) {
			return this.m_shape.RayCast(a, b, this.m_body.GetTransform(), c);
		},
		GetMassData: function (a) {
			this.m_shape.ComputeMass(a, this.m_density);
		},
		SetDensity: function (a) {
			this.m_density = a;
		},
		GetDensity: function () {
			return this.m_density;
		},
		GetFriction: function () {
			return this.m_friction;
		},
		SetFriction: function (a) {
			this.m_friction = a;
		},
		GetRestitution: function () {
			return this.m_restitution;
		},
		SetRestitution: function (a) {
			this.m_restitution = a;
		},
		GetAABB: function (a) {
			return this.m_proxies[a].aabb;
		},
		Create: function (a, b) {
			this.m_userData = b.userData;
			this.m_friction = b.friction;
			this.m_restitution = b.restitution;
			this.m_body = a;
			this.m_next = null;
			this.m_filter.Assign(b.filter);
			this.m_isSensor = b.isSensor;
			this.m_shape = b.shape.Clone();
			var c = this.m_shape.GetChildCount();
			this.m_proxies = new Array(c);
			for (var d = 0; d < c; ++d) {
				this.m_proxies[d] = new Fc();
				this.m_proxies[d].fixture = null;
				this.m_proxies[d].proxyId = Kb.e_nullProxy;
			}
			this.m_proxyCount = 0;
			this.m_density = b.density;
		},
		Destroy: function () {
			this.m_proxies = null;
			this.m_shape = null;
		},
		CreateProxies: function (a, b) {
			this.m_proxyCount = this.m_shape.GetChildCount();
			for (var c = 0; c < this.m_proxyCount; ++c) {
				var d = this.m_proxies[c];
				this.m_shape.ComputeAABB(d.aabb, b, c);
				d.proxyId = a.CreateProxy(d.aabb, d);
				d.fixture = this;
				d.childIndex = c;
			}
		},
		DestroyProxies: function (a) {
			for (var b = 0; b < this.m_proxyCount; ++b) {
				var c = this.m_proxies[b];
				a.DestroyProxy(c.proxyId);
				c.proxyId = Kb.e_nullProxy;
			}
			this.m_proxyCount = 0;
		},
		Synchronize: function (a, b, c) {
			if (0 == this.m_proxyCount) return;
			for (var d = 0; d < this.m_proxyCount; ++d) {
				var e = this.m_proxies[d];
				var f = new cc(), g = new cc();
				this.m_shape.ComputeAABB(f, b, e.childIndex);
				this.m_shape.ComputeAABB(g, c, e.childIndex);
				e.aabb.Combine(f, g);
				var h = L.Subtract(c.p, b.p);
				a.MoveProxy(e.proxyId, e.aabb, h);
			}
		},
		_serialize: function (a) {
			var b = a || {};
			b.shape = null;
			b.friction = this.m_friction;
			b.restitution = this.m_restitution;
			b.density = this.m_density;
			b.isSensor = this.m_isSensor;
			b.filter = this.m_filter._serialize();
			return b;
		}
	};
	function Hc() { }
	Hc.prototype = {
		SayGoodbyeJoint: function (a) { },
		SayGoodbyeFixture: function (a) { }
	};
	function Ic() { }
	Ic.prototype = {
		ShouldCollide: function (a, b) {
			var c = a.GetFilterData();
			var d = b.GetFilterData();
			if (c.groupIndex == d.groupIndex && 0 != c.groupIndex) return c.groupIndex > 0;
			var e = 0 != (c.maskBits & d.categoryBits) && 0 != (c.categoryBits & d.maskBits);
			return e;
		}
	};
	function Jc() {
		this.normalImpulses = new Array(e);
		this.tangentImpulses = new Array(e);
		this.count = 0;
	}
	function Kc() { }
	Kc.prototype = {
		BeginContact: function (a) { },
		EndContact: function (a) { },
		PreSolve: function (a, b) { },
		PostSolve: function (a, b) { }
	};
	function Lc() { }
	Lc.prototype = {
		ReportFixture: function (a) { }
	};
	function Mc() { }
	Mc.prototype = {
		ReportFixture: function (a, b, c, d) { }
	};
	function Nc() {
		this.dt = 0;
		this.inv_dt = 0;
		this.dtRatio = 0;
		this.velocityIterations = 0;
		this.positionIterations = 0;
		this.warmStarting = false;
	}
	function Oc() {
		this.c = new L();
		this.a = 0;
	}
	function Pc() {
		this.v = new L();
		this.w = 0;
	}
	function Qc() {
		this.step = new Nc();
		this.positions = null;
		this.velocities = null;
	}
	var Rc = a.create("step");
	var Sc = a.create("collide", "step");
	var Tc = a.create("solve", "step");
	var Uc = a.create("solveTOI", "step");
	var Vc = a.create("broadphase", "step");
	function Wc(a) {
		this.m_contactManager = new md();
		this.m_destructionListener = null;
		this.g_debugDraw = null;
		this.m_bodyList = null;
		this.m_jointList = null;
		this.m_bodyCount = 0;
		this.m_jointCount = 0;
		this.m_warmStarting = true;
		this.m_continuousPhysics = true;
		this.m_subStepping = false;
		this.m_stepComplete = true;
		this.m_allowSleep = true;
		this.m_gravity = a;
		this.m_flags = Wc.e_clearForces;
		this.m_inv_dt0 = 0;
		this.p_step = new Nc();
		this.p_island = new td();
	}
	function Xc() {
		this.broadPhase = null;
		this.callback = null;
	}
	Xc.prototype = {
		QueryCallback: function (a) {
			var b = this.broadPhase.GetUserData(a);
			return this.callback.ReportFixture(b.fixture);
		}
	};
	function Yc() {
		this.broadPhase = null;
		this.callback = null;
	}
	Yc.prototype = {
		RayCastCallback: function (a, b) {
			var c = this.broadPhase.GetUserData(b);
			var d = c;
			var e = d.fixture;
			var f = d.childIndex;
			var g = new bc();
			var h = e.RayCast(g, a, f);
			if (h) {
				var i = g.fraction;
				var j = L.Add(L.Multiply(1 - i, a.p1), L.Multiply(i, a.p2));
				return this.callback.ReportFixture(e, j, g.normal, i);
			}
			return a.maxFraction;
		}
	};
	Wc.m_local_sweep_backupA = new R();
	Wc.m_local_sweep_backupB = new R();
	Wc.m_local_sweep_backupC = new R();
	Wc.prototype = {
		Destroy: function () {
			var a = this.m_bodyList;
			while (a) {
				var b = a.m_next;
				var c = a.m_fixtureList;
				while (c) {
					var d = c.m_next;
					c.m_proxyCount = 0;
					c.Destroy();
					c = d;
				}
				a = b;
			}
		},
		SetDestructionListener: function (a) {
			this.m_destructionListener = a;
		},
		SetContactFilter: function (a) {
			this.m_contactManager.m_contactFilter = a;
		},
		SetContactListener: function (a) {
			this.m_contactManager.m_contactListener = a;
		},
		SetDebugDraw: function (a) {
			this.g_debugDraw = a;
		},
		CreateBody: function (a) {
			if (this.IsLocked()) return null;
			var b = new Cc(a, this);
			b.m_prev = null;
			b.m_next = this.m_bodyList;
			if (this.m_bodyList) this.m_bodyList.m_prev = b;
			this.m_bodyList = b;
			++this.m_bodyCount;
			return b;
		},
		DestroyBody: function (a) {
			if (this.IsLocked()) return;
			var b = a.m_jointList;
			while (b) {
				var c = b;
				b = b.next;
				if (this.m_destructionListener) this.m_destructionListener.SayGoodbyeJoint(c.joint);
				this.DestroyJoint(c.joint);
				a.m_jointList = b;
			}
			a.m_jointList = null;
			var d = a.m_contactList;
			while (d) {
				var e = d;
				d = d.next;
				this.m_contactManager.Destroy(e.contact);
			}
			a.m_contactList = null;
			var f = a.m_fixtureList;
			while (f) {
				var g = f;
				f = f.m_next;
				if (this.m_destructionListener) this.m_destructionListener.SayGoodbyeFixture(g);
				g.DestroyProxies(this.m_contactManager.m_broadPhase);
				g.Destroy();
				a.m_fixtureList = f;
				a.m_fixtureCount -= 1;
			}
			a.m_fixtureList = null;
			a.m_fixtureCount = 0;
			if (a.m_prev) a.m_prev.m_next = a.m_next;
			if (a.m_next) a.m_next.m_prev = a.m_prev;
			if (a == this.m_bodyList) this.m_bodyList = a.m_next;
			a.m_destroyed = true;
			--this.m_bodyCount;
		},
		CreateJoint: function (a) {
			if (this.IsLocked()) return null;
			var b = Bd.Create(a);
			b.m_prev = null;
			b.m_next = this.m_jointList;
			if (this.m_jointList) this.m_jointList.m_prev = b;
			this.m_jointList = b;
			++this.m_jointCount;
			b.m_edgeA.joint = b;
			b.m_edgeA.other = b.m_bodyB;
			b.m_edgeA.prev = null;
			b.m_edgeA.next = b.m_bodyA.m_jointList;
			if (b.m_bodyA.m_jointList) b.m_bodyA.m_jointList.prev = b.m_edgeA;
			b.m_bodyA.m_jointList = b.m_edgeA;
			b.m_edgeB.joint = b;
			b.m_edgeB.other = b.m_bodyA;
			b.m_edgeB.prev = null;
			b.m_edgeB.next = b.m_bodyB.m_jointList;
			if (b.m_bodyB.m_jointList) b.m_bodyB.m_jointList.prev = b.m_edgeB;
			b.m_bodyB.m_jointList = b.m_edgeB;
			var c = a.bodyA;
			var d = a.bodyB;
			if (false == a.collideConnected) {
				var e = d.GetContactList();
				while (e) {
					if (e.other == c) e.contact.FlagForFiltering();
					e = e.next;
				}
			}
			return b;
		},
		DestroyJoint: function (a) {
			if (this.IsLocked()) return;
			var b = a.m_collideConnected;
			if (a.m_prev) a.m_prev.m_next = a.m_next;
			if (a.m_next) a.m_next.m_prev = a.m_prev;
			if (a == this.m_jointList) this.m_jointList = a.m_next;
			var c = a.m_bodyA;
			var d = a.m_bodyB;
			c.SetAwake(true);
			d.SetAwake(true);
			if (a.m_edgeA.prev) a.m_edgeA.prev.next = a.m_edgeA.next;
			if (a.m_edgeA.next) a.m_edgeA.next.prev = a.m_edgeA.prev;
			if (a.m_edgeA == c.m_jointList) c.m_jointList = a.m_edgeA.next;
			a.m_edgeA.prev = null;
			a.m_edgeA.next = null;
			if (a.m_edgeB.prev) a.m_edgeB.prev.next = a.m_edgeB.next;
			if (a.m_edgeB.next) a.m_edgeB.next.prev = a.m_edgeB.prev;
			if (a.m_edgeB == d.m_jointList) d.m_jointList = a.m_edgeB.next;
			a.m_edgeB.prev = null;
			a.m_edgeB.next = null;
			Bd.Destroy(a);
			--this.m_jointCount;
			if (false == b) {
				var e = d.GetContactList();
				while (e) {
					if (e.other == c) e.contact.FlagForFiltering();
					e = e.next;
				}
			}
		},
		Step: function (a, b, c) {
			Rc.start();
			if (this.m_flags & Wc.e_newFixture) {
				this.m_contactManager.FindNewContacts();
				this.m_flags &= ~Wc.e_newFixture;
			}
			this.m_flags |= Wc.e_locked;
			this.p_step.dt = a;
			this.p_step.velocityIterations = b;
			this.p_step.positionIterations = c;
			if (a > 0) this.p_step.inv_dt = 1 / a; else this.p_step.inv_dt = 0;
			this.p_step.dtRatio = this.m_inv_dt0 * a;
			this.p_step.warmStarting = this.m_warmStarting;
			Sc.start();
			this.m_contactManager.Collide();
			Sc.stop();
			if (this.m_stepComplete && this.p_step.dt > 0) {
				Tc.start();
				this.Solve(this.p_step);
				Tc.stop();
			}
			if (this.m_continuousPhysics && this.p_step.dt > 0) {
				Uc.start();
				this.SolveTOI(this.p_step);
				Uc.stop();
			}
			if (this.p_step.dt > 0) this.m_inv_dt0 = this.p_step.inv_dt;
			if (this.m_flags & Wc.e_clearForces) this.ClearForces();
			this.m_flags &= ~Wc.e_locked;
			Rc.stop();
		},
		ClearForces: function () {
			for (var a = this.m_bodyList; a; a = a.GetNext()) {
				a.m_force.x = a.m_force.y = 0;
				a.m_torque = 0;
			}
		},
		DrawDebugData: function () {
			if (null == this.g_debugDraw) return;
			var a = this.g_debugDraw.GetFlags();
			if (a & Ab.e_shapeBit) for (var b = this.m_bodyList; b; b = b.GetNext()) {
				var c = b.GetTransform();
				for (var d = b.GetFixtureList(); d; d = d.GetNext()) if (false == b.IsActive()) this.DrawShape(d, c, new zb(.5, .5, .3)); else if (b.GetType() == Cc.b2_staticBody) this.DrawShape(d, c, new zb(.5, .9, .5)); else if (b.GetType() == Cc.b2_kinematicBody) this.DrawShape(d, c, new zb(.5, .5, .9)); else if (false == b.IsAwake()) this.DrawShape(d, c, new zb(.6, .6, .6)); else this.DrawShape(d, c, new zb(.9, .7, .7));
			}
			if (a & Ab.e_jointBit) for (var e = this.m_jointList; e; e = e.GetNext()) this.DrawJoint(e);
			if (a & Ab.e_pairBit) {
				var f = new zb(.3, .9, .9);
				for (var g = this.m_contactManager.m_contactList; g; g = g.GetNext()) {
					var h = g.GetFixtureA();
					var i = g.GetFixtureB();
					var j = h.GetAABB(g.GetChildIndexA()).GetCenter();
					var k = i.GetAABB(g.GetChildIndexB()).GetCenter();
					this.g_debugDraw.DrawSegment(j, k, f);
				}
			}
			if (a & Ab.e_aabbBit) {
				var f = new zb(.9, .3, .9);
				var l = this.m_contactManager.m_broadPhase;
				for (var b = this.m_bodyList; b; b = b.GetNext()) {
					if (false == b.IsActive()) continue;
					for (var d = b.GetFixtureList(); d; d = d.GetNext()) for (var m = 0; m < d.m_proxyCount; ++m) {
						var n = d.m_proxies[m];
						var o = l.GetFatAABB(n.proxyId);
						var p = [];
						p[0] = new L(o.lowerBound.x, o.lowerBound.y);
						p[1] = new L(o.upperBound.x, o.lowerBound.y);
						p[2] = new L(o.upperBound.x, o.upperBound.y);
						p[3] = new L(o.lowerBound.x, o.upperBound.y);
						this.g_debugDraw.DrawPolygon(p, 4, f);
					}
				}
			}
			if (a & Ab.e_centerOfMassBit) for (var b = this.m_bodyList; b; b = b.GetNext()) {
				var c = b.GetTransform().Clone();
				c.p = b.GetWorldCenter();
				this.g_debugDraw.DrawTransform(c);
			}
		},
		QueryAABB: function (a, b) {
			var c = new Xc();
			c.broadPhase = this.m_contactManager.m_broadPhase;
			c.callback = a;
			this.m_contactManager.m_broadPhase.Query(c, b);
		},
		RayCast: function (a, b, c) {
			var d = new Yc();
			d.broadPhase = this.m_contactManager.m_broadPhase;
			d.callback = a;
			var e = new ac();
			e.maxFraction = 1;
			e.p1 = b;
			e.p2 = c;
			this.m_contactManager.m_broadPhase.RayCast(d, e);
		},
		GetBodyList: function () {
			return this.m_bodyList;
		},
		GetJointList: function () {
			return this.m_jointList;
		},
		GetContactList: function () {
			return this.m_contactManager.m_contactList;
		},
		SetAllowSleeping: function (a) {
			if (a == this.m_allowSleep) return;
			this.m_allowSleep = a;
			if (false == this.m_allowSleep) for (var b = this.m_bodyList; b; b = b.m_next) b.SetAwake(true);
		},
		GetAllowSleeping: function () {
			return this.m_allowSleep;
		},
		SetWarmStarting: function (a) {
			this.m_warmStarting = a;
		},
		GetWarmStarting: function () {
			return this.m_warmStarting;
		},
		SetContinuousPhysics: function (a) {
			this.m_continuousPhysics = a;
		},
		GetContinuousPhysics: function () {
			return this.m_continuousPhysics;
		},
		SetSubStepping: function (a) {
			this.m_subStepping = a;
		},
		GetSubStepping: function () {
			return this.m_subStepping;
		},
		GetProxyCount: function () {
			return this.m_contactManager.m_broadPhase.GetProxyCount();
		},
		GetBodyCount: function () {
			return this.m_bodyCount;
		},
		GetJointCount: function () {
			return this.m_jointCount;
		},
		GetContactCount: function () {
			return this.m_contactManager.m_contactCount;
		},
		GetTreeHeight: function () {
			return this.m_contactManager.m_broadPhase.GetTreeHeight();
		},
		GetTreeBalance: function () {
			return this.m_contactManager.m_broadPhase.GetTreeBalance();
		},
		GetTreeQuality: function () {
			return this.m_contactManager.m_broadPhase.GetTreeQuality();
		},
		SetGravity: function (a) {
			this.m_gravity = a;
		},
		GetGravity: function () {
			return this.m_gravity;
		},
		IsLocked: function () {
			return (this.m_flags & Wc.e_locked) == Wc.e_locked;
		},
		SetAutoClearForces: function (a) {
			if (a) this.m_flags |= Wc.e_clearForces; else this.m_flags &= ~Wc.e_clearForces;
		},
		GetAutoClearForces: function () {
			return (this.m_flags & Wc.e_clearForces) == Wc.e_clearForces;
		},
		ShiftOrigin: function (a) {
			if ((this.m_flags & Wc.e_locked) == Wc.e_locked) return;
			for (var b = this.m_bodyList; b; b = b.m_next) {
				b.m_xf.p.Subtract(a);
				b.m_sweep.c0.Subtract(a);
				b.m_sweep.c.Subtract(a);
			}
			for (var c = this.m_jointList; c; c = c.m_next) c.ShiftOrigin(a);
			this.m_contactManager.m_broadPhase.ShiftOrigin(a);
		},
		GetContactManager: function () {
			return this.m_contactManager;
		},
		Solve: function (a) {
			this.p_island.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, this.m_contactManager.m_contactListener);
			for (var b = this.m_bodyList; b; b = b.m_next) b.m_flags &= ~Cc.e_islandFlag;
			for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) c.m_flags &= ~bd.e_islandFlag;
			for (var d = this.m_jointList; d; d = d.m_next) d.m_islandFlag = false;
			var e = this.m_bodyCount;
			var f = new Array(e);
			for (var g = this.m_bodyList; g; g = g.m_next) {
				if (g.m_flags & Cc.e_islandFlag) continue;
				if (false == g.IsAwake() || false == g.IsActive()) continue;
				if (g.GetType() == Cc.b2_staticBody) continue;
				this.p_island.Clear();
				var h = 0;
				f[h++] = g;
				g.m_flags |= Cc.e_islandFlag;
				while (h > 0) {
					var b = f[--h];
					this.p_island.AddBody(b);
					b.SetAwake(true);
					if (b.GetType() == Cc.b2_staticBody) continue;
					for (var i = b.m_contactList; i; i = i.next) {
						var j = i.contact;
						if (j.m_flags & bd.e_islandFlag) continue;
						if (false == j.IsEnabled() || false == j.IsTouching()) continue;
						var k = j.m_fixtureA.m_isSensor;
						var l = j.m_fixtureB.m_isSensor;
						if (k || l) continue;
						this.p_island.AddContact(j);
						j.m_flags |= bd.e_islandFlag;
						var m = i.other;
						if (m.m_flags & Cc.e_islandFlag) continue;
						f[h++] = m;
						m.m_flags |= Cc.e_islandFlag;
					}
					for (var n = b.m_jointList; n; n = n.next) {
						if (true == n.joint.m_islandFlag) continue;
						var m = n.other;
						if (false == m.IsActive()) continue;
						this.p_island.AddJoint(n.joint);
						n.joint.m_islandFlag = true;
						if (m.m_flags & Cc.e_islandFlag) continue;
						f[h++] = m;
						m.m_flags |= Cc.e_islandFlag;
					}
				}
				this.p_island.Solve(a, this.m_gravity, this.m_allowSleep);
				for (var o = 0; o < this.p_island.m_bodyCount; ++o) {
					var b = this.p_island.m_bodies[o];
					if (b.GetType() == Cc.b2_staticBody) b.m_flags &= ~Cc.e_islandFlag;
				}
			}
			Vc.start();
			for (var b = this.m_bodyList; b; b = b.GetNext()) {
				if (0 == (b.m_flags & Cc.e_islandFlag)) continue;
				if (b.GetType() == Cc.b2_staticBody) continue;
				b.SynchronizeFixtures();
			}
			this.m_contactManager.FindNewContacts();
			Vc.stop();
		},
		SolveTOI: function (a) {
			this.p_island.Initialize(2 * m, m, 0, this.m_contactManager.m_contactListener);
			if (this.m_stepComplete) {
				for (var b = this.m_bodyList; b; b = b.m_next) {
					b.m_flags &= ~Cc.e_islandFlag;
					b.m_sweep.alpha0 = 0;
				}
				for (var d = this.m_contactManager.m_contactList; d; d = d.m_next) {
					d.m_flags &= ~(bd.e_toiFlag | bd.e_islandFlag);
					d.m_toiCount = 0;
					d.m_toi = 1;
				}
			}
			for (; ;) {
				var e = null;
				var f = 1;
				for (var d = this.m_contactManager.m_contactList; d; d = d.m_next) {
					if (false == d.IsEnabled()) continue;
					if (d.m_toiCount > l) continue;
					var g = 1;
					if (d.m_flags & bd.e_toiFlag) g = d.m_toi; else {
						var h = d.GetFixtureA();
						var i = d.GetFixtureB();
						if (h.IsSensor() || i.IsSensor()) continue;
						var j = h.GetBody();
						var k = i.GetBody();
						var n = j.m_type;
						var o = k.m_type;
						var p = j.IsAwake() && n != Cc.b2_staticBody;
						var q = k.IsAwake() && o != Cc.b2_staticBody;
						if (false == p && false == q) continue;
						var r = j.IsBullet() || n != Cc.b2_dynamicBody;
						var s = k.IsBullet() || o != Cc.b2_dynamicBody;
						if (false == r && false == s) continue;
						var t = j.m_sweep.alpha0;
						if (j.m_sweep.alpha0 < k.m_sweep.alpha0) {
							t = k.m_sweep.alpha0;
							j.m_sweep.Advance(t);
						} else if (k.m_sweep.alpha0 < j.m_sweep.alpha0) {
							t = j.m_sweep.alpha0;
							k.m_sweep.Advance(t);
						}
						var u = d.GetChildIndexA();
						var v = d.GetChildIndexB();
						var w = new uc();
						w.proxyA.Set(h.GetShape(), u);
						w.proxyB.Set(i.GetShape(), v);
						w.sweepA.Assign(j.m_sweep);
						w.sweepB.Assign(k.m_sweep);
						w.tMax = 1;
						var x = new vc();
						Ac(x, w);
						var y = x.t;
						if (x.state == vc.e_touching) g = pb(t + (1 - t) * y, 1); else g = 1;
						d.m_toi = g;
						d.m_flags |= bd.e_toiFlag;
					}
					if (g < f) {
						e = d;
						f = g;
					}
				}
				if (null == e || 1 - 10 * c < f) {
					this.m_stepComplete = true;
					break;
				}
				var h = e.GetFixtureA();
				var i = e.GetFixtureB();
				var j = h.GetBody();
				var k = i.GetBody();
				Wc.m_local_sweep_backupA.Assign(j.m_sweep);
				Wc.m_local_sweep_backupB.Assign(k.m_sweep);
				j.Advance(f);
				k.Advance(f);
				e.Update(this.m_contactManager.m_contactListener);
				e.m_flags &= ~bd.e_toiFlag;
				++e.m_toiCount;
				if (false == e.IsEnabled() || false == e.IsTouching()) {
					e.SetEnabled(false);
					j.m_sweep.Assign(Wc.m_local_sweep_backupA);
					k.m_sweep.Assign(Wc.m_local_sweep_backupB);
					j.SynchronizeTransform();
					k.SynchronizeTransform();
					continue;
				}
				j.SetAwake(true);
				k.SetAwake(true);
				this.p_island.Clear();
				this.p_island.AddBody(j);
				this.p_island.AddBody(k);
				this.p_island.AddContact(e);
				j.m_flags |= Cc.e_islandFlag;
				k.m_flags |= Cc.e_islandFlag;
				e.m_flags |= bd.e_islandFlag;
				var z = [j, k];
				for (var A = 0; A < 2; ++A) {
					var B = z[A];
					if (B.m_type == Cc.b2_dynamicBody) for (var C = B.m_contactList; C; C = C.next) {
						if (this.p_island.m_bodyCount == this.p_island.m_bodyCapacity) break;
						if (this.p_island.m_contactCount == this.p_island.m_contactCapacity) break;
						var D = C.contact;
						if (D.m_flags & bd.e_islandFlag) continue;
						var E = C.other;
						if (E.m_type == Cc.b2_dynamicBody && false == B.IsBullet() && false == E.IsBullet()) continue;
						var F = D.m_fixtureA.m_isSensor;
						var G = D.m_fixtureB.m_isSensor;
						if (F || G) continue;
						Wc.m_local_sweep_backupC.Assign(E.m_sweep);
						if (0 == (E.m_flags & Cc.e_islandFlag)) E.Advance(f);
						D.Update(this.m_contactManager.m_contactListener);
						if (false == D.IsEnabled()) {
							E.m_sweep.Assign(Wc.m_local_sweep_backupC);
							E.SynchronizeTransform();
							continue;
						}
						if (false == D.IsTouching()) {
							E.m_sweep.Assign(Wc.m_local_sweep_backupC);
							E.SynchronizeTransform();
							continue;
						}
						D.m_flags |= bd.e_islandFlag;
						this.p_island.AddContact(D);
						if (E.m_flags & Cc.e_islandFlag) continue;
						E.m_flags |= Cc.e_islandFlag;
						if (E.m_type != Cc.b2_staticBody) E.SetAwake(true);
						this.p_island.AddBody(E);
					}
				}
				var H = new Nc();
				H.dt = (1 - f) * a.dt;
				H.inv_dt = 1 / H.dt;
				H.dtRatio = 1;
				H.positionIterations = 20;
				H.velocityIterations = a.velocityIterations;
				H.warmStarting = false;
				this.p_island.SolveTOI(H, j.m_islandIndex, k.m_islandIndex);
				for (var A = 0; A < this.p_island.m_bodyCount; ++A) {
					var B = this.p_island.m_bodies[A];
					B.m_flags &= ~Cc.e_islandFlag;
					if (B.m_type != Cc.b2_dynamicBody) continue;
					B.SynchronizeFixtures();
					for (var C = B.m_contactList; C; C = C.next) C.contact.m_flags &= ~(bd.e_toiFlag | bd.e_islandFlag);
				}
				this.m_contactManager.FindNewContacts();
				if (this.m_subStepping) {
					this.m_stepComplete = false;
					break;
				}
			}
		},
		DrawJoint: function (a) {
			var b = a.GetBodyA();
			var c = a.GetBodyB();
			var d = b.GetTransform();
			var e = c.GetTransform();
			var f = d.p;
			var g = e.p;
			var h = a.GetAnchorA();
			var i = a.GetAnchorB();
			var j = new zb(.5, .8, .8);
			switch (a.GetType()) {
				case Bd.e_distanceJoint:
					this.g_debugDraw.DrawSegment(h, i, j);
					break;

				case Bd.e_pulleyJoint:
					var k = a;
					var l = k.GetGroundAnchorA();
					var m = k.GetGroundAnchorB();
					this.g_debugDraw.DrawSegment(l, h, j);
					this.g_debugDraw.DrawSegment(m, i, j);
					this.g_debugDraw.DrawSegment(l, m, j);
					break;

				case Bd.e_mouseJoint:
					break;

				case Bd.e_motorJoint:
					this.g_debugDraw.DrawPoint(a.GetLinearOffset(), 5, j);

				default:
					this.g_debugDraw.DrawSegment(f, h, j);
					this.g_debugDraw.DrawSegment(h, i, j);
					this.g_debugDraw.DrawSegment(g, i, j);
			}
		},
		DrawShape: function (a, b, c) {
			switch (a.GetType()) {
				case Db.e_circle:
					var d = a.GetShape();
					var e = ib(b, d.m_p);
					var g = d.m_radius;
					var h = gb(b.q, new L(1, 0));
					this.g_debugDraw.DrawSolidCircle(e, g, h, c);
					break;

				case Db.e_edge:
					var i = a.GetShape();
					var j = ib(b, i.m_vertex1);
					var k = ib(b, i.m_vertex2);
					this.g_debugDraw.DrawSegment(j, k, c);
					break;

				case Db.e_chain:
					var l = a.GetShape();
					var m = l.m_count;
					var n = l.m_vertices;
					var j = ib(b, n[0]);
					for (var o = 1; o < m; ++o) {
						var k = ib(b, n[o]);
						this.g_debugDraw.DrawSegment(j, k, c);
						j = k;
					}
					break;

				case Db.e_polygon:
					var p = a.GetShape();
					var q = p.m_count;
					var n = new Array(f);
					for (var o = 0; o < q; ++o) n[o] = ib(b, p.m_vertices[o]);
					this.g_debugDraw.DrawSolidPolygon(n, q, c);
			}
		}
	};
	Wc.e_newFixture = 1;
	Wc.e_locked = 2;
	Wc.e_clearForces = 4;
	function Zc(a, b) {
		return I(a * b);
	}
	function $c(a, b) {
		return a > b ? a : b;
	}
	function _c() {
		this.fcn = null;
		this.primary = false;
	}
	function ad() {
		this.other = null;
		this.contact = null;
		this.prev = null;
		this.next = null;
	}
	function bd() {
		this.m_nodeA = new ad();
		this.m_nodeB = new ad();
		this.m_manifold = new Yb();
	}
	bd.m_local_tempManifold = new Yb();
	bd.prototype = {
		Create: function (a, b, c, d) {
			this.m_toi = 0;
			this.m_flags = bd.e_enabledFlag;
			this.m_fixtureA = a || null;
			this.m_fixtureB = c || null;
			this.m_indexA = b || 0;
			this.m_indexB = d || 0;
			this.m_manifold.pointCount = 0;
			this.m_prev = null;
			this.m_next = null;
			this.m_nodeA.contact = null;
			this.m_nodeA.prev = null;
			this.m_nodeA.next = null;
			this.m_nodeA.other = null;
			this.m_nodeB.contact = null;
			this.m_nodeB.prev = null;
			this.m_nodeB.next = null;
			this.m_nodeB.other = null;
			this.m_toiCount = 0;
			if (a) {
				this.m_friction = Zc(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
				this.m_restitution = $c(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
			} else {
				this.m_friction = 0;
				this.m_restitution = 0;
			}
			this.m_tangentSpeed = 0;
		},
		GetManifold: function () {
			return this.m_manifold;
		},
		GetWorldManifold: function (a) {
			var b = this.m_fixtureA.GetBody();
			var c = this.m_fixtureB.GetBody();
			var d = this.m_fixtureA.GetShape();
			var e = this.m_fixtureB.GetShape();
			a.Initialize(this.m_manifold, b.GetTransform(), d.m_radius, c.GetTransform(), e.m_radius);
		},
		IsTouching: function () {
			return (this.m_flags & bd.e_touchingFlag) == bd.e_touchingFlag;
		},
		SetEnabled: function (a) {
			if (a) this.m_flags |= bd.e_enabledFlag; else this.m_flags &= ~bd.e_enabledFlag;
		},
		IsEnabled: function () {
			return (this.m_flags & bd.e_enabledFlag) == bd.e_enabledFlag;
		},
		GetNext: function () {
			return this.m_next;
		},
		GetFixtureA: function () {
			return this.m_fixtureA;
		},
		GetChildIndexA: function () {
			return this.m_indexA;
		},
		GetFixtureB: function () {
			return this.m_fixtureB;
		},
		GetChildIndexB: function () {
			return this.m_indexB;
		},
		SetFriction: function (a) {
			this.m_friction = a;
		},
		GetFriction: function () {
			return this.m_friction;
		},
		ResetFriction: function () {
			this.m_friction = Zc(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
		},
		SetRestitution: function (a) {
			this.m_restitution = a;
		},
		GetRestitution: function () {
			return this.m_restitution;
		},
		ResetRestitution: function () {
			this.m_restitution = $c(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
		},
		SetTangentSpeed: function (a) {
			this.m_tangentSpeed = a;
		},
		GetTangentSpeed: function () {
			return this.m_tangentSpeed;
		},
		Evaluate: function (a, b, c) { },
		FlagForFiltering: function () {
			this.m_flags |= bd.e_filterFlag;
		},
		m_oldManifold: null,
		Update: function (a) {
			bd.m_local_tempManifold.Assign(this.m_manifold);
			this.m_flags |= bd.e_enabledFlag;
			var b = false;
			var c = (this.m_flags & bd.e_touchingFlag) == bd.e_touchingFlag;
			var d = this.m_fixtureA.IsSensor();
			var e = this.m_fixtureB.IsSensor();
			var f = d || e;
			var g = this.m_fixtureA.GetBody();
			var h = this.m_fixtureB.GetBody();
			var i = g.GetTransform();
			var j = h.GetTransform();
			if (f) {
				var k = this.m_fixtureA.GetShape();
				var l = this.m_fixtureB.GetShape();
				b = pc(k, this.m_indexA, l, this.m_indexB, i, j);
				this.m_manifold.pointCount = 0;
			} else {
				this.Evaluate(this.m_manifold, i, j);
				b = this.m_manifold.pointCount > 0;
				for (var m = 0; m < this.m_manifold.pointCount; ++m) {
					var n = this.m_manifold.points[m];
					n.normalImpulse = 0;
					n.tangentImpulse = 0;
					var o = n.id;
					for (var p = 0; p < bd.m_local_tempManifold.pointCount; ++p) {
						var q = bd.m_local_tempManifold.points[p];
						if (q.id.Get() == o.Get()) {
							n.normalImpulse = q.normalImpulse;
							n.tangentImpulse = q.tangentImpulse;
							break;
						}
					}
				}
				if (b != c) {
					g.SetAwake(true);
					h.SetAwake(true);
				}
			}
			if (b) this.m_flags |= bd.e_touchingFlag; else this.m_flags &= ~bd.e_touchingFlag;
			if (false == c && true == b && a) a.BeginContact(this);
			if (true == c && false == b && a) a.EndContact(this);
			if (false == f && b && a) a.PreSolve(this, bd.m_local_tempManifold);
		}
	};
	bd.e_islandFlag = 1;
	bd.e_touchingFlag = 2;
	bd.e_enabledFlag = 4;
	bd.e_filterFlag = 8;
	bd.e_bulletHitFlag = 16;
	bd.e_toiFlag = 32;
	function cd() {
		this.parent.call(this);
	}
	cd.prototype = {
		Evaluate: function (a, b, c) {
			dc(a, this.m_fixtureA.GetShape(), b, this.m_fixtureB.GetShape(), c);
		},
		Create: function (a, b, c, d) {
			this.parent.prototype.Create.call(this, a, 0, c, 0);
		}
	};
	cd._extend(bd);
	var dd = new Fb();
	function ed() {
		this.parent.call(this);
	}
	ed.prototype = {
		Evaluate: function (a, b, c) {
			var d = this.m_fixtureA.GetShape();
			d.GetChildEdge(dd, this.m_indexA);
			ic(a, dd, b, this.m_fixtureB.GetShape(), c);
		},
		Create: function (a, b, c, d) {
			this.parent.prototype.Create.call(this, a, b, c, d);
		}
	};
	ed._extend(bd);
	function fd() {
		this.parent.call(this);
	}
	fd.prototype = {
		Evaluate: function (a, b, c) {
			var d = this.m_fixtureA.GetShape();
			d.GetChildEdge(dd, this.m_indexA);
			nc(a, dd, b, this.m_fixtureB.GetShape(), c);
		},
		Create: function (a, b, c, d) {
			this.parent.prototype.Create.call(this, a, b, c, d);
		}
	};
	fd.Create = function (a, b, c, d) {
		return new fd(a, b, c, d);
	};
	fd._extend(bd);
	function gd() {
		this.parent.call(this);
	}
	gd.prototype = {
		Evaluate: function (a, b, c) {
			ic(a, this.m_fixtureA.GetShape(), b, this.m_fixtureB.GetShape(), c);
		},
		Create: function (a, b, c, d) {
			this.parent.prototype.Create.call(this, a, 0, c, 0);
		}
	};
	gd.Create = function (a, b, c, d) {
		return new gd(a, c);
	};
	gd._extend(bd);
	function hd() {
		this.parent.call(this);
	}
	hd.prototype = {
		Evaluate: function (a, b, c) {
			nc(a, this.m_fixtureA.GetShape(), b, this.m_fixtureB.GetShape(), c);
		},
		Create: function (a, b, c, d) {
			this.parent.prototype.Create.call(this, a, 0, c, 0);
		}
	};
	hd.Create = function (a, b, c, d) {
		return new hd(a, c);
	};
	hd._extend(bd);
	function id() {
		this.parent.call(this);
	}
	id.prototype = {
		Evaluate: function (a, b, c) {
			ec(a, this.m_fixtureA.GetShape(), b, this.m_fixtureB.GetShape(), c);
		},
		Create: function (a, b, c, d) {
			this.parent.prototype.Create.call(this, a, 0, c, 0);
		}
	};
	id.Create = function (a, b, c, d) {
		return new id(a, c);
	};
	id._extend(bd);
	function jd() {
		this.parent.call(this);
	}
	jd.prototype = {
		Evaluate: function (a, b, c) {
			hc(a, this.m_fixtureA.GetShape(), b, this.m_fixtureB.GetShape(), c);
		},
		Create: function (a, b, c, d) {
			this.parent.prototype.Create.call(this, a, 0, c, 0);
		}
	};
	jd.Create = function (a, b, c, d) {
		return new jd(a, c);
	};
	jd._extend(bd);
	bd.AddType = function (a, b, c) {
		if (!bd.s_registers[b]) bd.s_registers[b] = [];
		bd.s_registers[b][c] = new _c();
		bd.s_registers[b][c].fcn = a;
		bd.s_registers[b][c].primary = true;
		if (b != c) {
			if (!bd.s_registers[c]) bd.s_registers[c] = [];
			bd.s_registers[c][b] = new _c();
			bd.s_registers[c][b].fcn = a;
			bd.s_registers[c][b].primary = false;
		}
		a.garbage = [];
		a.alloc = 2;
	};
	bd.InitializeRegisters = function () {
		bd.AddType(cd, Db.e_circle, Db.e_circle);
		bd.AddType(id, Db.e_polygon, Db.e_circle);
		bd.AddType(jd, Db.e_polygon, Db.e_polygon);
		bd.AddType(gd, Db.e_edge, Db.e_circle);
		bd.AddType(hd, Db.e_edge, Db.e_polygon);
		bd.AddType(ed, Db.e_chain, Db.e_circle);
		bd.AddType(fd, Db.e_chain, Db.e_polygon);
	};
	bd.RetrieveGarbage = function (a) {
		var b;
		if (b = a.garbage.pop()) return b;
		for (var c = 0; c < a.alloc - 1; ++c) a.garbage.push(new a());
		a.alloc += 32;
		return new a();
	};
	bd.Create = function (a, b, c, d) {
		if (false == bd.s_initialized) {
			bd.InitializeRegisters();
			bd.s_initialized = true;
		}
		var e = a.GetType();
		var f = c.GetType();
		var g = bd.s_registers[e][f].fcn;
		if (g) {
			var h = bd.RetrieveGarbage(g);
			if (bd.s_registers[e][f].primary) h.Create(a, b, c, d); else h.Create(c, d, a, b);
			return h;
		}
		return null;
	};
	bd.Destroy = function (a) {
		var b = a.m_fixtureA;
		var c = a.m_fixtureB;
		if (a.m_manifold.pointCount > 0 && false == b.IsSensor() && false == c.IsSensor()) {
			b.GetBody().SetAwake(true);
			c.GetBody().SetAwake(true);
		}
		var d = b.GetType();
		var e = c.GetType();
		bd.s_registers[d][e].fcn.garbage.push(a);
	};
	bd.s_registers = [];
	bd.s_initialized = false;
	var kd = new Ic();
	var ld = new Kc();
	function md() {
		this.m_broadPhase = new Kb();
		this.m_contactList = null;
		this.m_contactCount = 0;
		this.m_contactFilter = kd;
		this.m_contactListener = ld;
	}
	md.prototype = {
		AddPair: function (a, b) {
			var c = a;
			var d = b;
			var e = c.fixture;
			var f = d.fixture;
			var g = c.childIndex;
			var h = d.childIndex;
			var i = e.GetBody();
			var j = f.GetBody();
			if (i == j) return;
			var k = j.GetContactList();
			while (k) {
				if (k.other == i) {
					var l = k.contact.GetFixtureA();
					var m = k.contact.GetFixtureB();
					var n = k.contact.GetChildIndexA();
					var o = k.contact.GetChildIndexB();
					if (l == e && m == f && n == g && o == h) return;
					if (l == f && m == e && n == h && o == g) return;
				}
				k = k.next;
			}
			if (false == j.ShouldCollide(i)) return;
			if (this.m_contactFilter && false == this.m_contactFilter.ShouldCollide(e, f)) return;
			var p = bd.Create(e, g, f, h);
			if (null == p) return;
			e = p.GetFixtureA();
			f = p.GetFixtureB();
			g = p.GetChildIndexA();
			h = p.GetChildIndexB();
			i = e.GetBody();
			j = f.GetBody();
			p.m_prev = null;
			p.m_next = this.m_contactList;
			if (null != this.m_contactList) this.m_contactList.m_prev = p;
			this.m_contactList = p;
			p.m_nodeA.contact = p;
			p.m_nodeA.other = j;
			p.m_nodeA.prev = null;
			p.m_nodeA.next = i.m_contactList;
			if (null != i.m_contactList) i.m_contactList.prev = p.m_nodeA;
			i.m_contactList = p.m_nodeA;
			p.m_nodeB.contact = p;
			p.m_nodeB.other = i;
			p.m_nodeB.prev = null;
			p.m_nodeB.next = j.m_contactList;
			if (null != j.m_contactList) j.m_contactList.prev = p.m_nodeB;
			j.m_contactList = p.m_nodeB;
			if (false == e.IsSensor() && false == f.IsSensor()) {
				i.SetAwake(true);
				j.SetAwake(true);
			}
			++this.m_contactCount;
		},
		FindNewContacts: function () {
			this.m_broadPhase.UpdatePairs(this);
		},
		Destroy: function (a) {
			var b = a.GetFixtureA();
			var c = a.GetFixtureB();
			var d = b.GetBody();
			var e = c.GetBody();
			if (this.m_contactListener && a.IsTouching()) this.m_contactListener.EndContact(a);
			if (a.m_prev) a.m_prev.m_next = a.m_next;
			if (a.m_next) a.m_next.m_prev = a.m_prev;
			if (a == this.m_contactList) this.m_contactList = a.m_next;
			if (a.m_nodeA.prev) a.m_nodeA.prev.next = a.m_nodeA.next;
			if (a.m_nodeA.next) a.m_nodeA.next.prev = a.m_nodeA.prev;
			if (a.m_nodeA == d.m_contactList) d.m_contactList = a.m_nodeA.next;
			if (a.m_nodeB.prev) a.m_nodeB.prev.next = a.m_nodeB.next;
			if (a.m_nodeB.next) a.m_nodeB.next.prev = a.m_nodeB.prev;
			if (a.m_nodeB == e.m_contactList) e.m_contactList = a.m_nodeB.next;
			bd.Destroy(a);
			--this.m_contactCount;
		},
		Collide: function () {
			var a = this.m_contactList;
			while (a) {
				var b = a.GetFixtureA();
				var c = a.GetFixtureB();
				var d = a.GetChildIndexA();
				var e = a.GetChildIndexB();
				var f = b.GetBody();
				var g = c.GetBody();
				if (a.m_flags & bd.e_filterFlag) {
					if (false == g.ShouldCollide(f)) {
						var h = a;
						a = h.GetNext();
						this.Destroy(h);
						continue;
					}
					if (this.m_contactFilter && false == this.m_contactFilter.ShouldCollide(b, c)) {
						var h = a;
						a = h.GetNext();
						this.Destroy(h);
						continue;
					}
					a.m_flags &= ~bd.e_filterFlag;
				}
				var i = f.IsAwake() && f.m_type != Cc.b2_staticBody;
				var j = g.IsAwake() && g.m_type != Cc.b2_staticBody;
				if (false == i && false == j) {
					a = a.GetNext();
					continue;
				}
				var k = b.m_proxies[d].proxyId;
				var l = c.m_proxies[e].proxyId;
				var m = this.m_broadPhase.TestOverlap(k, l);
				if (false == m) {
					var h = a;
					a = h.GetNext();
					this.Destroy(h);
					continue;
				}
				a.Update(this.m_contactListener);
				a = a.GetNext();
			}
		}
	};
	function nd() {
		this.rA = new L();
		this.rB = new L();
		this.normalImpulse = 0;
		this.tangentImpulse = 0;
		this.normalMass = 0;
		this.tangentMass = 0;
		this.velocityBias = 0;
	}
	function od() {
		this.localPoints = new Array(e);
		this.localNormal = new L();
		this.localPoint = new L();
		this.indexA = 0;
		this.indexB = 0;
		this.invMassA = 0, this.invMassB = 0;
		this.localCenterA = new L(), this.localCenterB = new L();
		this.invIA = 0, this.invIB = 0;
		this.type = 0;
		this.radiusA = 0, this.radiusB = 0;
		this.pointCount = 0;
	}
	function pd() {
		this.points = new Array(e);
		for (var a = 0; a < this.points.length; ++a) this.points[a] = new nd();
		this.normal = new L();
		this.normalMass = new N();
		this.K = new N();
		this.indexA = 0;
		this.indexB = 0;
		this.invMassA = 0, this.invMassB = 0;
		this.invIA = 0, this.invIB = 0;
		this.friction = 0;
		this.restitution = 0;
		this.tangentSpeed = 0;
		this.pointCount = 0;
		this.contactIndex = 0;
	}
	function qd() {
		this.normal = new L();
		this.point = new L();
		this.separation = 0;
	}
	qd.prototype = {
		Initialize: function (a, b, c, d) {
			switch (a.type) {
				case Yb.e_circles:
					var e = b.q.c * a.localPoint.x - b.q.s * a.localPoint.y + b.p.x;
					var f = b.q.s * a.localPoint.x + b.q.c * a.localPoint.y + b.p.y;
					var g = c.q.c * a.localPoints[0].x - c.q.s * a.localPoints[0].y + c.p.x;
					var h = c.q.s * a.localPoints[0].x + c.q.c * a.localPoints[0].y + c.p.y;
					this.point.x = .5 * (e + g);
					this.point.y = .5 * (f + h);
					this.normal.x = g - e;
					this.normal.y = h - f;
					var i = this.normal.x;
					var j = this.normal.y;
					this.normal.Normalize();
					this.separation = i * this.normal.x + j * this.normal.y - a.radiusA - a.radiusB;
					break;

				case Yb.e_faceA:
					this.normal.x = b.q.c * a.localNormal.x - b.q.s * a.localNormal.y;
					this.normal.y = b.q.s * a.localNormal.x + b.q.c * a.localNormal.y;
					var k = b.q.c * a.localPoint.x - b.q.s * a.localPoint.y + b.p.x;
					var l = b.q.s * a.localPoint.x + b.q.c * a.localPoint.y + b.p.y;
					var m = c.q.c * a.localPoints[d].x - c.q.s * a.localPoints[d].y + c.p.x;
					var n = c.q.s * a.localPoints[d].x + c.q.c * a.localPoints[d].y + c.p.y;
					this.separation = (m - k) * this.normal.x + (n - l) * this.normal.y - a.radiusA - a.radiusB;
					this.point.x = m;
					this.point.y = n;
					break;

				case Yb.e_faceB:
					this.normal.x = c.q.c * a.localNormal.x - c.q.s * a.localNormal.y;
					this.normal.y = c.q.s * a.localNormal.x + c.q.c * a.localNormal.y;
					var k = c.q.c * a.localPoint.x - c.q.s * a.localPoint.y + c.p.x;
					var l = c.q.s * a.localPoint.x + c.q.c * a.localPoint.y + c.p.y;
					var m = b.q.c * a.localPoints[d].x - b.q.s * a.localPoints[d].y + b.p.x;
					var n = b.q.s * a.localPoints[d].x + b.q.c * a.localPoints[d].y + b.p.y;
					this.separation = (m - k) * this.normal.x + (n - l) * this.normal.y - a.radiusA - a.radiusB;
					this.point.x = m;
					this.point.y = n;
					this.normal.x = -this.normal.x;
					this.normal.y = -this.normal.y;
			}
		}
	};
	function rd() {
		this.step = new Nc();
		this.contacts = null;
		this.count = 0;
		this.positions = null;
		this.velocities = null;
	}
	function sd() {
		this.m_positionConstraints = [];
		this.m_velocityConstraints = [];
	}
	sd.cs_xfA = new Q();
	sd.cs_xfB = new Q();
	sd.temp_solver_manifold = new qd();
	sd.prototype = {
		Init: function (a) {
			this.m_step = a.step;
			this.m_count = a.count;
			this.m_positionConstraints.length = this.m_count;
			this.m_velocityConstraints.length = this.m_count;
			this.m_positions = a.positions;
			this.m_velocities = a.velocities;
			this.m_contacts = a.contacts;
			for (var b = 0; b < this.m_count; ++b) {
				var c = this.m_contacts[b];
				var d = c.m_fixtureA;
				var e = c.m_fixtureB;
				var f = d.GetShape();
				var g = e.GetShape();
				var h = f.m_radius;
				var i = g.m_radius;
				var j = d.GetBody();
				var k = e.GetBody();
				var l = c.GetManifold();
				var m = l.pointCount;
				var n = this.m_velocityConstraints[b] || new pd();
				n.friction = c.m_friction;
				n.restitution = c.m_restitution;
				n.tangentSpeed = c.m_tangentSpeed;
				n.indexA = j.m_islandIndex;
				n.indexB = k.m_islandIndex;
				n.invMassA = j.m_invMass;
				n.invMassB = k.m_invMass;
				n.invIA = j.m_invI;
				n.invIB = k.m_invI;
				n.contactIndex = b;
				n.pointCount = m;
				n.K.SetZero();
				n.normalMass.SetZero();
				this.m_velocityConstraints[b] = n;
				var o = this.m_positionConstraints[b] || new od();
				o.indexA = j.m_islandIndex;
				o.indexB = k.m_islandIndex;
				o.invMassA = j.m_invMass;
				o.invMassB = k.m_invMass;
				o.localCenterA.x = j.m_sweep.localCenter.x;
				o.localCenterA.y = j.m_sweep.localCenter.y;
				o.localCenterB.x = k.m_sweep.localCenter.x;
				o.localCenterB.y = k.m_sweep.localCenter.y;
				o.invIA = j.m_invI;
				o.invIB = k.m_invI;
				o.localNormal.x = l.localNormal.x;
				o.localNormal.y = l.localNormal.y;
				o.localPoint.x = l.localPoint.x;
				o.localPoint.y = l.localPoint.y;
				o.pointCount = m;
				o.radiusA = h;
				o.radiusB = i;
				o.type = l.type;
				this.m_positionConstraints[b] = o;
				for (var p = 0; p < m; ++p) {
					var q = l.points[p];
					var r = n.points[p];
					if (this.m_step.warmStarting) {
						r.normalImpulse = this.m_step.dtRatio * q.normalImpulse;
						r.tangentImpulse = this.m_step.dtRatio * q.tangentImpulse;
					} else {
						r.normalImpulse = 0;
						r.tangentImpulse = 0;
					}
					r.rA.SetZero();
					r.rB.SetZero();
					r.normalMass = 0;
					r.tangentMass = 0;
					r.velocityBias = 0;
					o.localPoints[p] = q.localPoint;
				}
			}
		},
		InitializeVelocityConstraints: function () {
			for (var a = 0; a < this.m_count; ++a) {
				var b = this.m_velocityConstraints[a];
				var c = this.m_positionConstraints[a];
				var d = c.radiusA;
				var e = c.radiusB;
				var f = this.m_contacts[b.contactIndex].GetManifold();
				var g = b.indexA;
				var h = b.indexB;
				var i = b.invMassA;
				var j = b.invMassB;
				var k = b.invIA;
				var l = b.invIB;
				var m = c.localCenterA;
				var o = c.localCenterB;
				var p = this.m_positions[g].c;
				var q = this.m_positions[g].a;
				var r = this.m_velocities[g].v;
				var s = this.m_velocities[g].w;
				var t = this.m_positions[h].c;
				var u = this.m_positions[h].a;
				var v = this.m_velocities[h].v;
				var w = this.m_velocities[h].w;
				sd.cs_xfA.q.Set(q);
				sd.cs_xfB.q.Set(u);
				sd.cs_xfA.p.x = p.x - (sd.cs_xfA.q.c * m.x - sd.cs_xfA.q.s * m.y);
				sd.cs_xfA.p.y = p.y - (sd.cs_xfA.q.s * m.x + sd.cs_xfA.q.c * m.y);
				sd.cs_xfB.p.x = t.x - (sd.cs_xfB.q.c * o.x - sd.cs_xfB.q.s * o.y);
				sd.cs_xfB.p.y = t.y - (sd.cs_xfB.q.s * o.x + sd.cs_xfB.q.c * o.y);
				var x = new Zb();
				x.Initialize(f, sd.cs_xfA, d, sd.cs_xfB, e);
				b.normal.x = x.normal.x;
				b.normal.y = x.normal.y;
				var y = b.pointCount;
				for (var z = 0; z < y; ++z) {
					var A = b.points[z];
					A.rA.x = x.points[z].x - p.x;
					A.rA.y = x.points[z].y - p.y;
					A.rB.x = x.points[z].x - t.x;
					A.rB.y = x.points[z].y - t.y;
					var B = A.rA.x * b.normal.y - A.rA.y * b.normal.x;
					var C = A.rB.x * b.normal.y - A.rB.y * b.normal.x;
					var D = i + j + k * B * B + l * C * C;
					A.normalMass = D > 0 ? 1 / D : 0;
					var E = 1 * b.normal.y;
					var F = -1 * b.normal.x;
					var G = A.rA.x * F - A.rA.y * E;
					var H = A.rB.x * F - A.rB.y * E;
					var I = i + j + k * G * G + l * H * H;
					A.tangentMass = I > 0 ? 1 / I : 0;
					A.velocityBias = 0;
					var J = b.normal.x * (v.x + -w * A.rB.y - r.x - -s * A.rA.y) + b.normal.y * (v.y + w * A.rB.x - r.y - s * A.rA.x);
					if (J < -n) A.velocityBias = -b.restitution * J;
				}
				if (2 == b.pointCount) {
					var K = b.points[0];
					var L = b.points[1];
					var M = K.rA.x * b.normal.y - K.rA.y * b.normal.x;
					var N = K.rB.x * b.normal.y - K.rB.y * b.normal.x;
					var O = L.rA.x * b.normal.y - L.rA.y * b.normal.x;
					var P = L.rB.x * b.normal.y - L.rB.y * b.normal.x;
					var Q = i + j + k * M * M + l * N * N;
					var R = i + j + k * O * O + l * P * P;
					var S = i + j + k * M * O + l * N * P;
					var T = 1e3;
					if (Q * Q < T * (Q * R - S * S)) {
						b.K.ex.x = Q;
						b.K.ex.y = S;
						b.K.ey.x = S;
						b.K.ey.y = R;
						b.normalMass.Assign(b.K.GetInverse());
					} else b.pointCount = 1;
				}
			}
		},
		WarmStart: function () {
			for (var a = 0; a < this.m_count; ++a) {
				var b = this.m_velocityConstraints[a];
				var c = b.indexA;
				var d = b.indexB;
				var e = b.invMassA;
				var f = b.invIA;
				var g = b.invMassB;
				var h = b.invIB;
				var i = b.pointCount;
				var j = this.m_velocities[c].v;
				var k = this.m_velocities[c].w;
				var l = this.m_velocities[d].v;
				var m = this.m_velocities[d].w;
				var n = b.normal;
				var o = 1 * n.y;
				var p = -1 * n.x;
				for (var q = 0; q < i; ++q) {
					var r = b.points[q];
					var s = r.normalImpulse * n.x + r.tangentImpulse * o;
					var t = r.normalImpulse * n.y + r.tangentImpulse * p;
					k -= f * (r.rA.x * t - r.rA.y * s);
					j.x -= e * s;
					j.y -= e * t;
					m += h * (r.rB.x * t - r.rB.y * s);
					l.x += g * s;
					l.y += g * t;
				}
				this.m_velocities[c].w = k;
				this.m_velocities[d].w = m;
			}
		},
		SolveVelocityConstraints: function () {
			for (var a = 0; a < this.m_count; ++a) {
				var b = this.m_velocityConstraints[a];
				var c = b.indexA;
				var d = b.indexB;
				var e = b.invMassA;
				var f = b.invIA;
				var g = b.invMassB;
				var h = b.invIB;
				var i = b.pointCount;
				var j = this.m_velocities[c].v;
				var k = this.m_velocities[c].w;
				var l = this.m_velocities[d].v;
				var m = this.m_velocities[d].w;
				var n = b.normal;
				var o = 1 * n.y;
				var p = -1 * n.x;
				var q = b.friction;
				for (var r = 0; r < i; ++r) {
					var s = b.points[r];
					var t = l.x + -m * s.rB.y - j.x - -k * s.rA.y;
					var u = l.y + m * s.rB.x - j.y - k * s.rA.x;
					var v = t * o + u * p - b.tangentSpeed;
					var w = s.tangentMass * -v;
					var x = q * s.normalImpulse;
					var y = tb(s.tangentImpulse + w, -x, x);
					w = y - s.tangentImpulse;
					s.tangentImpulse = y;
					var z = w * o;
					var A = w * p;
					j.x -= e * z;
					j.y -= e * A;
					k -= f * (s.rA.x * A - s.rA.y * z);
					l.x += g * z;
					l.y += g * A;
					m += h * (s.rB.x * A - s.rB.y * z);
				}
				if (1 == b.pointCount) {
					s = b.points[0];
					t = l.x + -m * s.rB.y - j.x - -k * s.rA.y;
					u = l.y + m * s.rB.x - j.y - k * s.rA.x;
					var B = t * n.x + u * n.y;
					var w = -s.normalMass * (B - s.velocityBias);
					var y = rb(s.normalImpulse + w, 0);
					w = y - s.normalImpulse;
					s.normalImpulse = y;
					z = w * n.x;
					A = w * n.y;
					j.x -= e * z;
					j.y -= e * A;
					k -= f * (s.rA.x * A - s.rA.y * z);
					l.x += g * z;
					l.y += g * A;
					m += h * (s.rB.x * A - s.rB.y * z);
				} else {
					var C = b.points[0];
					var D = b.points[1];
					var E = C.normalImpulse;
					var F = D.normalImpulse;
					var G = l.x + -m * C.rB.y - j.x - -k * C.rA.y;
					var H = l.y + m * C.rB.x - j.y - k * C.rA.x;
					var I = l.x + -m * D.rB.y - j.x - -k * D.rA.y;
					var J = l.y + m * D.rB.x - j.y - k * D.rA.x;
					var K = G * n.x + H * n.y;
					var L = I * n.x + J * n.y;
					var M = K - C.velocityBias;
					var N = L - D.velocityBias;
					M -= b.K.ex.x * E + b.K.ey.x * F;
					N -= b.K.ex.y * E + b.K.ey.y * F;
					for (; ;) {
						var O = -(b.normalMass.ex.x * M + b.normalMass.ey.x * N);
						var P = -(b.normalMass.ex.y * M + b.normalMass.ey.y * N);
						if (O >= 0 && P >= 0) {
							var Q = O - E;
							var R = P - F;
							var S = Q * n.x;
							var T = Q * n.y;
							var U = R * n.x;
							var V = R * n.y;
							j.x -= e * (S + U);
							j.y -= e * (T + V);
							k -= f * (C.rA.x * T - C.rA.y * S + (D.rA.x * V - D.rA.y * U));
							l.x += g * (S + U);
							l.y += g * (T + V);
							m += h * (C.rB.x * T - C.rB.y * S + (D.rB.x * V - D.rB.y * U));
							C.normalImpulse = O;
							D.normalImpulse = P;
							break;
						}
						O = -C.normalMass * M;
						P = 0;
						K = 0;
						L = b.K.ex.y * O + N;
						if (O >= 0 && L >= 0) {
							Q = O - E;
							R = P - F;
							S = Q * n.x;
							T = Q * n.y;
							U = R * n.x;
							V = R * n.y;
							j.x -= e * (S + U);
							j.y -= e * (T + V);
							k -= f * (C.rA.x * T - C.rA.y * S + (D.rA.x * V - D.rA.y * U));
							l.x += g * (S + U);
							l.y += g * (T + V);
							m += h * (C.rB.x * T - C.rB.y * S + (D.rB.x * V - D.rB.y * U));
							C.normalImpulse = O;
							D.normalImpulse = P;
							break;
						}
						O = 0;
						P = -D.normalMass * N;
						K = b.K.ey.x * P + M;
						L = 0;
						if (P >= 0 && K >= 0) {
							Q = O - E;
							R = P - F;
							S = Q * n.x;
							T = Q * n.y;
							U = R * n.x;
							V = R * n.y;
							j.x -= e * (S + U);
							j.y -= e * (T + V);
							k -= f * (C.rA.x * T - C.rA.y * S + (D.rA.x * V - D.rA.y * U));
							l.x += g * (S + U);
							l.y += g * (T + V);
							m += h * (C.rB.x * T - C.rB.y * S + (D.rB.x * V - D.rB.y * U));
							C.normalImpulse = O;
							D.normalImpulse = P;
							break;
						}
						O = 0;
						P = 0;
						K = M;
						L = N;
						if (K >= 0 && L >= 0) {
							Q = O - E;
							R = P - F;
							S = Q * n.x;
							T = Q * n.y;
							U = R * n.x;
							V = R * n.y;
							j.x -= e * (S + U);
							j.y -= e * (T + V);
							k -= f * (C.rA.x * T - C.rA.y * S + (D.rA.x * V - D.rA.y * U));
							l.x += g * (S + U);
							l.y += g * (T + V);
							m += h * (C.rB.x * T - C.rB.y * S + (D.rB.x * V - D.rB.y * U));
							C.normalImpulse = O;
							D.normalImpulse = P;
							break;
						}
						break;
					}
				}
				this.m_velocities[c].w = k;
				this.m_velocities[d].w = m;
			}
		},
		StoreImpulses: function () {
			for (var a = 0; a < this.m_count; ++a) {
				var b = this.m_velocityConstraints[a];
				var c = this.m_contacts[b.contactIndex].GetManifold();
				for (var d = 0; d < b.pointCount; ++d) {
					c.points[d].normalImpulse = b.points[d].normalImpulse;
					c.points[d].tangentImpulse = b.points[d].tangentImpulse;
				}
			}
		},
		SolvePositionConstraints: function () {
			var a = 0;
			for (var b = 0; b < this.m_count; ++b) {
				var c = this.m_positionConstraints[b];
				var d = c.indexA;
				var e = c.indexB;
				var f = c.localCenterA;
				var g = c.invMassA;
				var h = c.invIA;
				var j = c.localCenterB;
				var k = c.invMassB;
				var l = c.invIB;
				var m = c.pointCount;
				var n = this.m_positions[d].c;
				var p = this.m_positions[d].a;
				var q = this.m_positions[e].c;
				var r = this.m_positions[e].a;
				for (var s = 0; s < m; ++s) {
					sd.cs_xfA.q.Set(p);
					sd.cs_xfB.q.Set(r);
					sd.cs_xfA.p.x = n.x - (sd.cs_xfA.q.c * f.x - sd.cs_xfA.q.s * f.y);
					sd.cs_xfA.p.y = n.y - (sd.cs_xfA.q.s * f.x + sd.cs_xfA.q.c * f.y);
					sd.cs_xfB.p.x = q.x - (sd.cs_xfB.q.c * j.x - sd.cs_xfB.q.s * j.y);
					sd.cs_xfB.p.y = q.y - (sd.cs_xfB.q.s * j.x + sd.cs_xfB.q.c * j.y);
					sd.temp_solver_manifold.Initialize(c, sd.cs_xfA, sd.cs_xfB, s);
					var t = sd.temp_solver_manifold.normal;
					var v = sd.temp_solver_manifold.point;
					var w = sd.temp_solver_manifold.separation;
					var x = v.x - n.x;
					var y = v.y - n.y;
					var z = v.x - q.x;
					var A = v.y - q.y;
					a = pb(a, w);
					var B = tb(u * (w + i), -o, 0);
					var C = x * t.y - y * t.x;
					var D = z * t.y - A * t.x;
					var E = g + k + h * C * C + l * D * D;
					var F = E > 0 ? -B / E : 0;
					var G = F * t.x;
					var H = F * t.y;
					n.x -= g * G;
					n.y -= g * H;
					p -= h * (x * H - y * G);
					q.x += k * G;
					q.y += k * H;
					r += l * (z * H - A * G);
				}
				this.m_positions[d].a = p;
				this.m_positions[e].a = r;
			}
			return a >= -3 * i;
		},
		SolveTOIPositionConstraints: function (a, b) {
			var c = 0;
			for (var d = 0; d < this.m_count; ++d) {
				var e = this.m_positionConstraints[d];
				var f = e.indexA;
				var g = e.indexB;
				var h = e.localCenterA;
				var j = e.localCenterB;
				var k = e.pointCount;
				var l = 0;
				var m = 0;
				if (f == a || f == b) {
					l = e.invMassA;
					m = e.invIA;
				}
				var n = 0;
				var p = 0;
				if (g == a || g == b) {
					n = e.invMassB;
					p = e.invIB;
				}
				var q = this.m_positions[f].c;
				var r = this.m_positions[f].a;
				var s = this.m_positions[g].c;
				var t = this.m_positions[g].a;
				for (var u = 0; u < k; ++u) {
					sd.cs_xfA.q.Set(r);
					sd.cs_xfB.q.Set(t);
					sd.cs_xfA.p.Assign(L.Subtract(q, gb(sd.cs_xfA.q, h)));
					sd.cs_xfB.p.Assign(L.Subtract(s, gb(sd.cs_xfB.q, j)));
					sd.temp_solver_manifold.Initialize(e, sd.cs_xfA, sd.cs_xfB, u);
					var w = sd.temp_solver_manifold.normal;
					var x = sd.temp_solver_manifold.point;
					var y = sd.temp_solver_manifold.separation;
					var z = L.Subtract(x, q);
					var A = L.Subtract(x, s);
					c = pb(c, y);
					var B = tb(v * (y + i), -o, 0);
					var C = T(z, w);
					var D = T(A, w);
					var E = l + n + m * C * C + p * D * D;
					var F = E > 0 ? -B / E : 0;
					var G = L.Multiply(F, w);
					q.Subtract(L.Multiply(l, G));
					r -= m * T(z, G);
					s.Add(L.Multiply(n, G));
					t += p * T(A, G);
				}
				this.m_positions[f].a = r;
				this.m_positions[g].a = t;
			}
			return c >= -1.5 * i;
		}
	};
	function td() {
		this.m_bodies = [];
		this.m_contacts = [];
		this.m_joints = [];
		this.m_velocities = [];
		this.m_positions = [];
	}
	var ud = a.create("solve initialization", "solve");
	var vd = a.create("warm starting", "solve initialization");
	var wd = a.create("solve velocities", "solve");
	var xd = a.create("solve positions", "solve");
	td._solverData = new Qc();
	td._solverDef = new rd();
	td._solver = new sd();
	td.prototype = {
		Clear: function () {
			this.m_bodyCount = 0;
			this.m_contactCount = 0;
			this.m_jointCount = 0;
		},
		Initialize: function (a, b, c, d) {
			this.m_listener = d;
			this.m_bodyCapacity = a;
			this.m_contactCapacity = b;
			this.m_jointCapacity = c;
			this.m_bodyCount = 0;
			this.m_contactCount = 0;
			this.m_jointCount = 0;
			this.m_bodies.length = a;
			this.m_contacts.length = b;
			this.m_joints.length = c;
			this.m_velocities.length = a;
			this.m_positions.length = a;
		},
		Solve: function (a, c, d) {
			ud.start();
			var e = a.dt;
			for (var f = 0; f < this.m_bodyCount; ++f) {
				var g = this.m_bodies[f];
				this.m_positions[f].c.Assign(g.m_sweep.c);
				var h = g.m_sweep.a;
				this.m_velocities[f].v.Assign(g.m_linearVelocity);
				var i = g.m_angularVelocity;
				g.m_sweep.c0.Assign(g.m_sweep.c);
				g.m_sweep.a0 = g.m_sweep.a;
				if (g.m_type == Cc.b2_dynamicBody) {
					this.m_velocities[f].v.x += e * (g.m_gravityScale * c.x + g.m_invMass * g.m_force.x);
					this.m_velocities[f].v.y += e * (g.m_gravityScale * c.y + g.m_invMass * g.m_force.y);
					i += e * g.m_invI * g.m_torque;
					this.m_velocities[f].v.x *= 1 / (1 + e * g.m_linearDamping);
					this.m_velocities[f].v.y *= 1 / (1 + e * g.m_linearDamping);
					i *= 1 / (1 + e * g.m_angularDamping);
				}
				this.m_positions[f].a = h;
				this.m_velocities[f].w = i;
			}
			td._solverData.step = a;
			td._solverData.positions = this.m_positions;
			td._solverData.velocities = this.m_velocities;
			td._solverDef.step = a;
			td._solverDef.contacts = this.m_contacts;
			td._solverDef.count = this.m_contactCount;
			td._solverDef.positions = this.m_positions;
			td._solverDef.velocities = this.m_velocities;
			td._solverDef.allocator = this.m_allocator;
			td._solver.Init(td._solverDef);
			td._solver.InitializeVelocityConstraints();
			if (a.warmStarting) {
				vd.start();
				td._solver.WarmStart();
				vd.stop();
			}
			for (var f = 0; f < this.m_jointCount; ++f) this.m_joints[f].InitVelocityConstraints(td._solverData);
			ud.stop();
			wd.start();
			for (var f = 0; f < a.velocityIterations; ++f) {
				for (var j = 0; j < this.m_jointCount; ++j) this.m_joints[j].SolveVelocityConstraints(td._solverData);
				td._solver.SolveVelocityConstraints();
			}
			td._solver.StoreImpulses();
			wd.stop();
			xd.start();
			for (var f = 0; f < this.m_bodyCount; ++f) {
				var k = this.m_positions[f].c;
				var h = this.m_positions[f].a;
				var l = this.m_velocities[f].v;
				var i = this.m_velocities[f].w;
				var m = e * l.x;
				var n = e * l.y;
				var o = m * m + n * n;
				if (o > r) {
					var p = q / I(o);
					l.x *= p;
					l.y *= p;
				}
				var u = e * i;
				if (u * u > t) {
					var p = s / mb(u);
					i *= p;
				}
				k.x += e * l.x;
				k.y += e * l.y;
				h += e * i;
				this.m_positions[f].a = h;
				this.m_velocities[f].w = i;
			}
			var v = false;
			for (var f = 0; f < a.positionIterations; ++f) {
				var z = td._solver.SolvePositionConstraints();
				var A = true;
				for (var j = 0; j < this.m_jointCount; ++j) {
					var B = this.m_joints[j].SolvePositionConstraints(td._solverData);
					A = A && B;
				}
				if (z && A) {
					v = true;
					break;
				}
			}
			for (var f = 0; f < this.m_bodyCount; ++f) {
				var C = this.m_bodies[f];
				C.m_sweep.c.Assign(this.m_positions[f].c);
				C.m_sweep.a = this.m_positions[f].a;
				C.m_linearVelocity.Assign(this.m_velocities[f].v);
				C.m_angularVelocity = this.m_velocities[f].w;
				C.SynchronizeTransform();
			}
			xd.stop();
			this.Report(td._solver.m_velocityConstraints);
			if (d) {
				var D = b;
				var E = x * x;
				var F = y * y;
				for (var f = 0; f < this.m_bodyCount; ++f) {
					var g = this.m_bodies[f];
					if (g.GetType() == Cc.b2_staticBody) continue;
					if (0 == (g.m_flags & Cc.e_autoSleepFlag) || g.m_angularVelocity * g.m_angularVelocity > F || S(g.m_linearVelocity, g.m_linearVelocity) > E) {
						g.m_sleepTime = 0;
						D = 0;
					} else {
						g.m_sleepTime += e;
						D = pb(D, g.m_sleepTime);
					}
				}
				if (D >= w && v) for (var f = 0; f < this.m_bodyCount; ++f) {
					var g = this.m_bodies[f];
					g.SetAwake(false);
				}
			}
		},
		SolveTOI: function (a, b, c) {
			for (var d = 0; d < this.m_bodyCount; ++d) {
				var e = this.m_bodies[d];
				this.m_positions[d].c.Assign(e.m_sweep.c);
				this.m_positions[d].a = e.m_sweep.a;
				this.m_velocities[d].v.Assign(e.m_linearVelocity);
				this.m_velocities[d].w = e.m_angularVelocity;
			}
			td._solverDef.contacts = this.m_contacts;
			td._solverDef.count = this.m_contactCount;
			td._solverDef.step = a;
			td._solverDef.positions = this.m_positions;
			td._solverDef.velocities = this.m_velocities;
			td._solver.Init(td._solverDef);
			for (var d = 0; d < a.positionIterations; ++d) {
				var f = td._solver.SolveTOIPositionConstraints(b, c);
				if (f) break;
			}
			this.m_bodies[b].m_sweep.c0.Assign(this.m_positions[b].c);
			this.m_bodies[b].m_sweep.a0 = this.m_positions[b].a;
			this.m_bodies[c].m_sweep.c0.Assign(this.m_positions[c].c);
			this.m_bodies[c].m_sweep.a0 = this.m_positions[c].a;
			td._solver.InitializeVelocityConstraints();
			for (var d = 0; d < a.velocityIterations; ++d) td._solver.SolveVelocityConstraints();
			var g = a.dt;
			for (var d = 0; d < this.m_bodyCount; ++d) {
				var h = this.m_positions[d].c;
				var i = this.m_positions[d].a;
				var j = this.m_velocities[d].v;
				var k = this.m_velocities[d].w;
				var l = L.Multiply(g, j);
				if (S(l, l) > r) {
					var m = q / l.Length();
					j.Multiply(m);
				}
				var n = g * k;
				if (n * n > t) {
					var m = s / mb(n);
					k *= m;
				}
				h.Add(L.Multiply(g, j));
				i += g * k;
				this.m_positions[d].a = i;
				this.m_velocities[d].w = k;
				var o = this.m_bodies[d];
				o.m_sweep.c.Assign(h);
				o.m_sweep.a = i;
				o.m_linearVelocity.Assign(j);
				o.m_angularVelocity = k;
				o.SynchronizeTransform();
			}
			this.Report(td._solver.m_velocityConstraints);
		},
		AddBody: function (a) {
			a.m_islandIndex = this.m_bodyCount;
			this.m_bodies[this.m_bodyCount] = a;
			if (!this.m_positions[this.m_bodyCount]) {
				this.m_positions[this.m_bodyCount] = new Oc();
				this.m_velocities[this.m_bodyCount] = new Pc();
			}
			++this.m_bodyCount;
		},
		AddContact: function (a) {
			this.m_contacts[this.m_contactCount++] = a;
		},
		AddJoint: function (a) {
			this.m_joints[this.m_jointCount++] = a;
		},
		Report: function (a) {
			if (null == this.m_listener) return;
			for (var b = 0; b < this.m_contactCount; ++b) {
				var c = this.m_contacts[b];
				var d = a[b];
				var e = new Jc();
				e.count = d.pointCount;
				for (var f = 0; f < d.pointCount; ++f) {
					e.normalImpulses[f] = d.points[f].normalImpulse;
					e.tangentImpulses[f] = d.points[f].tangentImpulse;
				}
				this.m_listener.PostSolve(c, e);
			}
		}
	};
	function yd() {
		this.linear = new L();
		this.angularA = 0;
		this.angularB = 0;
	}
	function zd() {
		this.other = null;
		this.joint = null;
		this.prev = null;
		this.next = null;
	}
	function Ad() {
		this.type = Bd.e_unknownJoint;
		this.userData = null;
		this.bodyA = null;
		this.bodyB = null;
		this.collideConnected = false;
	}
	Ad.prototype = {
		_deserialize: function (a, b, c) {
			this.bodyA = b[a.bodyA];
			this.bodyB = b[a.bodyB];
			this.collideConnected = a.collideConnected;
		}
	};
	function Bd(a) {
		this.m_type = a.type;
		this.m_prev = null;
		this.m_next = null;
		this.m_bodyA = a.bodyA;
		this.m_bodyB = a.bodyB;
		this.m_index = 0;
		this.m_collideConnected = a.collideConnected;
		this.m_islandFlag = false;
		this.m_userData = a.userData;
		this.m_edgeA = new zd();
		this.m_edgeA.joint = null;
		this.m_edgeA.other = null;
		this.m_edgeA.prev = null;
		this.m_edgeA.next = null;
		this.m_edgeB = new zd();
		this.m_edgeB.joint = null;
		this.m_edgeB.other = null;
		this.m_edgeB.prev = null;
		this.m_edgeB.next = null;
	}
	Bd.prototype = {
		GetType: function () {
			return this.m_type;
		},
		GetBodyA: function () {
			return this.m_bodyA;
		},
		GetBodyB: function () {
			return this.m_bodyB;
		},
		GetAnchorA: function () { },
		GetAnchorB: function () { },
		GetReactionForce: function (a) { },
		GetReactionTorque: function (a) { },
		GetNext: function () {
			return this.m_next;
		},
		GetUserData: function () {
			return this.m_userData;
		},
		SetUserData: function (a) {
			this.m_userData = a;
		},
		IsActive: function () {
			return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
		},
		GetCollideConnected: function () {
			return this.m_collideConnected;
		},
		ShiftOrigin: function (a) { },
		InitVelocityConstraints: function (a) { },
		SolveVelocityConstraints: function (a) { },
		SolvePositionConstraints: function (a) { },
		_serialize: function (a) {
			var b = a || {};
			b.bodyA = null;
			b.bodyB = null;
			b.type = this.m_type;
			b.collideConnected = this.m_collideConnected;
			return b;
		}
	};
	Bd.e_inactiveLimit = 0;
	Bd.e_atLowerLimit = 1;
	Bd.e_atUpperLimit = 2;
	Bd.e_equalLimits = 3;
	Bd.e_unknownJoint = 0;
	Bd.e_revoluteJoint = 1;
	Bd.e_prismaticJoint = 2;
	Bd.e_distanceJoint = 3;
	Bd.e_pulleyJoint = 4;
	Bd.e_mouseJoint = 5;
	Bd.e_gearJoint = 6;
	Bd.e_wheelJoint = 7;
	Bd.e_weldJoint = 8;
	Bd.e_frictionJoint = 9;
	Bd.e_ropeJoint = 10;
	Bd.e_motorJoint = 11;
	Bd.Create = function (a) {
		var b = null;
		switch (a.type) {
			case Bd.e_distanceJoint:
				b = new Hd(a);
				break;

			case Bd.e_mouseJoint:
				b = new Fd(a);
				break;

			case Bd.e_prismaticJoint:
				b = new Jd(a);
				break;

			case Bd.e_revoluteJoint:
				b = new Dd(a);
				break;

			case Bd.e_pulleyJoint:
				b = new Wd(a);
				break;

			case Bd.e_gearJoint:
				b = new Rd(a);
				break;

			case Bd.e_wheelJoint:
				b = new Pd(a);
				break;

			case Bd.e_weldJoint:
				b = new Nd(a);
				break;

			case Bd.e_frictionJoint:
				b = new Ld(a);
				break;

			case Bd.e_ropeJoint:
				b = new Yd(a);
				break;

			case Bd.e_motorJoint:
				b = new Td(a);
		}
		return b;
	};
	Bd.Destroy = function (a) { };
	function Cd() {
		this.parent.call(this);
		this.type = Bd.e_revoluteJoint;
		this.localAnchorA = new L();
		this.localAnchorB = new L();
		this.referenceAngle = 0;
		this.lowerAngle = 0;
		this.upperAngle = 0;
		this.maxMotorTorque = 0;
		this.motorSpeed = 0;
		this.enableLimit = false;
		this.enableMotor = false;
		Object.seal(this);
	}
	Cd.prototype = {
		Initialize: function (a, b, c) {
			this.bodyA = a;
			this.bodyB = b;
			this.localAnchorA = this.bodyA.GetLocalPoint(c);
			this.localAnchorB = this.bodyB.GetLocalPoint(c);
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		},
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.localAnchorA._deserialize(a.localAnchorA);
			this.localAnchorB._deserialize(a.localAnchorB);
			this.referenceAngle = a.referenceAngle;
			this.lowerAngle = a.lowerAngle;
			this.upperAngle = a.upperAngle;
			this.maxMotorTorque = a.maxMotorTorque;
			this.motorSpeed = a.motorSpeed;
			this.enableLimit = a.enableLimit;
			this.enableMotor = a.enableMotor;
		}
	};
	Cd._extend(Ad);
	function Dd(a) {
		this.parent.call(this, a);
		this.m_localAnchorA = a.localAnchorA.Clone();
		this.m_localAnchorB = a.localAnchorB.Clone();
		this.m_referenceAngle = a.referenceAngle;
		this.m_impulse = new M();
		this.m_motorImpulse = 0;
		this.m_lowerAngle = a.lowerAngle;
		this.m_upperAngle = a.upperAngle;
		this.m_maxMotorTorque = a.maxMotorTorque;
		this.m_motorSpeed = a.motorSpeed;
		this.m_enableLimit = a.enableLimit;
		this.m_enableMotor = a.enableMotor;
		this.m_limitState = Bd.e_inactiveLimit;
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_rA = new L();
		this.m_rB = new L();
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
		this.m_mass = new O();
		this.m_motorMass = 0;
	}
	Dd.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetLocalAnchorA: function () {
			return this.m_localAnchorA;
		},
		GetLocalAnchorB: function () {
			return this.m_localAnchorB;
		},
		GetReferenceAngle: function () {
			return this.m_referenceAngle;
		},
		GetJointAngle: function () {
			var a = this.m_bodyA;
			var b = this.m_bodyB;
			return b.m_sweep.a - a.m_sweep.a - this.m_referenceAngle;
		},
		GetJointSpeed: function () {
			var a = this.m_bodyA;
			var b = this.m_bodyB;
			return b.m_angularVelocity - a.m_angularVelocity;
		},
		IsLimitEnabled: function () {
			return this.m_enableLimit;
		},
		EnableLimit: function (a) {
			if (a != this.m_enableLimit) {
				this.m_bodyA.SetAwake(true);
				this.m_bodyB.SetAwake(true);
				this.m_enableLimit = a;
				this.m_impulse.z = 0;
			}
		},
		GetLowerLimit: function () {
			return this.m_lowerAngle;
		},
		GetUpperLimit: function () {
			return this.m_upperAngle;
		},
		SetLimits: function (a, b) {
			if (a != this.m_lowerAngle || b != this.m_upperAngle) {
				this.m_bodyA.SetAwake(true);
				this.m_bodyB.SetAwake(true);
				this.m_impulse.z = 0;
				this.m_lowerAngle = a;
				this.m_upperAngle = b;
			}
		},
		IsMotorEnabled: function () {
			return this.m_enableMotor;
		},
		EnableMotor: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableMotor = a;
		},
		SetMotorSpeed: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = a;
		},
		GetMotorSpeed: function () {
			return this.m_motorSpeed;
		},
		SetMaxMotorTorque: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_maxMotorTorque = a;
		},
		GetMaxMotorTorque: function () {
			return this.m_maxMotorTorque;
		},
		GetReactionForce: function (a) {
			var b = new L(this.m_impulse.x, this.m_impulse.y);
			return L.Multiply(a, b);
		},
		GetReactionTorque: function (a) {
			return a * this.m_impulse.z;
		},
		GetMotorTorque: function (a) {
			return a * this.m_motorImpulse;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
			this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexA].a;
			var c = a.velocities[this.m_indexA].v.Clone();
			var d = a.velocities[this.m_indexA].w;
			var e = a.positions[this.m_indexB].a;
			var f = a.velocities[this.m_indexB].v.Clone();
			var g = a.velocities[this.m_indexB].w;
			var h = new P(b), i = new P(e);
			this.m_rA = gb(h, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			this.m_rB = gb(i, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var k = this.m_invMassA, l = this.m_invMassB;
			var m = this.m_invIA, n = this.m_invIB;
			var o = m + n == 0;
			this.m_mass.ex.x = k + l + this.m_rA.y * this.m_rA.y * m + this.m_rB.y * this.m_rB.y * n;
			this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * m - this.m_rB.y * this.m_rB.x * n;
			this.m_mass.ez.x = -this.m_rA.y * m - this.m_rB.y * n;
			this.m_mass.ex.y = this.m_mass.ey.x;
			this.m_mass.ey.y = k + l + this.m_rA.x * this.m_rA.x * m + this.m_rB.x * this.m_rB.x * n;
			this.m_mass.ez.y = this.m_rA.x * m + this.m_rB.x * n;
			this.m_mass.ex.z = this.m_mass.ez.x;
			this.m_mass.ey.z = this.m_mass.ez.y;
			this.m_mass.ez.z = m + n;
			this.m_motorMass = m + n;
			if (this.m_motorMass > 0) this.m_motorMass = 1 / this.m_motorMass;
			if (false == this.m_enableMotor || o) this.m_motorImpulse = 0;
			if (this.m_enableLimit && false == o) {
				var p = e - b - this.m_referenceAngle;
				if (mb(this.m_upperAngle - this.m_lowerAngle) < 2 * j) this.m_limitState = Bd.e_equalLimits; else if (p <= this.m_lowerAngle) {
					if (this.m_limitState != Bd.e_atLowerLimit) this.m_impulse.z = 0;
					this.m_limitState = Bd.e_atLowerLimit;
				} else if (p >= this.m_upperAngle) {
					if (this.m_limitState != Bd.e_atUpperLimit) this.m_impulse.z = 0;
					this.m_limitState = Bd.e_atUpperLimit;
				} else {
					this.m_limitState = Bd.e_inactiveLimit;
					this.m_impulse.z = 0;
				}
			} else this.m_limitState = Bd.e_inactiveLimit;
			if (a.step.warmStarting) {
				this.m_impulse.Multiply(a.step.dtRatio);
				this.m_motorImpulse *= a.step.dtRatio;
				var q = new L(this.m_impulse.x, this.m_impulse.y);
				c.Subtract(L.Multiply(k, q));
				d -= m * (T(this.m_rA, q) + this.m_motorImpulse + this.m_impulse.z);
				f.Add(L.Multiply(l, q));
				g += n * (T(this.m_rB, q) + this.m_motorImpulse + this.m_impulse.z);
			} else {
				this.m_impulse.SetZero();
				this.m_motorImpulse = 0;
			}
			a.velocities[this.m_indexA].v.Assign(c);
			a.velocities[this.m_indexA].w = d;
			a.velocities[this.m_indexB].v.Assign(f);
			a.velocities[this.m_indexB].w = g;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = this.m_invMassA, g = this.m_invMassB;
			var h = this.m_invIA, i = this.m_invIB;
			var j = h + i == 0;
			if (this.m_enableMotor && this.m_limitState != Bd.e_equalLimits && false == j) {
				var k = e - c - this.m_motorSpeed;
				var l = -this.m_motorMass * k;
				var m = this.m_motorImpulse;
				var n = a.step.dt * this.m_maxMotorTorque;
				this.m_motorImpulse = tb(this.m_motorImpulse + l, -n, n);
				l = this.m_motorImpulse - m;
				c -= h * l;
				e += i * l;
			}
			if (this.m_enableLimit && this.m_limitState != Bd.e_inactiveLimit && false == j) {
				var o = L.Subtract(L.Subtract(L.Add(d, V(e, this.m_rB)), b), V(c, this.m_rA));
				var p = e - c;
				var k = new M(o.x, o.y, p);
				var l = this.m_mass.Solve33(k).Negate();
				if (this.m_limitState == Bd.e_equalLimits) this.m_impulse.Add(l); else if (this.m_limitState == Bd.e_atLowerLimit) {
					var q = this.m_impulse.z + l.z;
					if (q < 0) {
						var r = L.Add(o.Negate(), L.Multiply(this.m_impulse.z, new L(this.m_mass.ez.x, this.m_mass.ez.y)));
						var s = this.m_mass.Solve22(r);
						l.x = s.x;
						l.y = s.y;
						l.z = -this.m_impulse.z;
						this.m_impulse.x += s.x;
						this.m_impulse.y += s.y;
						this.m_impulse.z = 0;
					} else this.m_impulse.Add(l);
				} else if (this.m_limitState == Bd.e_atUpperLimit) {
					var q = this.m_impulse.z + l.z;
					if (q > 0) {
						var r = L.Add(o.Negate(), L.Multiply(this.m_impulse.z, new L(this.m_mass.ez.x, this.m_mass.ez.y)));
						var s = this.m_mass.Solve22(r);
						l.x = s.x;
						l.y = s.y;
						l.z = -this.m_impulse.z;
						this.m_impulse.x += s.x;
						this.m_impulse.y += s.y;
						this.m_impulse.z = 0;
					} else this.m_impulse.Add(l);
				}
				var t = new L(l.x, l.y);
				b.Subtract(L.Multiply(f, t));
				c -= h * (T(this.m_rA, t) + l.z);
				d.Add(L.Multiply(g, t));
				e += i * (T(this.m_rB, t) + l.z);
			} else {
				var k = L.Subtract(L.Subtract(L.Add(d, V(e, this.m_rB)), b), V(c, this.m_rA));
				var l = this.m_mass.Solve22(k.Negate());
				this.m_impulse.x += l.x;
				this.m_impulse.y += l.y;
				b.Subtract(L.Multiply(f, l));
				c -= h * T(this.m_rA, l);
				d.Add(L.Multiply(g, l));
				e += i * T(this.m_rB, l);
			}
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
		},
		SolvePositionConstraints: function (a) {
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.positions[this.m_indexB].c.Clone();
			var e = a.positions[this.m_indexB].a;
			var f = new P(c), g = new P(e);
			var h = 0;
			var k = 0;
			var l = this.m_invIA + this.m_invIB == 0;
			if (this.m_enableLimit && this.m_limitState != Bd.e_inactiveLimit && false == l) {
				var m = e - c - this.m_referenceAngle;
				var n = 0;
				if (this.m_limitState == Bd.e_equalLimits) {
					var o = tb(m - this.m_lowerAngle, -p, p);
					n = -this.m_motorMass * o;
					h = mb(o);
				} else if (this.m_limitState == Bd.e_atLowerLimit) {
					var o = m - this.m_lowerAngle;
					h = -o;
					o = tb(o + j, -p, 0);
					n = -this.m_motorMass * o;
				} else if (this.m_limitState == Bd.e_atUpperLimit) {
					var o = m - this.m_upperAngle;
					h = o;
					o = tb(o - j, 0, p);
					n = -this.m_motorMass * o;
				}
				c -= this.m_invIA * n;
				e += this.m_invIB * n;
			}
			f.Set(c);
			g.Set(e);
			var q = gb(f, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var r = gb(g, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var o = L.Subtract(L.Subtract(L.Add(d, r), b), q);
			k = o.Length();
			var s = this.m_invMassA, t = this.m_invMassB;
			var u = this.m_invIA, v = this.m_invIB;
			var w = new N();
			w.ex.x = s + t + u * q.y * q.y + v * r.y * r.y;
			w.ex.y = -u * q.x * q.y - v * r.x * r.y;
			w.ey.x = w.ex.y;
			w.ey.y = s + t + u * q.x * q.x + v * r.x * r.x;
			var x = w.Solve(o).Negate();
			b.Subtract(L.Multiply(s, x));
			c -= u * T(q, x);
			d.Add(L.Multiply(t, x));
			e += v * T(r, x);
			a.positions[this.m_indexA].c.Assign(b);
			a.positions[this.m_indexA].a = c;
			a.positions[this.m_indexB].c.Assign(d);
			a.positions[this.m_indexB].a = e;
			return k <= i && h <= j;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.localAnchorA = this.m_localAnchorA._serialize();
			b.localAnchorB = this.m_localAnchorB._serialize();
			b.referenceAngle = this.m_referenceAngle;
			b.lowerAngle = this.m_lowerAngle;
			b.upperAngle = this.m_upperAngle;
			b.maxMotorTorque = this.m_maxMotorTorque;
			b.motorSpeed = this.m_motorSpeed;
			b.enableLimit = this.m_enableLimit;
			b.enableMotor = this.m_enableMotor;
			return b;
		}
	};
	Dd._extend(Bd);
	function Ed() {
		this.parent.call(this);
		this.type = Bd.e_mouseJoint;
		this.target = new L(0, 0);
		this.maxForce = 0;
		this.frequencyHz = 5;
		this.dampingRatio = .7;
		Object.seal(this);
	}
	Ed._extend(Ad);
	function Fd(a) {
		this.parent.call(this, a);
		this.m_targetA = a.target.Clone();
		this.m_localAnchorB = jb(this.m_bodyB.GetTransform(), this.m_targetA);
		this.m_maxForce = a.maxForce;
		this.m_impulse = new L();
		this.m_frequencyHz = a.frequencyHz;
		this.m_dampingRatio = a.dampingRatio;
		this.m_beta = 0;
		this.m_gamma = 0;
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_rB = new L();
		this.m_localCenterB = new L();
		this.m_invMassB = 0;
		this.m_invIB = 0;
		this.m_mass = new N();
		this.m_C = new L();
	}
	Fd.prototype = {
		GetAnchorA: function () {
			return this.m_targetA;
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			return L.Multiply(a, this.m_impulse);
		},
		GetReactionTorque: function (a) {
			return 0 * a;
		},
		SetTarget: function (a) {
			if (false == this.m_bodyB.IsAwake()) this.m_bodyB.SetAwake(true);
			this.m_targetA.Assign(a);
		},
		GetTarget: function () {
			return this.m_targetA;
		},
		SetMaxForce: function (a) {
			this.m_maxForce = a;
		},
		GetMaxForce: function () {
			return this.m_maxForce;
		},
		SetFrequency: function (a) {
			this.m_frequencyHz = a;
		},
		GetFrequency: function () {
			return this.m_frequencyHz;
		},
		SetDampingRatio: function (a) {
			this.m_dampingRatio = a;
		},
		GetDampingRatio: function () {
			return this.m_dampingRatio;
		},
		ShiftOrigin: function (a) {
			this.m_targetA.Subtract(a);
		},
		InitVelocityConstraints: function (a) {
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexB].c.Clone();
			var c = a.positions[this.m_indexB].a;
			var e = a.velocities[this.m_indexB].v.Clone();
			var f = a.velocities[this.m_indexB].w;
			var g = new P(c);
			var h = this.m_bodyB.GetMass();
			var i = 2 * d * this.m_frequencyHz;
			var j = 2 * h * this.m_dampingRatio * i;
			var k = h * i * i;
			var l = a.step.dt;
			this.m_gamma = l * (j + l * k);
			if (0 != this.m_gamma) this.m_gamma = 1 / this.m_gamma;
			this.m_beta = l * k * this.m_gamma;
			this.m_rB.Assign(gb(g, L.Subtract(this.m_localAnchorB, this.m_localCenterB)));
			var m = new N();
			m.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
			m.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
			m.ey.x = m.ex.y;
			m.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
			this.m_mass.Assign(m.GetInverse());
			this.m_C.Assign(L.Subtract(L.Add(b, this.m_rB), this.m_targetA));
			this.m_C.Multiply(this.m_beta);
			f *= .98;
			if (a.step.warmStarting) {
				this.m_impulse.Multiply(a.step.dtRatio);
				e.Add(L.Multiply(this.m_invMassB, this.m_impulse));
				f += this.m_invIB * T(this.m_rB, this.m_impulse);
			} else this.m_impulse.SetZero();
			a.velocities[this.m_indexB].v.Assign(e);
			a.velocities[this.m_indexB].w = f;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexB].v.Clone();
			var c = a.velocities[this.m_indexB].w;
			var d = L.Add(b, V(c, this.m_rB));
			var e = W(this.m_mass, L.Add(L.Add(d, this.m_C), L.Multiply(this.m_gamma, this.m_impulse)).Negate());
			var f = this.m_impulse.Clone();
			this.m_impulse.Add(e);
			var g = a.step.dt * this.m_maxForce;
			if (this.m_impulse.LengthSquared() > g * g) this.m_impulse.Multiply(g / this.m_impulse.Length());
			e.Assign(L.Subtract(this.m_impulse, f));
			b.Add(L.Multiply(this.m_invMassB, e));
			c += this.m_invIB * T(this.m_rB, e);
			a.velocities[this.m_indexB].v.Assign(b);
			a.velocities[this.m_indexB].w = c;
		},
		SolvePositionConstraints: function (a) {
			return true;
		}
	};
	Fd._extend(Bd);
	function Gd() {
		this.parent.call(this);
		this.type = Bd.e_distanceJoint;
		this.localAnchorA = new L(0, 0);
		this.localAnchorB = new L(0, 0);
		this.length = 1;
		this.frequencyHz = 0;
		this.dampingRatio = 0;
		Object.seal(this);
	}
	Gd.prototype = {
		Initialize: function (a, b, c, d) {
			this.bodyA = a;
			this.bodyB = b;
			this.localAnchorA = this.bodyA.GetLocalPoint(c);
			this.localAnchorB = this.bodyB.GetLocalPoint(d);
			var e = L.Subtract(d, c);
			this.length = e.Length();
		},
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.localAnchorA._deserialize(a.localAnchorA);
			this.localAnchorB._deserialize(a.localAnchorB);
			this.length = a.length;
			this.frequencyHz = a.frequencyHz;
			this.dampingRatio = a.dampingRatio;
		}
	};
	Gd._extend(Ad);
	function Hd(a) {
		this.parent.call(this, a);
		this.m_localAnchorA = a.localAnchorA.Clone();
		this.m_localAnchorB = a.localAnchorB.Clone();
		this.m_length = a.length;
		this.m_frequencyHz = a.frequencyHz;
		this.m_dampingRatio = a.dampingRatio;
		this.m_impulse = 0;
		this.m_gamma = 0;
		this.m_bias = 0;
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_u = new L();
		this.m_rA = new L();
		this.m_rB = new L();
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
		this.m_mass = 0;
	}
	Hd.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			var b = L.Multiply(a * this.m_impulse, this.m_u);
			return b;
		},
		GetReactionTorque: function (a) {
			return 0;
		},
		GetLocalAnchorA: function () {
			return this.m_localAnchorA;
		},
		GetLocalAnchorB: function () {
			return this.m_localAnchorB;
		},
		SetLength: function (a) {
			this.m_length = a;
		},
		GetLength: function () {
			return this.m_length;
		},
		SetFrequency: function (a) {
			this.m_frequencyHz = a;
		},
		GetFrequency: function () {
			return this.m_frequencyHz;
		},
		SetDampingRatio: function (a) {
			this.m_dampingRatio = a;
		},
		GetDampingRatio: function () {
			return this.m_dampingRatio;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
			this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var e = a.velocities[this.m_indexA].v.Clone();
			var f = a.velocities[this.m_indexA].w;
			var g = a.positions[this.m_indexB].c.Clone();
			var h = a.positions[this.m_indexB].a;
			var j = a.velocities[this.m_indexB].v.Clone();
			var k = a.velocities[this.m_indexB].w;
			var l = new P(c), m = new P(h);
			this.m_rA = gb(l, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			this.m_rB = gb(m, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			this.m_u = L.Subtract(L.Subtract(L.Add(g, this.m_rB), b), this.m_rA);
			var n = this.m_u.Length();
			if (n > i) this.m_u.Multiply(1 / n); else this.m_u.Set(0, 0);
			var o = T(this.m_rA, this.m_u);
			var p = T(this.m_rB, this.m_u);
			var q = this.m_invMassA + this.m_invIA * o * o + this.m_invMassB + this.m_invIB * p * p;
			this.m_mass = 0 != q ? 1 / q : 0;
			if (this.m_frequencyHz > 0) {
				var r = n - this.m_length;
				var s = 2 * d * this.m_frequencyHz;
				var t = 2 * this.m_mass * this.m_dampingRatio * s;
				var u = this.m_mass * s * s;
				var v = a.step.dt;
				this.m_gamma = v * (t + v * u);
				this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
				this.m_bias = r * v * u * this.m_gamma;
				q += this.m_gamma;
				this.m_mass = 0 != q ? 1 / q : 0;
			} else {
				this.m_gamma = 0;
				this.m_bias = 0;
			}
			if (a.step.warmStarting) {
				this.m_impulse *= a.step.dtRatio;
				var w = L.Multiply(this.m_impulse, this.m_u);
				e.Subtract(L.Multiply(this.m_invMassA, w));
				f -= this.m_invIA * T(this.m_rA, w);
				j.Add(L.Multiply(this.m_invMassB, w));
				k += this.m_invIB * T(this.m_rB, w);
			} else this.m_impulse = 0;
			a.velocities[this.m_indexA].v.Assign(e);
			a.velocities[this.m_indexA].w = f;
			a.velocities[this.m_indexB].v.Assign(j);
			a.velocities[this.m_indexB].w = k;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = L.Add(b, V(c, this.m_rA));
			var g = L.Add(d, V(e, this.m_rB));
			var h = S(this.m_u, L.Subtract(g, f));
			var i = -this.m_mass * (h + this.m_bias + this.m_gamma * this.m_impulse);
			this.m_impulse += i;
			var j = L.Multiply(i, this.m_u);
			b.Subtract(L.Multiply(this.m_invMassA, j));
			c -= this.m_invIA * T(this.m_rA, j);
			d.Add(L.Multiply(this.m_invMassB, j));
			e += this.m_invIB * T(this.m_rB, j);
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
		},
		SolvePositionConstraints: function (a) {
			if (this.m_frequencyHz > 0) return true;
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.positions[this.m_indexB].c.Clone();
			var e = a.positions[this.m_indexB].a;
			var f = new P(c), g = new P(e);
			var h = gb(f, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var j = gb(g, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var k = L.Subtract(L.Subtract(L.Add(d, j), b), h);
			var l = k.Normalize();
			var m = l - this.m_length;
			m = tb(m, -o, o);
			var n = -this.m_mass * m;
			var p = L.Multiply(n, k);
			b.Subtract(L.Multiply(this.m_invMassA, p));
			c -= this.m_invIA * T(h, p);
			d.Add(L.Multiply(this.m_invMassB, p));
			e += this.m_invIB * T(j, p);
			a.positions[this.m_indexA].c.Assign(b);
			a.positions[this.m_indexA].a = c;
			a.positions[this.m_indexB].c.Assign(d);
			a.positions[this.m_indexB].a = e;
			return mb(m) < i;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.localAnchorA = this.m_localAnchorA._serialize();
			b.localAnchorB = this.m_localAnchorB._serialize();
			b.length = this.m_length;
			b.frequencyHz = this.m_frequencyHz;
			b.dampingRatio = this.m_dampingRatio;
			return b;
		}
	};
	Hd._extend(Bd);
	function Id() {
		this.parent.call(this);
		this.type = Bd.e_prismaticJoint;
		this.localAnchorA = new L();
		this.localAnchorB = new L();
		this.localAxisA = new L(1, 0);
		this.referenceAngle = 0;
		this.enableLimit = false;
		this.lowerTranslation = 0;
		this.upperTranslation = 0;
		this.enableMotor = false;
		this.maxMotorForce = 0;
		this.motorSpeed = 0;
		Object.seal(this);
	}
	Id.prototype = {
		Initialize: function (a, b, c, d) {
			this.bodyA = a;
			this.bodyB = b;
			this.localAnchorA = this.bodyA.GetLocalPoint(c);
			this.localAnchorB = this.bodyB.GetLocalPoint(c);
			this.localAxisA = this.bodyA.GetLocalVector(d);
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		},
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.localAnchorA._deserialize(a.localAnchorA);
			this.localAnchorB._deserialize(a.localAnchorB);
			this.localAxisA._deserialize(a.localAxisA);
			this.referenceAngle = a.referenceAngle;
			this.enableLimit = a.enableLimit;
			this.lowerTranslation = a.lowerTranslation;
			this.upperTranslation = a.upperTranslation;
			this.enableMotor = a.enableMotor;
			this.maxMotorForce = a.maxMotorForce;
			this.motorSpeed = a.motorSpeed;
		}
	};
	Id._extend(Ad);
	function Jd(a) {
		this.parent.call(this, a);
		this.m_localAnchorA = a.localAnchorA.Clone();
		this.m_localAnchorB = a.localAnchorB.Clone();
		this.m_localXAxisA = a.localAxisA.Clone();
		this.m_localXAxisA.Normalize();
		this.m_localYAxisA = V(1, this.m_localXAxisA);
		this.m_referenceAngle = a.referenceAngle;
		this.m_impulse = new M();
		this.m_motorMass = 0;
		this.m_motorImpulse = 0;
		this.m_lowerTranslation = a.lowerTranslation;
		this.m_upperTranslation = a.upperTranslation;
		this.m_maxMotorForce = a.maxMotorForce;
		this.m_motorSpeed = a.motorSpeed;
		this.m_enableLimit = a.enableLimit;
		this.m_enableMotor = a.enableMotor;
		this.m_limitState = Bd.e_inactiveLimit;
		this.m_axis = new L();
		this.m_perp = new L();
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
		this.m_s1 = 0, this.m_s2 = 0;
		this.m_a1 = 0, this.m_a2 = 0;
		this.m_K = new O();
		this.m_motorMass = 0;
	}
	Jd.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			return L.Multiply(a, L.Add(L.Multiply(this.m_impulse.x, this.m_perp), L.Multiply(this.m_motorImpulse + this.m_impulse.z, this.m_axis)));
		},
		GetReactionTorque: function (a) {
			return a * this.m_impulse.y;
		},
		GetLocalAnchorA: function () {
			return this.m_localAnchorA;
		},
		GetLocalAnchorB: function () {
			return this.m_localAnchorB;
		},
		GetLocalAxisA: function () {
			return this.m_localXAxisA;
		},
		GetReferenceAngle: function () {
			return this.m_referenceAngle;
		},
		GetJointTranslation: function () {
			var a = this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
			var b = this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
			var c = L.Subtract(b, a);
			var d = this.m_bodyA.GetWorldVector(this.m_localXAxisA);
			var e = S(c, d);
			return e;
		},
		GetJointSpeed: function () {
			var a = this.m_bodyA;
			var b = this.m_bodyB;
			var c = gb(a.m_xf.q, L.Subtract(this.m_localAnchorA, a.m_sweep.localCenter));
			var d = gb(b.m_xf.q, L.Subtract(this.m_localAnchorB, b.m_sweep.localCenter));
			var e = L.Add(a.m_sweep.c, c);
			var f = L.Add(b.m_sweep.c, d);
			var g = L.Subtract(f, e);
			var h = gb(a.m_xf.q, this.m_localXAxisA);
			var i = a.m_linearVelocity;
			var j = b.m_linearVelocity;
			var k = a.m_angularVelocity;
			var l = b.m_angularVelocity;
			var m = S(g, V(k, h)) + S(h, L.Subtract(L.Subtract(L.Add(j, V(l, d)), i), V(k, c)));
			return m;
		},
		IsLimitEnabled: function () {
			return this.m_enableLimit;
		},
		EnableLimit: function (a) {
			if (a != this.m_enableLimit) {
				this.m_bodyA.SetAwake(true);
				this.m_bodyB.SetAwake(true);
				this.m_enableLimit = a;
				this.m_impulse.z = 0;
			}
		},
		GetLowerLimit: function () {
			return this.m_lowerTranslation;
		},
		GetUpperLimit: function () {
			return this.m_upperTranslation;
		},
		SetLimits: function (a, b) {
			if (a != this.m_lowerTranslation || b != this.m_upperTranslation) {
				this.m_bodyA.SetAwake(true);
				this.m_bodyB.SetAwake(true);
				this.m_lowerTranslation = a;
				this.m_upperTranslation = b;
				this.m_impulse.z = 0;
			}
		},
		IsMotorEnabled: function () {
			return this.m_enableMotor;
		},
		EnableMotor: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableMotor = a;
		},
		SetMotorSpeed: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = a;
		},
		GetMotorSpeed: function () {
			return this.m_motorSpeed;
		},
		SetMaxMotorForce: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_maxMotorForce = a;
		},
		GetMaxMotorForce: function () {
			return this.m_maxMotorForce;
		},
		GetMotorForce: function (a) {
			return a * this.m_motorImpulse;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
			this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.velocities[this.m_indexA].v.Clone();
			var e = a.velocities[this.m_indexA].w;
			var f = a.positions[this.m_indexB].c.Clone();
			var g = a.positions[this.m_indexB].a;
			var h = a.velocities[this.m_indexB].v.Clone();
			var j = a.velocities[this.m_indexB].w;
			var k = new P(c), l = new P(g);
			var m = gb(k, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var n = gb(l, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var o = L.Add(L.Subtract(f, b), L.Subtract(n, m));
			var p = this.m_invMassA, q = this.m_invMassB;
			var r = this.m_invIA, s = this.m_invIB;
			this.m_axis = gb(k, this.m_localXAxisA);
			this.m_a1 = T(L.Add(o, m), this.m_axis);
			this.m_a2 = T(n, this.m_axis);
			this.m_motorMass = p + q + r * this.m_a1 * this.m_a1 + s * this.m_a2 * this.m_a2;
			if (this.m_motorMass > 0) this.m_motorMass = 1 / this.m_motorMass;
			this.m_perp = gb(k, this.m_localYAxisA);
			this.m_s1 = T(L.Add(o, m), this.m_perp);
			this.m_s2 = T(n, this.m_perp);
			var t = p + q + r * this.m_s1 * this.m_s1 + s * this.m_s2 * this.m_s2;
			var u = r * this.m_s1 + s * this.m_s2;
			var v = r * this.m_s1 * this.m_a1 + s * this.m_s2 * this.m_a2;
			var w = r + s;
			if (0 == w) w = 1;
			var x = r * this.m_a1 + s * this.m_a2;
			var y = p + q + r * this.m_a1 * this.m_a1 + s * this.m_a2 * this.m_a2;
			this.m_K.ex.Set(t, u, v);
			this.m_K.ey.Set(u, w, x);
			this.m_K.ez.Set(v, x, y);
			if (this.m_enableLimit) {
				var z = S(this.m_axis, o);
				if (mb(this.m_upperTranslation - this.m_lowerTranslation) < 2 * i) this.m_limitState = Bd.e_equalLimits; else if (z <= this.m_lowerTranslation) {
					if (this.m_limitState != Bd.e_atLowerLimit) {
						this.m_limitState = Bd.e_atLowerLimit;
						this.m_impulse.z = 0;
					}
				} else if (z >= this.m_upperTranslation) {
					if (this.m_limitState != Bd.e_atUpperLimit) {
						this.m_limitState = Bd.e_atUpperLimit;
						this.m_impulse.z = 0;
					}
				} else {
					this.m_limitState = Bd.e_inactiveLimit;
					this.m_impulse.z = 0;
				}
			} else {
				this.m_limitState = Bd.e_inactiveLimit;
				this.m_impulse.z = 0;
			}
			if (false == this.m_enableMotor) this.m_motorImpulse = 0;
			if (a.step.warmStarting) {
				this.m_impulse.Multiply(a.step.dtRatio);
				this.m_motorImpulse *= a.step.dtRatio;
				var A = L.Add(L.Multiply(this.m_impulse.x, this.m_perp), L.Multiply(this.m_motorImpulse + this.m_impulse.z, this.m_axis));
				var B = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
				var C = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
				d.Subtract(L.Multiply(p, A));
				e -= r * B;
				h.Add(L.Multiply(q, A));
				j += s * C;
			} else {
				this.m_impulse.SetZero();
				this.m_motorImpulse = 0;
			}
			a.velocities[this.m_indexA].v.Assign(d);
			a.velocities[this.m_indexA].w = e;
			a.velocities[this.m_indexB].v.Assign(h);
			a.velocities[this.m_indexB].w = j;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = this.m_invMassA, g = this.m_invMassB;
			var h = this.m_invIA, i = this.m_invIB;
			if (this.m_enableMotor && this.m_limitState != Bd.e_equalLimits) {
				var j = S(this.m_axis, L.Subtract(d, b)) + this.m_a2 * e - this.m_a1 * c;
				var k = this.m_motorMass * (this.m_motorSpeed - j);
				var l = this.m_motorImpulse;
				var m = a.step.dt * this.m_maxMotorForce;
				this.m_motorImpulse = tb(this.m_motorImpulse + k, -m, m);
				k = this.m_motorImpulse - l;
				var n = L.Multiply(k, this.m_axis);
				var o = k * this.m_a1;
				var p = k * this.m_a2;
				b.Subtract(L.Multiply(f, n));
				c -= h * o;
				d.Add(L.Multiply(g, n));
				e += i * p;
			}
			var q = new L();
			q.x = S(this.m_perp, L.Subtract(d, b)) + this.m_s2 * e - this.m_s1 * c;
			q.y = e - c;
			if (this.m_enableLimit && this.m_limitState != Bd.e_inactiveLimit) {
				var r;
				r = S(this.m_axis, L.Subtract(d, b)) + this.m_a2 * e - this.m_a1 * c;
				var j = new M(q.x, q.y, r);
				var s = this.m_impulse.Clone();
				var t = this.m_K.Solve33(j.Negate());
				this.m_impulse.Add(t);
				if (this.m_limitState == Bd.e_atLowerLimit) this.m_impulse.z = rb(this.m_impulse.z, 0); else if (this.m_limitState == Bd.e_atUpperLimit) this.m_impulse.z = pb(this.m_impulse.z, 0);
				var u = L.Subtract(q.Negate(), L.Multiply(this.m_impulse.z - s.z, new L(this.m_K.ez.x, this.m_K.ez.y)));
				var v = L.Add(this.m_K.Solve22(u), new L(s.x, s.y));
				this.m_impulse.x = v.x;
				this.m_impulse.y = v.y;
				t = M.Subtract(this.m_impulse, s);
				var n = L.Add(L.Multiply(t.x, this.m_perp), L.Multiply(t.z, this.m_axis));
				var o = t.x * this.m_s1 + t.y + t.z * this.m_a1;
				var p = t.x * this.m_s2 + t.y + t.z * this.m_a2;
				b.Subtract(L.Multiply(f, n));
				c -= h * o;
				d.Add(L.Multiply(g, n));
				e += i * p;
			} else {
				var t = this.m_K.Solve22(q.Negate());
				this.m_impulse.x += t.x;
				this.m_impulse.y += t.y;
				var n = L.Multiply(t.x, this.m_perp);
				var o = t.x * this.m_s1 + t.y;
				var p = t.x * this.m_s2 + t.y;
				b.Subtract(L.Multiply(f, n));
				c -= h * o;
				d.Add(L.Multiply(g, n));
				e += i * p;
			}
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
		},
		SolvePositionConstraints: function (a) {
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.positions[this.m_indexB].c.Clone();
			var e = a.positions[this.m_indexB].a;
			var f = new P(c), g = new P(e);
			var h = this.m_invMassA, k = this.m_invMassB;
			var l = this.m_invIA, m = this.m_invIB;
			var n = gb(f, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var p = gb(g, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var q = L.Subtract(L.Subtract(L.Add(d, p), b), n);
			var r = gb(f, this.m_localXAxisA);
			var s = T(L.Add(q, n), r);
			var t = T(p, r);
			var u = gb(f, this.m_localYAxisA);
			var v = T(L.Add(q, n), u);
			var w = T(p, u);
			var x = new M();
			var y = new L();
			y.x = S(u, q);
			y.y = e - c - this.m_referenceAngle;
			var z = mb(y.x);
			var A = mb(y.y);
			var B = false;
			var C = 0;
			if (this.m_enableLimit) {
				var D = S(r, q);
				if (mb(this.m_upperTranslation - this.m_lowerTranslation) < 2 * i) {
					C = tb(D, -o, o);
					z = rb(z, mb(D));
					B = true;
				} else if (D <= this.m_lowerTranslation) {
					C = tb(D - this.m_lowerTranslation + i, -o, 0);
					z = rb(z, this.m_lowerTranslation - D);
					B = true;
				} else if (D >= this.m_upperTranslation) {
					C = tb(D - this.m_upperTranslation - i, 0, o);
					z = rb(z, D - this.m_upperTranslation);
					B = true;
				}
			}
			if (B) {
				var E = h + k + l * v * v + m * w * w;
				var F = l * v + m * w;
				var G = l * v * s + m * w * t;
				var H = l + m;
				if (0 == H) H = 1;
				var I = l * s + m * t;
				var J = h + k + l * s * s + m * t * t;
				var K = new O();
				K.ex.Set(E, F, G);
				K.ey.Set(F, H, I);
				K.ez.Set(G, I, J);
				var Q = new M();
				Q.x = y.x;
				Q.y = y.y;
				Q.z = C;
				x = K.Solve33(Q.Negate());
			} else {
				var E = h + k + l * v * v + m * w * w;
				var F = l * v + m * w;
				var H = l + m;
				if (0 == H) H = 1;
				var K = new N();
				K.ex.Set(E, F);
				K.ey.Set(F, H);
				var R = K.Solve(y.Negate());
				x.x = R.x;
				x.y = R.y;
				x.z = 0;
			}
			var U = L.Add(L.Multiply(x.x, u), L.Multiply(x.z, r));
			var V = x.x * v + x.y + x.z * s;
			var W = x.x * w + x.y + x.z * t;
			b.Subtract(L.Multiply(h, U));
			c -= l * V;
			d.Add(L.Multiply(k, U));
			e += m * W;
			a.positions[this.m_indexA].c.Assign(b);
			a.positions[this.m_indexA].a = c;
			a.positions[this.m_indexB].c.Assign(d);
			a.positions[this.m_indexB].a = e;
			return z <= i && A <= j;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.localAnchorA = this.m_localAnchorA._serialize();
			b.localAnchorB = this.m_localAnchorB._serialize();
			b.localAxisA = this.m_localXAxisA._serialize();
			b.referenceAngle = this.m_referenceAngle;
			b.enableLimit = this.m_enableLimit;
			b.lowerTranslation = this.m_lowerTranslation;
			b.upperTranslation = this.m_upperTranslation;
			b.enableMotor = this.m_enableMotor;
			b.maxMotorForce = this.m_maxMotorForce;
			b.motorSpeed = this.m_motorSpeed;
			return b;
		}
	};
	Jd._extend(Bd);
	function Kd() {
		this.parent.call(this);
		this.type = Bd.e_frictionJoint;
		this.localAnchorA = new L();
		this.localAnchorB = new L();
		this.maxForce = 0;
		this.maxTorque = 0;
		Object.seal(this);
	}
	Kd.prototype = {
		Initialize: function (a, b, c) {
			this.bodyA = a;
			this.bodyB = b;
			this.localAnchorA.Assign(this.bodyA.GetLocalPoint(c));
			this.localAnchorB.Assign(this.bodyB.GetLocalPoint(c));
		},
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.localAnchorA._deserialize(a.localAnchorA);
			this.localAnchorB._deserialize(a.localAnchorB);
			this.maxForce = a.maxForce;
			this.maxTorque = a.maxTorque;
		}
	};
	Kd._extend(Ad);
	function Ld(a) {
		this.parent.call(this, a);
		this.m_localAnchorA = a.localAnchorA.Clone();
		this.m_localAnchorB = a.localAnchorB.Clone();
		this.m_linearImpulse = new L();
		this.m_angularImpulse = 0;
		this.m_maxForce = a.maxForce;
		this.m_maxTorque = a.maxTorque;
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_rA = new L();
		this.m_rB = new L();
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
		this.m_linearMass = new N();
		this.m_angularMass = 0;
	}
	Ld.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			return L.Multiply(a, this.m_linearImpulse);
		},
		GetReactionTorque: function (a) {
			return a * this.m_angularImpulse;
		},
		GetLocalAnchorA: function () {
			return this.m_localAnchorA;
		},
		GetLocalAnchorB: function () {
			return this.m_localAnchorB;
		},
		SetMaxForce: function (a) {
			this.m_maxForce = a;
		},
		GetMaxForce: function () {
			return this.m_maxForce;
		},
		SetMaxTorque: function (a) {
			this.m_maxTorque = a;
		},
		GetMaxTorque: function () {
			return this.m_maxTorque;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
			this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexA].a;
			var c = a.velocities[this.m_indexA].v.Clone();
			var d = a.velocities[this.m_indexA].w;
			var e = a.positions[this.m_indexB].a;
			var f = a.velocities[this.m_indexB].v.Clone();
			var g = a.velocities[this.m_indexB].w;
			var h = new P(b), i = new P(e);
			this.m_rA = gb(h, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			this.m_rB = gb(i, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var j = this.m_invMassA, k = this.m_invMassB;
			var l = this.m_invIA, m = this.m_invIB;
			var n = new N();
			n.ex.x = j + k + l * this.m_rA.y * this.m_rA.y + m * this.m_rB.y * this.m_rB.y;
			n.ex.y = -l * this.m_rA.x * this.m_rA.y - m * this.m_rB.x * this.m_rB.y;
			n.ey.x = n.ex.y;
			n.ey.y = j + k + l * this.m_rA.x * this.m_rA.x + m * this.m_rB.x * this.m_rB.x;
			this.m_linearMass = n.GetInverse();
			this.m_angularMass = l + m;
			if (this.m_angularMass > 0) this.m_angularMass = 1 / this.m_angularMass;
			if (a.step.warmStarting) {
				this.m_linearImpulse.Multiply(a.step.dtRatio);
				this.m_angularImpulse *= a.step.dtRatio;
				var o = new L(this.m_linearImpulse.x, this.m_linearImpulse.y);
				c.Subtract(L.Multiply(j, o));
				d -= l * (T(this.m_rA, o) + this.m_angularImpulse);
				f.Add(L.Multiply(k, o));
				g += m * (T(this.m_rB, o) + this.m_angularImpulse);
			} else {
				this.m_linearImpulse.SetZero();
				this.m_angularImpulse = 0;
			}
			a.velocities[this.m_indexA].v.Assign(c);
			a.velocities[this.m_indexA].w = d;
			a.velocities[this.m_indexB].v.Assign(f);
			a.velocities[this.m_indexB].w = g;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = this.m_invMassA, g = this.m_invMassB;
			var h = this.m_invIA, i = this.m_invIB;
			var j = a.step.dt;
			var k = e - c;
			var l = -this.m_angularMass * k;
			var m = this.m_angularImpulse;
			var n = j * this.m_maxTorque;
			this.m_angularImpulse = tb(this.m_angularImpulse + l, -n, n);
			l = this.m_angularImpulse - m;
			c -= h * l;
			e += i * l;
			var k = L.Add(d, L.Subtract(V(e, this.m_rB), L.Subtract(b, V(c, this.m_rA))));
			var l = W(this.m_linearMass, k).Negate();
			var m = this.m_linearImpulse.Clone();
			this.m_linearImpulse.Add(l);
			var n = j * this.m_maxForce;
			if (this.m_linearImpulse.LengthSquared() > n * n) {
				this.m_linearImpulse.Normalize();
				this.m_linearImpulse.Multiply(n);
			}
			l = L.Subtract(this.m_linearImpulse, m);
			b.Subtract(L.Multiply(f, l));
			c -= h * T(this.m_rA, l);
			d.Add(L.Multiply(g, l));
			e += i * T(this.m_rB, l);
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
		},
		SolvePositionConstraints: function (a) {
			return true;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.localAnchorA = this.m_localAnchorA._serialize();
			b.localAnchorB = this.m_localAnchorB._serialize();
			b.maxForce = this.m_maxForce;
			b.maxTorque = this.m_maxTorque;
			return b;
		}
	};
	Ld._extend(Bd);
	function Md() {
		this.parent.call(this);
		this.type = Bd.e_weldJoint;
		this.localAnchorA = new L(0, 0);
		this.localAnchorB = new L(0, 0);
		this.referenceAngle = 0;
		this.frequencyHz = 0;
		this.dampingRatio = 0;
		Object.seal(this);
	}
	Md.prototype = {
		Initialize: function (a, b, c) {
			this.bodyA = a;
			this.bodyB = b;
			this.localAnchorA.Assign(this.bodyA.GetLocalPoint(c));
			this.localAnchorB.Assign(this.bodyB.GetLocalPoint(c));
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		},
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.localAnchorA._deserialize(a.localAnchorA);
			this.localAnchorB._deserialize(a.localAnchorB);
			this.referenceAngle = a.referenceAngle;
			this.frequencyHz = a.frequencyHz;
			this.dampingRatio = a.dampingRatio;
		}
	};
	Md._extend(Ad);
	function Nd(a) {
		this.parent.call(this, a);
		this.m_bias = 0;
		this.m_gamma = 0;
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_rA = new L();
		this.m_rB = new L();
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
		this.m_mass = new O();
		this.m_localAnchorA = a.localAnchorA.Clone();
		this.m_localAnchorB = a.localAnchorB.Clone();
		this.m_referenceAngle = a.referenceAngle;
		this.m_frequencyHz = a.frequencyHz;
		this.m_dampingRatio = a.dampingRatio;
		this.m_impulse = new M();
	}
	Nd.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			var b = new L(this.m_impulse.x, this.m_impulse.y);
			return L.Multiply(a, b);
		},
		GetReactionTorque: function (a) {
			return a * this.m_impulse.z;
		},
		GetLocalAnchorA: function () {
			return this.m_localAnchorA;
		},
		GetLocalAnchorB: function () {
			return this.m_localAnchorB;
		},
		GetReferenceAngle: function () {
			return this.m_referenceAngle;
		},
		SetFrequency: function (a) {
			this.m_frequencyHz = a;
		},
		GetFrequency: function () {
			return this.m_frequencyHz;
		},
		SetDampingRatio: function (a) {
			this.m_dampingRatio = a;
		},
		GetDampingRatio: function () {
			return this.m_dampingRatio;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
			this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexA].a;
			var c = a.velocities[this.m_indexA].v.Clone();
			var e = a.velocities[this.m_indexA].w;
			var f = a.positions[this.m_indexB].a;
			var g = a.velocities[this.m_indexB].v.Clone();
			var h = a.velocities[this.m_indexB].w;
			var i = new P(b), j = new P(f);
			this.m_rA.Assign(gb(i, L.Subtract(this.m_localAnchorA, this.m_localCenterA)));
			this.m_rB.Assign(gb(j, L.Subtract(this.m_localAnchorB, this.m_localCenterB)));
			var k = this.m_invMassA, l = this.m_invMassB;
			var m = this.m_invIA, n = this.m_invIB;
			var o = new O();
			o.ex.x = k + l + this.m_rA.y * this.m_rA.y * m + this.m_rB.y * this.m_rB.y * n;
			o.ey.x = -this.m_rA.y * this.m_rA.x * m - this.m_rB.y * this.m_rB.x * n;
			o.ez.x = -this.m_rA.y * m - this.m_rB.y * n;
			o.ex.y = o.ey.x;
			o.ey.y = k + l + this.m_rA.x * this.m_rA.x * m + this.m_rB.x * this.m_rB.x * n;
			o.ez.y = this.m_rA.x * m + this.m_rB.x * n;
			o.ex.z = o.ez.x;
			o.ey.z = o.ez.y;
			o.ez.z = m + n;
			if (this.m_frequencyHz > 0) {
				o.GetInverse22(this.m_mass);
				var p = m + n;
				var q = p > 0 ? 1 / p : 0;
				var r = f - b - this.m_referenceAngle;
				var s = 2 * d * this.m_frequencyHz;
				var t = 2 * q * this.m_dampingRatio * s;
				var u = q * s * s;
				var v = a.step.dt;
				this.m_gamma = v * (t + v * u);
				this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
				this.m_bias = r * v * u * this.m_gamma;
				p += this.m_gamma;
				this.m_mass.ez.z = 0 != p ? 1 / p : 0;
			} else {
				o.GetSymInverse33(this.m_mass);
				this.m_gamma = 0;
				this.m_bias = 0;
			}
			if (a.step.warmStarting) {
				this.m_impulse.Multiply(a.step.dtRatio);
				var w = new L(this.m_impulse.x, this.m_impulse.y);
				c.Subtract(L.Multiply(k, w));
				e -= m * (T(this.m_rA, w) + this.m_impulse.z);
				g.Add(L.Multiply(l, w));
				h += n * (T(this.m_rB, w) + this.m_impulse.z);
			} else this.m_impulse.SetZero();
			a.velocities[this.m_indexA].v.Assign(c);
			a.velocities[this.m_indexA].w = e;
			a.velocities[this.m_indexB].v.Assign(g);
			a.velocities[this.m_indexB].w = h;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = this.m_invMassA, g = this.m_invMassB;
			var h = this.m_invIA, i = this.m_invIB;
			if (this.m_frequencyHz > 0) {
				var j = e - c;
				var k = -this.m_mass.ez.z * (j + this.m_bias + this.m_gamma * this.m_impulse.z);
				this.m_impulse.z += k;
				c -= h * k;
				e += i * k;
				var l = L.Subtract(L.Subtract(L.Add(d, V(e, this.m_rB)), b), V(c, this.m_rA));
				var m = db(this.m_mass, l).Negate();
				this.m_impulse.x += m.x;
				this.m_impulse.y += m.y;
				var n = m.Clone();
				b.Subtract(L.Multiply(f, n));
				c -= h * T(this.m_rA, n);
				d.Add(L.Multiply(g, n));
				e += i * T(this.m_rB, n);
			} else {
				var l = L.Subtract(L.Subtract(L.Add(d, V(e, this.m_rB)), b), V(c, this.m_rA));
				var j = e - c;
				var o = new M(l.x, l.y, j);
				var p = cb(this.m_mass, o).Negate();
				this.m_impulse.Add(p);
				var n = new L(p.x, p.y);
				b.Subtract(L.Multiply(f, n));
				c -= h * (T(this.m_rA, n) + p.z);
				d.Add(L.Multiply(g, n));
				e += i * (T(this.m_rB, n) + p.z);
			}
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
		},
		SolvePositionConstraints: function (a) {
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.positions[this.m_indexB].c.Clone();
			var e = a.positions[this.m_indexB].a;
			var f = new P(c), g = new P(e);
			var h = this.m_invMassA, k = this.m_invMassB;
			var l = this.m_invIA, m = this.m_invIB;
			var n = gb(f, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var o = gb(g, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var p, q;
			var r = new O();
			r.ex.x = h + k + n.y * n.y * l + o.y * o.y * m;
			r.ey.x = -n.y * n.x * l - o.y * o.x * m;
			r.ez.x = -n.y * l - o.y * m;
			r.ex.y = r.ey.x;
			r.ey.y = h + k + n.x * n.x * l + o.x * o.x * m;
			r.ez.y = n.x * l + o.x * m;
			r.ex.z = r.ez.x;
			r.ey.z = r.ez.y;
			r.ez.z = l + m;
			if (this.m_frequencyHz > 0) {
				var s = L.Subtract(L.Subtract(L.Add(d, o), b), n);
				p = s.Length();
				q = 0;
				var t = r.Solve22(s).Negate();
				b.Subtract(L.Multiply(h, t));
				c -= l * T(n, t);
				d.Add(L.Multiply(k, t));
				e += m * T(o, t);
			} else {
				var s = L.Subtract(L.Subtract(L.Add(d, o), b), n);
				var u = e - c - this.m_referenceAngle;
				p = s.Length();
				q = mb(u);
				var v = new M(s.x, s.y, u);
				var w = r.Solve33(v).Negate();
				var t = new L(w.x, w.y);
				b.Subtract(L.Multiply(h, t));
				c -= l * (T(n, t) + w.z);
				d.Add(L.Multiply(k, t));
				e += m * (T(o, t) + w.z);
			}
			a.positions[this.m_indexA].c.Assign(b);
			a.positions[this.m_indexA].a = c;
			a.positions[this.m_indexB].c.Assign(d);
			a.positions[this.m_indexB].a = e;
			return p <= i && q <= j;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.localAnchorA = this.m_localAnchorA._serialize();
			b.localAnchorB = this.m_localAnchorB._serialize();
			b.referenceAngle = this.m_referenceAngle;
			b.frequencyHz = this.m_frequencyHz;
			b.dampingRatio = this.m_dampingRatio;
			return b;
		}
	};
	Nd._extend(Bd);
	function Od() {
		this.parent.call(this);
		this.type = Bd.e_wheelJoint;
		this.localAnchorA = new L();
		this.localAnchorB = new L();
		this.localAxisA = new L(1, 0);
		this.enableMotor = false;
		this.maxMotorTorque = 0;
		this.motorSpeed = 0;
		this.frequencyHz = 2;
		this.dampingRatio = .7;
		Object.seal(this);
	}
	Od.prototype = {
		Initialize: function (a, b, c, d) {
			this.bodyA = a;
			this.bodyB = b;
			this.localAnchorA.Assign(this.bodyA.GetLocalPoint(c));
			this.localAnchorB.Assign(this.bodyB.GetLocalPoint(c));
			this.localAxisA.Assign(this.bodyA.GetLocalVector(d));
		},
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.localAnchorA._deserialize(a.localAnchorA);
			this.localAnchorB._deserialize(a.localAnchorB);
			this.localAxisA._deserialize(a.localAxisA);
			this.enableMotor = a.enableMotor;
			this.maxMotorTorque = a.maxMotorTorque;
			this.motorSpeed = a.motorSpeed;
			this.frequencyHz = a.frequencyHz;
			this.dampingRatio = a.dampingRatio;
		}
	};
	Od._extend(Ad);
	function Pd(a) {
		this.parent.call(this, a);
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
		this.m_localAnchorA = a.localAnchorA.Clone();
		this.m_localAnchorB = a.localAnchorB.Clone();
		this.m_localXAxisA = a.localAxisA.Clone();
		this.m_localYAxisA = V(1, this.m_localXAxisA);
		this.m_mass = 0;
		this.m_impulse = 0;
		this.m_motorMass = 0;
		this.m_motorImpulse = 0;
		this.m_springMass = 0;
		this.m_springImpulse = 0;
		this.m_maxMotorTorque = a.maxMotorTorque;
		this.m_motorSpeed = a.motorSpeed;
		this.m_enableMotor = a.enableMotor;
		this.m_frequencyHz = a.frequencyHz;
		this.m_dampingRatio = a.dampingRatio;
		this.m_bias = 0;
		this.m_gamma = 0;
		this.m_ax = new L();
		this.m_ay = new L();
		this.m_sAx = this.m_sBx = 0;
		this.m_sAy = this.m_sBy = 0;
	}
	Pd.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			return L.Multiply(a, L.Add(L.Multiply(this.m_impulse, this.m_ay), L.Multiply(this.m_springImpulse, this.m_ax)));
		},
		GetReactionTorque: function (a) {
			return a * this.m_motorImpulse;
		},
		GetLocalAnchorA: function () {
			return this.m_localAnchorA;
		},
		GetLocalAnchorB: function () {
			return this.m_localAnchorB;
		},
		GetLocalAxisA: function () {
			return this.m_localXAxisA;
		},
		GetJointTranslation: function () {
			var a = this.m_bodyA;
			var b = this.m_bodyB;
			var c = a.GetWorldPoint(this.m_localAnchorA);
			var d = b.GetWorldPoint(this.m_localAnchorB);
			var e = L.Subtract(d, c);
			var f = a.GetWorldVector(this.m_localXAxisA);
			var g = S(e, f);
			return g;
		},
		GetJointSpeed: function () {
			var a = this.m_bodyA.m_angularVelocity;
			var b = this.m_bodyB.m_angularVelocity;
			return b - a;
		},
		IsMotorEnabled: function () {
			return this.m_enableMotor;
		},
		EnableMotor: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableMotor = a;
		},
		SetMotorSpeed: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = a;
		},
		GetMotorSpeed: function () {
			return this.m_motorSpeed;
		},
		SetMaxMotorTorque: function (a) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_maxMotorTorque = a;
		},
		GetMaxMotorTorque: function () {
			return this.m_maxMotorTorque;
		},
		GetMotorTorque: function (a) {
			return a * this.m_motorImpulse;
		},
		SetSpringFrequencyHz: function (a) {
			this.m_frequencyHz = a;
		},
		GetSpringFrequencyHz: function () {
			return this.m_frequencyHz;
		},
		SetSpringDampingRatio: function (a) {
			this.m_dampingRatio = a;
		},
		GetSpringDampingRatio: function () {
			return this.m_dampingRatio;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
			this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = this.m_invMassA, c = this.m_invMassB;
			var e = this.m_invIA, f = this.m_invIB;
			var g = a.positions[this.m_indexA].c.Clone();
			var h = a.positions[this.m_indexA].a;
			var i = a.velocities[this.m_indexA].v.Clone();
			var j = a.velocities[this.m_indexA].w;
			var k = a.positions[this.m_indexB].c.Clone();
			var l = a.positions[this.m_indexB].a;
			var m = a.velocities[this.m_indexB].v.Clone();
			var n = a.velocities[this.m_indexB].w;
			var o = new P(h), p = new P(l);
			var q = gb(o, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var r = gb(p, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var s = L.Subtract(L.Subtract(L.Add(k, r), g), q);
			this.m_ay.Assign(gb(o, this.m_localYAxisA));
			this.m_sAy = T(L.Add(s, q), this.m_ay);
			this.m_sBy = T(r, this.m_ay);
			this.m_mass = b + c + e * this.m_sAy * this.m_sAy + f * this.m_sBy * this.m_sBy;
			if (this.m_mass > 0) this.m_mass = 1 / this.m_mass;
			this.m_springMass = 0;
			this.m_bias = 0;
			this.m_gamma = 0;
			if (this.m_frequencyHz > 0) {
				this.m_ax.Assign(gb(o, this.m_localXAxisA));
				this.m_sAx = T(L.Add(s, q), this.m_ax);
				this.m_sBx = T(r, this.m_ax);
				var t = b + c + e * this.m_sAx * this.m_sAx + f * this.m_sBx * this.m_sBx;
				if (t > 0) {
					this.m_springMass = 1 / t;
					var u = S(s, this.m_ax);
					var v = 2 * d * this.m_frequencyHz;
					var s = 2 * this.m_springMass * this.m_dampingRatio * v;
					var w = this.m_springMass * v * v;
					var x = a.step.dt;
					this.m_gamma = x * (s + x * w);
					if (this.m_gamma > 0) this.m_gamma = 1 / this.m_gamma;
					this.m_bias = u * x * w * this.m_gamma;
					this.m_springMass = t + this.m_gamma;
					if (this.m_springMass > 0) this.m_springMass = 1 / this.m_springMass;
				}
			} else this.m_springImpulse = 0;
			if (this.m_enableMotor) {
				this.m_motorMass = e + f;
				if (this.m_motorMass > 0) this.m_motorMass = 1 / this.m_motorMass;
			} else {
				this.m_motorMass = 0;
				this.m_motorImpulse = 0;
			}
			if (a.step.warmStarting) {
				this.m_impulse *= a.step.dtRatio;
				this.m_springImpulse *= a.step.dtRatio;
				this.m_motorImpulse *= a.step.dtRatio;
				var y = L.Add(L.Multiply(this.m_impulse, this.m_ay), L.Multiply(this.m_springImpulse, this.m_ax));
				var z = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
				var A = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
				i.Subtract(L.Multiply(this.m_invMassA, y));
				j -= this.m_invIA * z;
				m.Add(L.Multiply(this.m_invMassB, y));
				n += this.m_invIB * A;
			} else {
				this.m_impulse = 0;
				this.m_springImpulse = 0;
				this.m_motorImpulse = 0;
			}
			a.velocities[this.m_indexA].v.Assign(i);
			a.velocities[this.m_indexA].w = j;
			a.velocities[this.m_indexB].v.Assign(m);
			a.velocities[this.m_indexB].w = n;
		},
		SolveVelocityConstraints: function (a) {
			var b = this.m_invMassA, c = this.m_invMassB;
			var d = this.m_invIA, e = this.m_invIB;
			var f = a.velocities[this.m_indexA].v.Clone();
			var g = a.velocities[this.m_indexA].w;
			var h = a.velocities[this.m_indexB].v.Clone();
			var i = a.velocities[this.m_indexB].w;
			var j = S(this.m_ax, L.Subtract(h, f)) + this.m_sBx * i - this.m_sAx * g;
			var k = -this.m_springMass * (j + this.m_bias + this.m_gamma * this.m_springImpulse);
			this.m_springImpulse += k;
			var l = L.Multiply(k, this.m_ax);
			var m = k * this.m_sAx;
			var n = k * this.m_sBx;
			f.Subtract(L.Multiply(b, l));
			g -= d * m;
			h.Add(L.Multiply(c, l));
			i += e * n;
			var j = i - g - this.m_motorSpeed;
			var k = -this.m_motorMass * j;
			var o = this.m_motorImpulse;
			var p = a.step.dt * this.m_maxMotorTorque;
			this.m_motorImpulse = tb(this.m_motorImpulse + k, -p, p);
			k = this.m_motorImpulse - o;
			g -= d * k;
			i += e * k;
			var j = S(this.m_ay, L.Subtract(h, f)) + this.m_sBy * i - this.m_sAy * g;
			var k = -this.m_mass * j;
			this.m_impulse += k;
			var l = L.Multiply(k, this.m_ay);
			var m = k * this.m_sAy;
			var n = k * this.m_sBy;
			f.Subtract(L.Multiply(b, l));
			g -= d * m;
			h.Add(L.Multiply(c, l));
			i += e * n;
			a.velocities[this.m_indexA].v.Assign(f);
			a.velocities[this.m_indexA].w = g;
			a.velocities[this.m_indexB].v.Assign(h);
			a.velocities[this.m_indexB].w = i;
		},
		SolvePositionConstraints: function (a) {
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.positions[this.m_indexB].c.Clone();
			var e = a.positions[this.m_indexB].a;
			var f = new P(c), g = new P(e);
			var h = gb(f, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var j = gb(g, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var k = L.Add(L.Subtract(d, b), L.Subtract(j, h));
			var l = gb(f, this.m_localYAxisA);
			var m = T(L.Add(k, h), l);
			var n = T(j, l);
			var o = S(k, l);
			var p = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
			var q;
			if (0 != p) q = -o / p; else q = 0;
			var r = L.Multiply(q, l);
			var s = q * m;
			var t = q * n;
			b.Subtract(L.Multiply(this.m_invMassA, r));
			c -= this.m_invIA * s;
			d.Add(L.Multiply(this.m_invMassB, r));
			e += this.m_invIB * t;
			a.positions[this.m_indexA].c.Assign(b);
			a.positions[this.m_indexA].a = c;
			a.positions[this.m_indexB].c.Assign(d);
			a.positions[this.m_indexB].a = e;
			return mb(o) <= i;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.localAnchorA = this.m_localAnchorA._serialize();
			b.localAnchorB = this.m_localAnchorB._serialize();
			b.localAxisA = this.m_localAxisA._serialize();
			b.enableMotor = this.m_enableMotor;
			b.maxMotorTorque = this.m_maxMotorTorque;
			b.motorSpeed = this.m_motorSpeed;
			b.frequencyHz = this.m_frequencyHz;
			b.dampingRatio = this.m_dampingRatio;
			return b;
		}
	};
	Pd._extend(Bd);
	function Qd() {
		this.parent.call(this);
		this.type = Bd.e_gearJoint;
		this.joint1 = null;
		this.joint2 = null;
		this.ratio = 1;
		Object.seal(this);
	}
	Qd.prototype = {
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.joint1 = a.joint1;
			this.joint2 = a.joint2;
			this.ratio = a.ratio;
		}
	};
	Qd._extend(Ad);
	function Rd(a) {
		this.parent.call(this, a);
		this.m_joint1 = a.joint1;
		this.m_joint2 = a.joint2;
		this.m_typeA = this.m_joint1.GetType();
		this.m_typeB = this.m_joint2.GetType();
		var b, c;
		this.m_bodyC = this.m_joint1.GetBodyA();
		this.m_bodyA = this.m_joint1.GetBodyB();
		var d = this.m_bodyA.m_xf;
		var e = this.m_bodyA.m_sweep.a;
		var f = this.m_bodyC.m_xf;
		var g = this.m_bodyC.m_sweep.a;
		this.m_localAnchorA = new L();
		this.m_localAnchorB = new L();
		this.m_localAnchorC = new L();
		this.m_localAnchorD = new L();
		this.m_localAxisC = new L();
		this.m_localAxisD = new L();
		if (this.m_typeA == Bd.e_revoluteJoint) {
			var h = a.joint1;
			this.m_localAnchorC.Assign(h.m_localAnchorA);
			this.m_localAnchorA.Assign(h.m_localAnchorB);
			this.m_referenceAngleA = h.m_referenceAngle;
			this.m_localAxisC.SetZero();
			b = e - g - this.m_referenceAngleA;
		} else {
			var i = a.joint1;
			this.m_localAnchorC.Assign(i.m_localAnchorA);
			this.m_localAnchorA.Assign(i.m_localAnchorB);
			this.m_referenceAngleA = i.m_referenceAngle;
			this.m_localAxisC.Assign(i.m_localXAxisA);
			var j = this.m_localAnchorC;
			var k = hb(f.q, L.Add(gb(d.q, this.m_localAnchorA), L.Subtract(d.p, f.p)));
			b = S(L.Subtract(k, j), this.m_localAxisC);
		}
		this.m_bodyD = this.m_joint2.GetBodyA();
		this.m_bodyB = this.m_joint2.GetBodyB();
		var l = this.m_bodyB.m_xf;
		var m = this.m_bodyB.m_sweep.a;
		var n = this.m_bodyD.m_xf;
		var o = this.m_bodyD.m_sweep.a;
		if (this.m_typeB == Bd.e_revoluteJoint) {
			var h = a.joint2;
			this.m_localAnchorD.Assign(h.m_localAnchorA);
			this.m_localAnchorB.Assign(h.m_localAnchorB);
			this.m_referenceAngleB = h.m_referenceAngle;
			this.m_localAxisD.SetZero();
			c = m - o - this.m_referenceAngleB;
		} else {
			var i = a.joint2;
			this.m_localAnchorD.Assign(i.m_localAnchorA);
			this.m_localAnchorB.Assign(i.m_localAnchorB);
			this.m_referenceAngleB = i.m_referenceAngle;
			this.m_localAxisD.Assign(i.m_localXAxisA);
			var p = this.m_localAnchorD;
			var q = hb(n.q, L.Add(gb(l.q, this.m_localAnchorB), L.Subtract(l.p, n.p)));
			c = S(L.Subtract(q, p), this.m_localAxisD);
		}
		this.m_ratio = a.ratio;
		this.m_constant = b + this.m_ratio * c;
		this.m_impulse = 0;
		this.m_indexA = this.m_indexB = this.m_indexC = this.m_indexD = 0;
		this.m_lcA = new L();
		this.m_lcB = new L();
		this.m_lcC = new L();
		this.m_lcD = new L();
		this.m_mA = this.m_mB = this.m_mC = this.m_mD = 0;
		this.m_iA = this.m_iB = this.m_iC = this.m_iD = 0;
		this.m_JvAC = new L(), this.m_JvBD = new L();
		this.m_JwA = this.m_JwB = this.m_JwC = this.m_JwD = 0;
		this.m_mass = 0;
	}
	Rd.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			var b = L.Multiply(this.m_impulse, this.m_JvAC);
			return L.Multiply(a, b);
		},
		GetReactionTorque: function (a) {
			var b = this.m_impulse * this.m_JwA;
			return a * b;
		},
		GetJoint1: function () {
			return this.m_joint1;
		},
		GetJoint2: function () {
			return this.m_joint2;
		},
		SetRatio: function (a) {
			this.m_ratio = a;
		},
		GetRatio: function () {
			return this.m_ratio;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_indexC = this.m_bodyC.m_islandIndex;
			this.m_indexD = this.m_bodyD.m_islandIndex;
			this.m_lcA.Assign(this.m_bodyA.m_sweep.localCenter);
			this.m_lcB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_lcC.Assign(this.m_bodyC.m_sweep.localCenter);
			this.m_lcD.Assign(this.m_bodyD.m_sweep.localCenter);
			this.m_mA = this.m_bodyA.m_invMass;
			this.m_mB = this.m_bodyB.m_invMass;
			this.m_mC = this.m_bodyC.m_invMass;
			this.m_mD = this.m_bodyD.m_invMass;
			this.m_iA = this.m_bodyA.m_invI;
			this.m_iB = this.m_bodyB.m_invI;
			this.m_iC = this.m_bodyC.m_invI;
			this.m_iD = this.m_bodyD.m_invI;
			var b = a.positions[this.m_indexA].a;
			var c = a.velocities[this.m_indexA].v.Clone();
			var d = a.velocities[this.m_indexA].w;
			var e = a.positions[this.m_indexB].a;
			var f = a.velocities[this.m_indexB].v.Clone();
			var g = a.velocities[this.m_indexB].w;
			var h = a.positions[this.m_indexC].a;
			var i = a.velocities[this.m_indexC].v.Clone();
			var j = a.velocities[this.m_indexC].w;
			var k = a.positions[this.m_indexD].a;
			var l = a.velocities[this.m_indexD].v.Clone();
			var m = a.velocities[this.m_indexD].w;
			var n = new P(b), o = new P(e), p = new P(h), q = new P(k);
			this.m_mass = 0;
			if (this.m_typeA == Bd.e_revoluteJoint) {
				this.m_JvAC.SetZero();
				this.m_JwA = 1;
				this.m_JwC = 1;
				this.m_mass += this.m_iA + this.m_iC;
			} else {
				var r = gb(p, this.m_localAxisC);
				var s = gb(p, L.Subtract(this.m_localAnchorC, this.m_lcC));
				var t = gb(n, L.Subtract(this.m_localAnchorA, this.m_lcA));
				this.m_JvAC.Assign(r);
				this.m_JwC = T(s, r);
				this.m_JwA = T(t, r);
				this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
			}
			if (this.m_typeB == Bd.e_revoluteJoint) {
				this.m_JvBD.SetZero();
				this.m_JwB = this.m_ratio;
				this.m_JwD = this.m_ratio;
				this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
			} else {
				var r = gb(q, this.m_localAxisD);
				var u = gb(q, L.Subtract(this.m_localAnchorD, this.m_lcD));
				var v = gb(o, L.Subtract(this.m_localAnchorB, this.m_lcB));
				this.m_JvBD.Assign(L.Multiply(this.m_ratio, r));
				this.m_JwD = this.m_ratio * T(u, r);
				this.m_JwB = this.m_ratio * T(v, r);
				this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
			}
			this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;
			if (a.step.warmStarting) {
				c.Add(L.Multiply(this.m_mA * this.m_impulse, this.m_JvAC));
				d += this.m_iA * this.m_impulse * this.m_JwA;
				f.Add(L.Multiply(this.m_mB * this.m_impulse, this.m_JvBD));
				g += this.m_iB * this.m_impulse * this.m_JwB;
				i.Subtract(L.Multiply(this.m_mC * this.m_impulse, this.m_JvAC));
				j -= this.m_iC * this.m_impulse * this.m_JwC;
				l.Subtract(L.Multiply(this.m_mD * this.m_impulse, this.m_JvBD));
				m -= this.m_iD * this.m_impulse * this.m_JwD;
			} else this.m_impulse = 0;
			a.velocities[this.m_indexA].v.Assign(c);
			a.velocities[this.m_indexA].w = d;
			a.velocities[this.m_indexB].v.Assign(f);
			a.velocities[this.m_indexB].w = g;
			a.velocities[this.m_indexC].v.Assign(i);
			a.velocities[this.m_indexC].w = j;
			a.velocities[this.m_indexD].v.Assign(l);
			a.velocities[this.m_indexD].w = m;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = a.velocities[this.m_indexC].v.Clone();
			var g = a.velocities[this.m_indexC].w;
			var h = a.velocities[this.m_indexD].v.Clone();
			var i = a.velocities[this.m_indexD].w;
			var j = S(this.m_JvAC, L.Subtract(b, f)) + S(this.m_JvBD, L.Subtract(d, h));
			j += this.m_JwA * c - this.m_JwC * g + (this.m_JwB * e - this.m_JwD * i);
			var k = -this.m_mass * j;
			this.m_impulse += k;
			b.Add(L.Multiply(this.m_mA * k, this.m_JvAC));
			c += this.m_iA * k * this.m_JwA;
			d.Add(L.Multiply(this.m_mB * k, this.m_JvBD));
			e += this.m_iB * k * this.m_JwB;
			f.Subtract(L.Multiply(this.m_mC * k, this.m_JvAC));
			g -= this.m_iC * k * this.m_JwC;
			h.Subtract(L.Multiply(this.m_mD * k, this.m_JvBD));
			i -= this.m_iD * k * this.m_JwD;
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
			a.velocities[this.m_indexC].v.Assign(f);
			a.velocities[this.m_indexC].w = g;
			a.velocities[this.m_indexD].v.Assign(h);
			a.velocities[this.m_indexD].w = i;
		},
		SolvePositionConstraints: function (a) {
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.positions[this.m_indexB].c.Clone();
			var e = a.positions[this.m_indexB].a;
			var f = a.positions[this.m_indexC].c.Clone();
			var g = a.positions[this.m_indexC].a;
			var h = a.positions[this.m_indexD].c.Clone();
			var j = a.positions[this.m_indexD].a;
			var k = new P(c), l = new P(e), m = new P(g), n = new P(j);
			var o = 0;
			var p, q;
			var r = new L(), s = new L();
			var t, u, v, w;
			var x = 0;
			if (this.m_typeA == Bd.e_revoluteJoint) {
				r.SetZero();
				t = 1;
				v = 1;
				x += this.m_iA + this.m_iC;
				p = c - g - this.m_referenceAngleA;
			} else {
				var y = gb(m, this.m_localAxisC);
				var z = gb(m, L.Subtract(this.m_localAnchorC, this.m_lcC));
				var A = gb(k, L.Subtract(this.m_localAnchorA, this.m_lcA));
				r.Assign(y);
				v = T(z, y);
				t = T(A, y);
				x += this.m_mC + this.m_mA + this.m_iC * v * v + this.m_iA * t * t;
				var B = L.Subtract(this.m_localAnchorC, this.m_lcC);
				var C = hb(m, L.Add(A, L.Subtract(b, f)));
				p = S(L.Subtract(C, B), this.m_localAxisC);
			}
			if (this.m_typeB == Bd.e_revoluteJoint) {
				s.SetZero();
				u = this.m_ratio;
				w = this.m_ratio;
				x += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
				q = e - j - this.m_referenceAngleB;
			} else {
				var y = gb(n, this.m_localAxisD);
				var D = gb(n, L.Subtract(this.m_localAnchorD, this.m_lcD));
				var E = gb(l, L.Subtract(this.m_localAnchorB, this.m_lcB));
				s.Assign(L.Multiply(this.m_ratio, y));
				w = this.m_ratio * T(D, y);
				u = this.m_ratio * T(E, y);
				x += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * w * w + this.m_iB * u * u;
				var F = L.Subtract(this.m_localAnchorD, this.m_lcD);
				var G = hb(n, L.Add(E, L.Subtract(d, h)));
				q = S(L.Subtract(G, F), this.m_localAxisD);
			}
			var H = p + this.m_ratio * q - this.m_constant;
			var I = 0;
			if (x > 0) I = -H / x;
			b.Add(L.Multiply(this.m_mA, L.Multiply(I, r)));
			c += this.m_iA * I * t;
			d.Add(L.Multiply(this.m_mB, L.Multiply(I, s)));
			e += this.m_iB * I * u;
			f.Subtract(L.Multiply(this.m_mC, L.Multiply(I, r)));
			g -= this.m_iC * I * v;
			h.Subtract(L.Multiply(this.m_mD, L.Multiply(I, s)));
			j -= this.m_iD * I * w;
			a.positions[this.m_indexA].c.Assign(b);
			a.positions[this.m_indexA].a = c;
			a.positions[this.m_indexB].c.Assign(d);
			a.positions[this.m_indexB].a = e;
			a.positions[this.m_indexC].c.Assign(f);
			a.positions[this.m_indexC].a = g;
			a.positions[this.m_indexD].c.Assign(h);
			a.positions[this.m_indexD].a = j;
			return o < i;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.joint1 = this.m_joint1.__temp_joint_id;
			b.joint2 = this.m_joint2.__temp_joint_id;
			b.ratio = this.m_ratio;
			return b;
		}
	};
	Rd._extend(Bd);
	function Sd() {
		this.parent.call(this);
		this.type = Bd.e_motorJoint;
		this.linearOffset = new L();
		this.angularOffset = 0;
		this.maxForce = 1;
		this.maxTorque = 1;
		this.correctionFactor = .3;
		Object.seal(this);
	}
	Sd.prototype = {
		Initialize: function (a, b) {
			this.bodyA = a;
			this.bodyB = b;
			var c = this.bodyB.GetPosition();
			this.linearOffset.Assign(this.bodyA.GetLocalPoint(c));
			var d = this.bodyA.GetAngle();
			var e = this.bodyB.GetAngle();
			this.angularOffset = e - d;
		},
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.linearOffset._deserialize(a.linearOffset);
			this.angularOffset = a.angularOffset;
			this.maxForce = a.maxForce;
			this.maxTorque = a.maxTorque;
			this.correctionFactor = a.correctionFactor;
		}
	};
	Sd._extend(Ad);
	function Td(a) {
		this.parent.call(this, a);
		this.m_linearOffset = a.linearOffset.Clone();
		this.m_angularOffset = a.angularOffset;
		this.m_linearImpulse = new L();
		this.m_angularImpulse = 0;
		this.m_maxForce = a.maxForce;
		this.m_maxTorque = a.maxTorque;
		this.m_correctionFactor = a.correctionFactor;
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_rA = new L();
		this.m_rB = new L();
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_linearError = new L();
		this.m_angularError = 0;
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
		this.m_linearMass = new N();
		this.m_angularMass = 0;
	}
	Td.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetPosition();
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetPosition();
		},
		GetReactionForce: function (a) {
			return L.Multiply(a, this.m_linearImpulse);
		},
		GetReactionTorque: function (a) {
			return a * this.m_angularImpulse;
		},
		SetLinearOffset: function (a) {
			if (a.x != this.m_linearOffset.x || a.y != this.m_linearOffset.y) {
				this.m_bodyA.SetAwake(true);
				this.m_bodyB.SetAwake(true);
				this.m_linearOffset.Assign(a);
			}
		},
		GetLinearOffset: function () {
			return this.m_linearOffset;
		},
		SetAngularOffset: function (a) {
			if (a != this.m_angularOffset) {
				this.m_bodyA.SetAwake(true);
				this.m_bodyB.SetAwake(true);
				this.m_angularOffset = a;
			}
		},
		GetAngularOffset: function () {
			return this.m_angularOffset;
		},
		SetMaxForce: function (a) {
			this.m_maxForce = a;
		},
		GetMaxForce: function () {
			return this.m_maxForce;
		},
		SetMaxTorque: function (a) {
			this.m_maxTorque = a;
		},
		GetMaxTorque: function () {
			return this.m_maxTorque;
		},
		SetCorrectionFactor: function (a) {
			this.m_correctionFactor = a;
		},
		GetCorrectionFactor: function () {
			return this.m_correctionFactor;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
			this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.velocities[this.m_indexA].v.Clone();
			var e = a.velocities[this.m_indexA].w;
			var f = a.positions[this.m_indexB].c.Clone();
			var g = a.positions[this.m_indexB].a;
			var h = a.velocities[this.m_indexB].v.Clone();
			var i = a.velocities[this.m_indexB].w;
			var j = new P(c), k = new P(g);
			this.m_rA.Assign(gb(j, this.m_localCenterA.Negate()));
			this.m_rB.Assign(gb(k, this.m_localCenterB.Negate()));
			var l = this.m_invMassA, m = this.m_invMassB;
			var n = this.m_invIA, o = this.m_invIB;
			var p = new N();
			p.ex.x = l + m + n * this.m_rA.y * this.m_rA.y + o * this.m_rB.y * this.m_rB.y;
			p.ex.y = -n * this.m_rA.x * this.m_rA.y - o * this.m_rB.x * this.m_rB.y;
			p.ey.x = p.ex.y;
			p.ey.y = l + m + n * this.m_rA.x * this.m_rA.x + o * this.m_rB.x * this.m_rB.x;
			this.m_linearMass.Assign(p.GetInverse());
			this.m_angularMass = n + o;
			if (this.m_angularMass > 0) this.m_angularMass = 1 / this.m_angularMass;
			this.m_linearError.Assign(L.Subtract(L.Subtract(L.Subtract(L.Add(f, this.m_rB), b), this.m_rA), gb(j, this.m_linearOffset)));
			this.m_angularError = g - c - this.m_angularOffset;
			if (a.step.warmStarting) {
				this.m_linearImpulse.Multiply(a.step.dtRatio);
				this.m_angularImpulse *= a.step.dtRatio;
				var q = new L(this.m_linearImpulse.x, this.m_linearImpulse.y);
				d.Subtract(L.Multiply(l, q));
				e -= n * (T(this.m_rA, q) + this.m_angularImpulse);
				h.Add(L.Multiply(m, q));
				i += o * (T(this.m_rB, q) + this.m_angularImpulse);
			} else {
				this.m_linearImpulse.SetZero();
				this.m_angularImpulse = 0;
			}
			a.velocities[this.m_indexA].v.Assign(d);
			a.velocities[this.m_indexA].w = e;
			a.velocities[this.m_indexB].v.Assign(h);
			a.velocities[this.m_indexB].w = i;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = this.m_invMassA, g = this.m_invMassB;
			var h = this.m_invIA, i = this.m_invIB;
			var j = a.step.dt;
			var k = a.step.inv_dt;
			var l = e - c + k * this.m_correctionFactor * this.m_angularError;
			var m = -this.m_angularMass * l;
			var n = this.m_angularImpulse;
			var o = j * this.m_maxTorque;
			this.m_angularImpulse = tb(this.m_angularImpulse + m, -o, o);
			m = this.m_angularImpulse - n;
			c -= h * m;
			e += i * m;
			var l = L.Add(L.Subtract(L.Subtract(L.Add(d, V(e, this.m_rB)), b), V(c, this.m_rA)), L.Multiply(k, L.Multiply(this.m_correctionFactor, this.m_linearError)));
			var m = W(this.m_linearMass, l).Negate();
			var n = this.m_linearImpulse;
			this.m_linearImpulse.Add(m);
			var o = j * this.m_maxForce;
			if (this.m_linearImpulse.LengthSquared() > o * o) {
				this.m_linearImpulse.Normalize();
				this.m_linearImpulse.Multiply(o);
			}
			m.Assign(L.Subtract(this.m_linearImpulse, n));
			b.Subtract(L.Multiply(f, m));
			c -= h * T(this.m_rA, m);
			d.Add(L.Multiply(g, m));
			e += i * T(this.m_rB, m);
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
		},
		SolvePositionConstraints: function (a) {
			return true;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.linearOffset = this.m_linearOffset._serialize();
			b.angularOffset = this.m_angularOffset;
			b.maxForce = this.m_maxForce;
			b.maxTorque = this.m_maxTorque;
			b.correctionFactor = this.m_correctionFactor;
			return b;
		}
	};
	Td._extend(Bd);
	var Ud = 2;
	function Vd() {
		this.parent.call(this);
		this.type = Bd.e_pulleyJoint;
		this.groundAnchorA = new L(-1, 1);
		this.groundAnchorB = new L(1, 1);
		this.localAnchorA = new L(-1, 0);
		this.localAnchorB = new L(1, 0);
		this.lengthA = 0;
		this.lengthB = 0;
		this.ratio = 1;
		this.collideConnected = true;
		Object.seal(this);
	}
	Vd.prototype = {
		Initialize: function (a, b, c, d, e, f, g) {
			this.bodyA = a;
			this.bodyB = b;
			this.groundAnchorA.Assign(c);
			this.groundAnchorB.Assign(d);
			this.localAnchorA.Assign(this.bodyA.GetLocalPoint(e));
			this.localAnchorB.Assign(this.bodyB.GetLocalPoint(f));
			var h = L.Subtract(e, c);
			this.lengthA = h.Length();
			var i = L.Subtract(f, d);
			this.lengthB = i.Length();
			this.ratio = g;
		},
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.groundAnchorA._deserialize(a.groundAnchorA);
			this.groundAnchorB._deserialize(a.groundAnchorB);
			this.localAnchorA._deserialize(a.localAnchorA);
			this.localAnchorB._deserialize(a.localAnchorB);
			this.lengthA = a.lengthA;
			this.lengthB = a.lengthB;
			this.ratio = a.ratio;
		}
	};
	Vd._extend(Ad);
	function Wd(a) {
		this.parent.call(this, a);
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_uA = new L();
		this.m_uB = new L();
		this.m_rA = new L();
		this.m_rB = new L();
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
		this.m_mass = 0;
		this.m_groundAnchorA = a.groundAnchorA.Clone();
		this.m_groundAnchorB = a.groundAnchorB.Clone();
		this.m_localAnchorA = a.localAnchorA.Clone();
		this.m_localAnchorB = a.localAnchorB.Clone();
		this.m_lengthA = a.lengthA;
		this.m_lengthB = a.lengthB;
		this.m_ratio = a.ratio;
		this.m_constant = a.lengthA + this.m_ratio * a.lengthB;
		this.m_impulse = 0;
	}
	Wd.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			var b = L.Multiply(this.m_impulse, this.m_uB);
			return L.Multiply(a, b);
		},
		GetReactionTorque: function (a) {
			return 0;
		},
		GetGroundAnchorA: function () {
			return this.m_groundAnchorA;
		},
		GetGroundAnchorB: function () {
			return this.m_groundAnchorB;
		},
		GetLengthA: function () {
			return this.m_lengthA;
		},
		GetLengthB: function () {
			return this.m_lengthB;
		},
		GetRatio: function () {
			return this.m_ratio;
		},
		GetCurrentLengthA: function () {
			var a = this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
			var b = this.m_groundAnchorA;
			var c = L.Subtract(a, b);
			return c.Length();
		},
		GetCurrentLengthB: function () {
			var a = this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
			var b = this.m_groundAnchorB;
			var c = L.Subtract(a, b);
			return c.Length();
		},
		ShiftOrigin: function (a) {
			this.m_groundAnchorA.Subtract(a);
			this.m_groundAnchorB.Subtract(a);
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
			this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.velocities[this.m_indexA].v.Clone();
			var e = a.velocities[this.m_indexA].w;
			var f = a.positions[this.m_indexB].c.Clone();
			var g = a.positions[this.m_indexB].a;
			var h = a.velocities[this.m_indexB].v.Clone();
			var j = a.velocities[this.m_indexB].w;
			var k = new P(c), l = new P(g);
			this.m_rA.Assign(gb(k, L.Subtract(this.m_localAnchorA, this.m_localCenterA)));
			this.m_rB.Assign(gb(l, L.Subtract(this.m_localAnchorB, this.m_localCenterB)));
			this.m_uA.Assign(L.Add(b, L.Subtract(this.m_rA, this.m_groundAnchorA)));
			this.m_uB.Assign(L.Add(f, L.Subtract(this.m_rB, this.m_groundAnchorB)));
			var m = this.m_uA.Length();
			var n = this.m_uB.Length();
			if (m > 10 * i) this.m_uA.Multiply(1 / m); else this.m_uA.SetZero();
			if (n > 10 * i) this.m_uB.Multiply(1 / n); else this.m_uB.SetZero();
			var o = T(this.m_rA, this.m_uA);
			var p = T(this.m_rB, this.m_uB);
			var q = this.m_invMassA + this.m_invIA * o * o;
			var r = this.m_invMassB + this.m_invIB * p * p;
			this.m_mass = q + this.m_ratio * this.m_ratio * r;
			if (this.m_mass > 0) this.m_mass = 1 / this.m_mass;
			if (a.step.warmStarting) {
				this.m_impulse *= a.step.dtRatio;
				var s = L.Multiply(-this.m_impulse, this.m_uA);
				var t = L.Multiply(-this.m_ratio * this.m_impulse, this.m_uB);
				d.Add(L.Multiply(this.m_invMassA, s));
				e += this.m_invIA * T(this.m_rA, s);
				h.Add(L.Multiply(this.m_invMassB, t));
				j += this.m_invIB * T(this.m_rB, t);
			} else this.m_impulse = 0;
			a.velocities[this.m_indexA].v.Assign(d);
			a.velocities[this.m_indexA].w = e;
			a.velocities[this.m_indexB].v.Assign(h);
			a.velocities[this.m_indexB].w = j;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = L.Add(b, V(c, this.m_rA));
			var g = L.Add(d, V(e, this.m_rB));
			var h = -S(this.m_uA, f) - this.m_ratio * S(this.m_uB, g);
			var i = -this.m_mass * h;
			this.m_impulse += i;
			var j = L.Multiply(-i, this.m_uA);
			var k = L.Multiply(-this.m_ratio, L.Multiply(i, this.m_uB));
			b.Add(L.Multiply(this.m_invMassA, j));
			c += this.m_invIA * T(this.m_rA, j);
			d.Add(L.Multiply(this.m_invMassB, k));
			e += this.m_invIB * T(this.m_rB, k);
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
		},
		SolvePositionConstraints: function (a) {
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.positions[this.m_indexB].c.Clone();
			var e = a.positions[this.m_indexB].a;
			var f = new P(c), g = new P(e);
			var h = gb(f, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var j = gb(g, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var k = L.Add(b, L.Subtract(h, this.m_groundAnchorA));
			var l = L.Add(d, L.Subtract(j, this.m_groundAnchorB));
			var m = k.Length();
			var n = l.Length();
			if (m > 10 * i) k.Multiply(1 / m); else k.SetZero();
			if (n > 10 * i) l.Multiply(1 / n); else l.SetZero();
			var o = T(h, k);
			var p = T(j, l);
			var q = this.m_invMassA + this.m_invIA * o * o;
			var r = this.m_invMassB + this.m_invIB * p * p;
			var s = q + this.m_ratio * this.m_ratio * r;
			if (s > 0) s = 1 / s;
			var t = this.m_constant - m - this.m_ratio * n;
			var u = mb(t);
			var v = -s * t;
			var w = L.Multiply(-v, k);
			var x = L.Multiply(-this.m_ratio, L.Multiply(v, l));
			b.Add(L.Multiply(this.m_invMassA, w));
			c += this.m_invIA * T(h, w);
			d.Add(L.Multiply(this.m_invMassB, x));
			e += this.m_invIB * T(j, x);
			a.positions[this.m_indexA].c.Assign(b);
			a.positions[this.m_indexA].a = c;
			a.positions[this.m_indexB].c.Assign(d);
			a.positions[this.m_indexB].a = e;
			return u < i;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.groundAnchorA = this.m_groundAnchorA._serialize();
			b.groundAnchorB = this.m_groundAnchorB._serialize();
			b.localAnchorA = this.m_localAnchorA._serialize();
			b.localAnchorB = this.m_localAnchorB._serialize();
			b.lengthA = this.m_lengthA;
			b.lengthB = this.m_lengthB;
			b.ratio = this.m_ratio;
			return b;
		}
	};
	Wd._extend(Bd);
	function Xd() {
		this.parent.call(this);
		this.type = Bd.e_ropeJoint;
		this.localAnchorA = new L(-1, 0);
		this.localAnchorB = new L(1, 0);
		this.maxLength = 0;
		Object.seal(this);
	}
	Xd.prototype = {
		_deserialize: function (a, b, c) {
			this.parent.prototype._deserialize.call(this, a, b, c);
			this.localAnchorA._deserialize(a.localAnchorA);
			this.localAnchorB._deserialize(a.localAnchorB);
			this.maxLength = a.maxLength;
		}
	};
	Xd._extend(Ad);
	function Yd(a) {
		this.parent.call(this, a);
		this.m_localAnchorA = a.localAnchorA.Clone();
		this.m_localAnchorB = a.localAnchorB.Clone();
		this.m_maxLength = a.maxLength;
		this.m_mass = 0;
		this.m_impulse = 0;
		this.m_state = Bd.e_inactiveLimit;
		this.m_length = 0;
		this.m_indexA = 0;
		this.m_indexB = 0;
		this.m_u = new L();
		this.m_rA = new L();
		this.m_rB = new L();
		this.m_localCenterA = new L();
		this.m_localCenterB = new L();
		this.m_invMassA = 0;
		this.m_invMassB = 0;
		this.m_invIA = 0;
		this.m_invIB = 0;
	}
	Yd.prototype = {
		GetAnchorA: function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		},
		GetAnchorB: function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		},
		GetReactionForce: function (a) {
			var b = L.Multiply(a * this.m_impulse, this.m_u);
			return b;
		},
		GetReactionTorque: function (a) {
			return 0;
		},
		GetLocalAnchorA: function () {
			return this.m_localAnchorA;
		},
		GetLocalAnchorB: function () {
			return this.m_localAnchorB;
		},
		SetMaxLength: function (a) {
			this.m_maxLength = a;
		},
		GetMaxLength: function () {
			return this.m_maxLength;
		},
		GetLimitState: function () {
			return this.m_state;
		},
		InitVelocityConstraints: function (a) {
			this.m_indexA = this.m_bodyA.m_islandIndex;
			this.m_indexB = this.m_bodyB.m_islandIndex;
			this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
			this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
			this.m_invMassA = this.m_bodyA.m_invMass;
			this.m_invMassB = this.m_bodyB.m_invMass;
			this.m_invIA = this.m_bodyA.m_invI;
			this.m_invIB = this.m_bodyB.m_invI;
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.velocities[this.m_indexA].v.Clone();
			var e = a.velocities[this.m_indexA].w;
			var f = a.positions[this.m_indexB].c.Clone();
			var g = a.positions[this.m_indexB].a;
			var h = a.velocities[this.m_indexB].v.Clone();
			var j = a.velocities[this.m_indexB].w;
			var k = new P(c), l = new P(g);
			this.m_rA.Assign(gb(k, L.Subtract(this.m_localAnchorA, this.m_localCenterA)));
			this.m_rB.Assign(gb(l, L.Subtract(this.m_localAnchorB, this.m_localCenterB)));
			this.m_u.Assign(L.Subtract(L.Subtract(L.Add(f, this.m_rB), b), this.m_rA));
			this.m_length = this.m_u.Length();
			var m = this.m_length - this.m_maxLength;
			if (m > 0) this.m_state = Bd.e_atUpperLimit; else this.m_state = Bd.e_inactiveLimit;
			if (this.m_length > i) this.m_u.Multiply(1 / this.m_length); else {
				this.m_u.SetZero();
				this.m_mass = 0;
				this.m_impulse = 0;
				return;
			}
			var n = T(this.m_rA, this.m_u);
			var o = T(this.m_rB, this.m_u);
			var p = this.m_invMassA + this.m_invIA * n * n + this.m_invMassB + this.m_invIB * o * o;
			this.m_mass = 0 != p ? 1 / p : 0;
			if (a.step.warmStarting) {
				this.m_impulse *= a.step.dtRatio;
				var q = L.Multiply(this.m_impulse, this.m_u);
				d.Subtract(L.Multiply(this.m_invMassA, q));
				e -= this.m_invIA * T(this.m_rA, q);
				h.Add(L.Multiply(this.m_invMassB, q));
				j += this.m_invIB * T(this.m_rB, q);
			} else this.m_impulse = 0;
			a.velocities[this.m_indexA].v.Assign(d);
			a.velocities[this.m_indexA].w = e;
			a.velocities[this.m_indexB].v.Assign(h);
			a.velocities[this.m_indexB].w = j;
		},
		SolveVelocityConstraints: function (a) {
			var b = a.velocities[this.m_indexA].v.Clone();
			var c = a.velocities[this.m_indexA].w;
			var d = a.velocities[this.m_indexB].v.Clone();
			var e = a.velocities[this.m_indexB].w;
			var f = L.Add(b, V(c, this.m_rA));
			var g = L.Add(d, V(e, this.m_rB));
			var h = this.m_length - this.m_maxLength;
			var i = S(this.m_u, L.Subtract(g, f));
			if (h < 0) i += a.step.inv_dt * h;
			var j = -this.m_mass * i;
			var k = this.m_impulse;
			this.m_impulse = pb(0, this.m_impulse + j);
			j = this.m_impulse - k;
			var l = L.Multiply(j, this.m_u);
			b.Subtract(L.Multiply(this.m_invMassA, l));
			c -= this.m_invIA * T(this.m_rA, l);
			d.Add(L.Multiply(this.m_invMassB, l));
			e += this.m_invIB * T(this.m_rB, l);
			a.velocities[this.m_indexA].v.Assign(b);
			a.velocities[this.m_indexA].w = c;
			a.velocities[this.m_indexB].v.Assign(d);
			a.velocities[this.m_indexB].w = e;
		},
		SolvePositionConstraints: function (a) {
			var b = a.positions[this.m_indexA].c.Clone();
			var c = a.positions[this.m_indexA].a;
			var d = a.positions[this.m_indexB].c.Clone();
			var e = a.positions[this.m_indexB].a;
			var f = new P(c), g = new P(e);
			var h = gb(f, L.Subtract(this.m_localAnchorA, this.m_localCenterA));
			var j = gb(g, L.Subtract(this.m_localAnchorB, this.m_localCenterB));
			var k = L.Subtract(L.Subtract(L.Add(d, j), b), h);
			var l = k.Normalize();
			var m = l - this.m_maxLength;
			m = tb(m, 0, o);
			var n = -this.m_mass * m;
			var p = L.Multiply(n, k);
			b.Subtract(L.Multiply(this.m_invMassA, p));
			c -= this.m_invIA * T(h, p);
			d.Add(L.Multiply(this.m_invMassB, p));
			e += this.m_invIB * T(j, p);
			a.positions[this.m_indexA].c.Assign(b);
			a.positions[this.m_indexA].a = c;
			a.positions[this.m_indexB].c.Assign(d);
			a.positions[this.m_indexB].a = e;
			return l - this.m_maxLength < i;
		},
		_serialize: function (a) {
			var b = a || {};
			this.parent.prototype._serialize.call(this, b);
			b.localAnchorA = this.m_localAnchorA._serialize();
			b.localAnchorB = this.m_localAnchorB._serialize();
			b.maxLength = this.m_maxLength;
			return b;
		}
	};
	Yd._extend(Bd);
	var Zd = Math.exp;
	function $d() {
		this.vertices = null;
		this.count = 0;
		this.masses = null;
		this.gravity = new L();
		this.damping = .1;
		this.k2 = .9;
		this.k3 = .1;
	}
	function _d() {
		this.m_count = 0;
		this.m_ps = null;
		this.m_p0s = null;
		this.m_vs = null;
		this.m_ims = null;
		this.m_Ls = null;
		this.m_as = null;
		this.m_damping = 0;
		this.m_gravity = new L();
		this.m_k2 = 1;
		this.m_k3 = .1;
	}
	_d.prototype = {
		Initialize: function (a) {
			this.m_count = a.count;
			this.m_ps = new Array(this.m_count);
			this.m_p0s = new Array(this.m_count);
			this.m_vs = new Array(this.m_count);
			this.m_ims = new Array(this.m_count);
			for (var b = 0; b < this.m_count; ++b) {
				this.m_ps[b] = a.vertices[b].Clone();
				this.m_p0s[b] = a.vertices[b].Clone();
				this.m_vs[b] = new L();
				var c = a.masses[b];
				if (c > 0) this.m_ims[b] = 1 / c; else this.m_ims[b] = 0;
			}
			var d = this.m_count - 1;
			var e = this.m_count - 2;
			this.m_Ls = new Array(d);
			this.m_as = new Array(e);
			for (var b = 0; b < d; ++b) {
				var f = this.m_ps[b];
				var g = this.m_ps[b + 1];
				this.m_Ls[b] = Y(f, g);
			}
			for (var b = 0; b < e; ++b) {
				var f = this.m_ps[b];
				var g = this.m_ps[b + 1];
				var h = this.m_ps[b + 2];
				var i = L.Subtract(g, f);
				var j = L.Subtract(h, g);
				var k = T(i, j);
				var l = S(i, j);
				this.m_as[b] = J(k, l);
			}
			this.m_gravity = a.gravity.Clone();
			this.m_damping = a.damping;
			this.m_k2 = a.k2;
			this.m_k3 = a.k3;
		},
		Step: function (a, b) {
			if (0 == a) return;
			var c = Zd(-a * this.m_damping);
			for (var d = 0; d < this.m_count; ++d) {
				this.m_p0s[d].Assign(this.m_ps[d]);
				if (this.m_ims[d] > 0) this.m_vs[d].Add(L.Multiply(a, this.m_gravity));
				this.m_vs[d].Multiply(c);
				this.m_ps[d].Add(L.Multiply(a, this.m_vs[d]));
			}
			for (var d = 0; d < b; ++d) {
				this.SolveC2();
				this.SolveC3();
				this.SolveC2();
			}
			var e = 1 / a;
			for (var d = 0; d < this.m_count; ++d) this.m_vs[d] = L.Multiply(e, L.Subtract(this.m_ps[d], this.m_p0s[d]));
		},
		GetVertexCount: function () {
			return this.m_count;
		},
		GetVertices: function () {
			return this.m_ps;
		},
		Draw: function (a) {
			var b = new zb(.4, .5, .7);
			for (var c = 0; c < this.m_count - 1; ++c) a.DrawSegment(this.m_ps[c], this.m_ps[c + 1], b);
		},
		SetAngle: function (a) {
			var b = this.m_count - 2;
			for (var c = 0; c < b; ++c) this.m_as[c] = a;
		},
		SolveC2: function () {
			var a = this.m_count - 1;
			for (var b = 0; b < a; ++b) {
				var c = this.m_ps[b];
				var d = this.m_ps[b + 1];
				var e = L.Subtract(d, c);
				var f = e.Normalize();
				var g = this.m_ims[b];
				var h = this.m_ims[b + 1];
				if (g + h == 0) continue;
				var i = g / (g + h);
				var j = h / (g + h);
				c.Subtract(L.Multiply(this.m_k2 * i * (this.m_Ls[b] - f), e));
				d.Add(L.Multiply(this.m_k2 * j * (this.m_Ls[b] - f), e));
			}
		},
		SolveC3: function () {
			var a = this.m_count - 2;
			for (var b = 0; b < a; ++b) {
				var c = this.m_ps[b];
				var e = this.m_ps[b + 1];
				var f = this.m_ps[b + 2];
				var g = this.m_ims[b];
				var h = this.m_ims[b + 1];
				var i = this.m_ims[b + 2];
				var j = L.Subtract(e, c);
				var k = L.Subtract(f, e);
				var l = j.LengthSquared();
				var m = k.LengthSquared();
				if (l * m == 0) continue;
				var n = T(j, k);
				var o = S(j, k);
				var p = J(n, o);
				var q = L.Multiply(-1 / l, j.Skew());
				var r = L.Multiply(1 / m, k.Skew());
				var s = L.Negate(q);
				var t = L.Subtract(q, r);
				var u = r;
				var v = g * S(s, s) + h * S(t, t) + i * S(u, u);
				if (0 == v) continue;
				v = 1 / v;
				var w = p - this.m_as[b];
				while (w > d) {
					p -= 2 * d;
					w = p - this.m_as[b];
				}
				while (w < -d) {
					p += 2 * d;
					w = p - this.m_as[b];
				}
				var x = -this.m_k3 * v * w;
				c.Add(L.Multiply(g * x, s));
				e.Add(L.Multiply(h * x, t));
				f.Add(L.Multiply(i * x, u));
			}
		}
	};
	var ae = {
		serialize: function (a) {
			var b = [];
			var c;
			var d;
			var e;
			var f;
			var g;
			for (e = a.GetBodyList(); e; e = e.GetNext()) for (f = e.GetFixtureList(); f; f = f.GetNext()) {
				g = f.GetShape();
				f.__temp_shape_id = b.length;
				b.push(g._serialize());
			}
			var h = [];
			for (e = a.GetBodyList(); e; e = e.GetNext()) {
				e.__temp_fixture_ids = [];
				for (f = e.GetFixtureList(); f; f = f.GetNext()) {
					d = f._serialize();
					d.shape = f.__temp_shape_id;
					delete f.__temp_shape_id;
					e.__temp_fixture_ids.push(h.length);
					h.push(d);
				}
			}
			var i = [];
			for (e = a.GetBodyList(); e; e = e.GetNext()) {
				d = e._serialize();
				d.fixtures = [];
				for (c = 0; c < e.__temp_fixture_ids.length; ++c) d.fixtures.push(e.__temp_fixture_ids[c]);
				delete e.__temp_fixture_ids;
				e.__temp_body_id = i.length;
				i.push(d);
			}
			var j = [];
			var k;
			for (k = a.GetJointList(), c = 0; k; k = k.GetNext(), ++c) k.__temp_joint_id = c;
			for (k = a.GetJointList(); k; k = k.GetNext()) {
				if (k.GetType() === Bd.e_mouseJoint) continue;
				d = k._serialize();
				d.bodyA = k.GetBodyA().__temp_body_id;
				d.bodyB = k.GetBodyB().__temp_body_id;
				j.push(d);
			}
			for (k = a.GetJointList(); k; k = k.GetNext()) delete k.__temp_joint_id;
			for (e = a.GetBodyList(); e; e = e.GetNext()) delete e.__temp_body_id;
			return {
				shapes: b,
				fixtures: h,
				bodies: i,
				joints: j
			};
		},
		deserialize: function (a, b, c) {
			var d = JSON.parse(a);
			if (c) {
				for (var e = b.GetBodyList(); e;) {
					var f = e.GetNext();
					b.DestroyBody(e);
					e = f;
				}
				for (var g = b.GetJointList(); g;) {
					var f = g.GetNext();
					b.DestroyJoint(g);
					g = f;
				}
			}
			var h = [];
			for (var i = 0; i < d.shapes.length; ++i) {
				var j = d.shapes[i];
				var k;
				switch (j.m_type) {
					case Db.e_circle:
						k = new Eb();
						break;

					case Db.e_edge:
						k = new Fb();
						break;

					case Db.e_chain:
						k = new Gb();
						break;

					case Db.e_polygon:
						k = new Hb();
				}
				k._deserialize(j);
				h.push(k);
			}
			var l = [];
			for (i = 0; i < d.fixtures.length; ++i) {
				var m = d.fixtures[i];
				var n = new Ec();
				n._deserialize(m);
				n.shape = h[m.shape];
				l.push(n);
			}
			var o = [];
			for (i = 0; i < d.bodies.length; ++i) {
				var p = d.bodies[i];
				var q = new Bc();
				q._deserialize(p);
				var r = b.CreateBody(q);
				for (var s = 0; s < p.fixtures.length; ++s) r.CreateFixture(l[p.fixtures[s]]);
				o.push(r);
			}
			var t = [];
			var u = [];
			for (i = 0; i < d.joints.length; ++i) {
				var v = d.joints[i];
				var w;
				switch (v.type) {
					case Bd.e_revoluteJoint:
						w = new Cd();
						break;

					case Bd.e_prismaticJoint:
						w = new Id();
						break;

					case Bd.e_distanceJoint:
						w = new Gd();
						break;

					case Bd.e_pulleyJoint:
						w = new Vd();
						break;

					case Bd.e_gearJoint:
						w = new Qd();
						break;

					case Bd.e_wheelJoint:
						w = new Od();
						break;

					case Bd.e_weldJoint:
						w = new Md();
						break;

					case Bd.e_frictionJoint:
						w = new Kd();
						break;

					case Bd.e_ropeJoint:
						w = new Xd();
						break;

					case Bd.e_motorJoint:
						w = new Sd();
						break;

					default:
						throw new Error("unknown joint");
				}
				w._deserialize(v, o);
				if (v.type === Bd.e_gearJoint) {
					u.push([w, t.length]);
					t.push(null);
				} else {
					var x = b.CreateJoint(w);
					t.push(x);
				}
			}
			for (i = 0; i < u.length; ++i) {
				u[i][0].joint1 = t[u[i][0].joint1];
				u[i][0].joint2 = t[u[i][0].joint2];
				x = b.CreateJoint(u[i][0]);
				t[u[i][1]] = x;
			}
		}
	};
	var be = function () {
		function a(a) {
			return new L(a ? a.x || 0 : 0, a ? a.y || 0 : 0);
		}
		function b(a) {
			var b = new Array(a.x.length);
			for (var c = 0; c < b.length; ++c) b[c] = new L(a.x[c], a.y[c]);
			return b;
		}
		function c(b, c) {
			var d = b.name;
			var e;
			if ("undefined" !== typeof b["int"]) e = b["int"]; else if ("undefined" !== typeof b["float"]) e = b["float"]; else if ("undefined" !== typeof b.string) e = b.string; else if ("undefined" !== typeof b.bool) e = b.bool; else if ("undefined" !== typeof b.vec2) e = a(b.vec2); else throw new Error("unknown property type");
			if (c.hasOwnProperty(d)) throw new Error("custom property possibly overwriting an existing one");
			c[d] = e;
		}
		function d(d, e) {
			var f = new Ec();
			f.density = d.density || 0;
			f.filter.categoryBits = "undefined" === typeof d["filter-categoryBits"] ? 1 : d["filter-categoryBits"];
			f.filter.maskBits = "undefined" === typeof d["filter-maskBits"] ? 65535 : d["filter-maskBits"];
			f.filter.groupIndex = "undefined" === typeof d["filter-groupIndex"] ? 0 : d["filter-groupIndex"];
			f.friction = d.friction || 0;
			f.restitution = d.restitution || 0;
			f.isSensor = d.sensor || 0;
			var g;
			if ("undefined" !== typeof d.circle) {
				g = new Eb();
				g.m_p = a(d.circle.center);
				g.m_radius = d.circle.radius || 0;
			} else if ("undefined" !== typeof d.polygon) {
				var h = b(d.polygon.vertices);
				g = new Hb();
				g.Set(h, h.length);
			} else if ("undefined" !== typeof d.chain) {
				var h = b(d.chain.vertices);
				g = new Gb();
				g.m_count = h.length;
				g.m_vertices = h;
				if (g.m_hasNextVertex = d.chain.hasNextVertex) g.m_nextVertex = a(d.chain.nextVertex);
				if (g.m_hasPrevVertex = d.chain.hasPrevVertex) g.m_prevVertex = a(d.chain.prevVertex);
			} else throw new Error("unknown shape type");
			f.shape = g;
			var i = e.CreateFixture(f);
			i.name = d.name;
			if (d.customProperties) for (var j = 0; j < d.customProperties.length; ++j) c(d, i);
		}
		function e(b, e) {
			var f = new Bc();
			f.type = b.type || Cc.b2_staticBody;
			f.angle = b.angle || 0;
			f.angularDamping = b.angularDamping || 0;
			f.angularVelocity = b.angularVelocity || 0;
			f.awake = b.awake || false;
			f.bullet = b.bullet || false;
			f.fixedRotation = b.fixedRotation || false;
			f.linearDamping = b.linearDamping || false;
			f.linearVelocity = a(b.linearVelocity);
			f.gravityScale = "undefined" !== typeof b.gravityScale ? b.gravityScale : 1;
			var g = new Cb();
			g.mass = b["massData-mass"] || 0;
			g.center = a(b["massData-center"]);
			g.I = b["massData-I"] || 0;
			f.position = a(b.position);
			var h = e.CreateBody(f);
			h.name = b.name;
			h.SetMassData(g);
			if (b.fixture) for (var i = 0; i < b.fixture.length; ++i) d(b.fixture[i], h);
			if (b.customProperties) for (i = 0; i < b.customProperties.length; ++i) c(b, h);
			return h;
		}
		var f = {
			revolute: Cd,
			distance: Gd,
			prismatic: Id,
			wheel: Od,
			rope: Xd,
			motor: Sd,
			weld: Md,
			friction: Kd
		};
		function g(b, d, e) {
			if (!f[b.type]) throw new Error("unknown joint type");
			var g = new f[b.type]();
			switch (g.type) {
				case Bd.e_revoluteJoint:
					g.localAnchorA = a(b.anchorA);
					g.localAnchorB = a(b.anchorB);
					g.enableLimit = b.enableLimit || false;
					g.enableMotor = b.enableMotor || false;
					g.lowerAngle = b.lowerLimit || 0;
					g.maxMotorTorque = b.maxMotorTorque || 0;
					g.motorSpeed = b.motorSpeed || 0;
					g.referenceAngle = b.refAngle || 0;
					g.upperAngle = b.upperLimit || 0;
					break;

				case Bd.e_distanceJoint:
					g.localAnchorA = a(b.anchorA);
					g.localAnchorB = a(b.anchorB);
					g.dampingRatio = b.dampingRatio || 0;
					g.frequencyHz = b.frequency || 0;
					g.length = b.length || 0;
					break;

				case Bd.e_prismaticJoint:
					g.localAnchorA = a(b.anchorA);
					g.localAnchorB = a(b.anchorB);
					g.enableLimit = b.enableLimit || false;
					g.enableMotor = b.enableMotor || false;
					g.localAxisA = a(b.localAxisA);
					g.lowerTranslation = b.lowerLimit || 0;
					g.maxMotorForce = b.maxMotorForce || 0;
					g.motorSpeed = b.motorSpeed || 0;
					g.referenceAngle = b.refAngle || 0;
					g.upperTranslation = b.upperLimit || 0;
					break;

				case Bd.e_wheelJoint:
					g.localAnchorA = a(b.anchorA);
					g.localAnchorB = a(b.anchorB);
					g.enableMotor = b.enableMotor || false;
					g.localAxisA = a(b.localAxisA);
					g.maxMotorTorque = b.maxMotorTorque || 0;
					g.motorSpeed = b.motorSpeed || 0;
					g.dampingRatio = b.springDampingRatio || 0;
					g.frequencyHz = b.springFrequency || 0;
					break;

				case Bd.e_ropeJoint:
					g.localAnchorA = a(b.anchorA);
					g.localAnchorB = a(b.anchorB);
					g.maxLength = b.maxLength || 0;
					break;

				case Bd.e_motorJoint:
					g.linearOffset = a(b.anchorA);
					g.angularOffset = b.refAngle || 0;
					g.maxForce = b.maxForce || 0;
					g.maxTorque = b.maxTorque || 0;
					g.correctionFactor = b.correctionFactor || 0;
					break;

				case Bd.e_weldJoint:
					g.localAnchorA = a(b.anchorA);
					g.localAnchorB = a(b.anchorB);
					g.referenceAngle = b.refAngle || 0;
					g.dampingRatio = b.dampingRatio || 0;
					g.frequencyHz = b.frequencyHz || 0;
					break;

				case Bd.e_frictionJoint:
					g.localAnchorA = a(b.anchorA);
					g.localAnchorB = a(b.anchorB);
					g.maxForce = b.maxForce || 0;
					g.maxTorque = b.maxTorque || 0;
					break;

				default:
					throw new Error("wat?");
			}
			g.bodyA = e[b.bodyA || 0];
			g.bodyB = e[b.bodyB || 0];
			g.collideConnected = b.collideConnected || false;
			var h = d.CreateJoint(g);
			h.name = b.name;
			if (b.customProperties) for (var i = 0; i < b.customProperties.length; ++i) c(b, h);
			return h;
		}
		function h() {
			this.world = null;
			this.positionIterations = 0;
			this.velocityIterations = 0;
			this.stepsPerSecond = 0;
			this.fixtures = {};
			this.bodies = {};
			this.joints = {};
			Object.seal(this);
		}
		function i(b, c) {
			var d = new h();
			d.world = c = c || new Wc(new L(0, 0));
			d.positionIterations = b.positionIterations || 0;
			d.velocityIterations = b.velocityIterations || 0;
			d.stepsPerSecond = b.stepsPerSecond || 0;
			if (b.gravity) c.SetGravity(a(b.gravity));
			c.SetAllowSleeping(b.allowSleep || false);
			c.SetAutoClearForces(b.autoClearForces || false);
			c.SetWarmStarting(b.warmStarting || false);
			c.SetContinuousPhysics(b.continuousPhysics || false);
			c.SetSubStepping(b.subStepping || false);
			var f = [];
			var i = b.body;
			if (i) for (var j = 0; j < i.length; ++j) {
				var k = e(i[j], c);
				f.push(k);
				for (var l = k.GetFixtureList(); l; l = l.GetNext()) {
					if (!d.fixtures[l.name]) d.fixtures[l.name] = [];
					d.fixtures[l.name].push(l);
				}
				if (!d.bodies[k.name]) d.bodies[k.name] = [];
				d.bodies[k.name].push(k);
			}
			var m = [];
			var n = b.joint;
			if (n) for (j = 0; j < n.length; ++j) {
				var o = g(n[j], c, f);
				m.push(o);
				if (!d.joints[o.name]) d.joints[o.name] = [];
				d.joints[o.name].push(o);
			}
			return d;
		}
		return {
			parseWorld: i
		};
	}();
	var ce = [{
		trimmed: "version",
		name: "b2_version",
		def: A
	}, {
		trimmed: "Vec2",
		name: "b2Vec2",
		def: L
	}, {
		trimmed: "Vec3",
		name: "b2Vec3",
		def: M
	}, {
		trimmed: "Mat22",
		name: "b2Mat22",
		def: N
	}, {
		trimmed: "Mat33",
		name: "b2Mat33",
		def: O
	}, {
		trimmed: "Rot",
		name: "b2Rot",
		def: P
	}, {
		trimmed: "Transform",
		name: "b2Transform",
		def: Q
	}, {
		trimmed: "Sweep",
		name: "b2Sweep",
		def: R
	}, {
		trimmed: "Dot_v2_v2",
		name: "b2Dot_v2_v2",
		def: S
	}, {
		trimmed: "Cross_v2_v2",
		name: "b2Cross_v2_v2",
		def: T
	}, {
		trimmed: "Cross_v2_f",
		name: "b2Cross_v2_f",
		def: U
	}, {
		trimmed: "Cross_f_v2",
		name: "b2Cross_f_v2",
		def: V
	}, {
		trimmed: "Mul_m22_v2",
		name: "b2Mul_m22_v2",
		def: W
	}, {
		trimmed: "MulT_m22_v2",
		name: "b2MulT_m22_v2",
		def: X
	}, {
		trimmed: "Distance",
		name: "b2Distance",
		def: Y
	}, {
		trimmed: "DistanceSquared",
		name: "b2DistanceSquared",
		def: Z
	}, {
		trimmed: "Dot_v3_v3",
		name: "b2Dot_v3_v3",
		def: $
	}, {
		trimmed: "Cross_v3_v3",
		name: "b2Cross_v3_v3",
		def: _
	}, {
		trimmed: "Mul_m22_m22",
		name: "b2Mul_m22_m22",
		def: ab
	}, {
		trimmed: "MulT_m22_m22",
		name: "b2MulT_m22_m22",
		def: bb
	}, {
		trimmed: "Mul_m33_v3",
		name: "b2Mul_m33_v3",
		def: cb
	}, {
		trimmed: "Mul22_m33_v2",
		name: "b2Mul22_m33_v2",
		def: db
	}, {
		trimmed: "Mul_r_r",
		name: "b2Mul_r_r",
		def: eb
	}, {
		trimmed: "MulT_r_r",
		name: "b2MulT_r_r",
		def: fb
	}, {
		trimmed: "Mul_r_v2",
		name: "b2Mul_r_v2",
		def: gb
	}, {
		trimmed: "MulT_r_v2",
		name: "b2MulT_r_v2",
		def: hb
	}, {
		trimmed: "Mul_t_v2",
		name: "b2Mul_t_v2",
		def: ib
	}, {
		trimmed: "Min_v2",
		name: "b2Min_v2",
		def: qb
	}, {
		trimmed: "Max_v2",
		name: "b2Max_v2",
		def: sb
	}, {
		trimmed: "Clamp",
		name: "b2Clamp",
		def: tb
	}, {
		trimmed: "MulT_t_v2",
		name: "b2MulT_t_v2",
		def: jb
	}, {
		trimmed: "Mul_t_t",
		name: "b2Mul_t_t",
		def: kb
	}, {
		trimmed: "MulT_t_t",
		name: "b2MulT_t_t",
		def: lb
	}, {
		trimmed: "Clamp_v2",
		name: "b2Clamp_v2",
		def: ub
	}, {
		trimmed: "NextPowerOfTwo",
		name: "b2NextPowerOfTwo",
		def: vb
	}, {
		trimmed: "Abs_v2",
		name: "b2Abs_v2",
		def: nb
	}, {
		trimmed: "Abs_m22",
		name: "b2Abs_m22",
		def: ob
	}, {
		trimmed: "IsPowerOfTwo",
		name: "b2IsPowerOfTwo",
		def: wb
	}, {
		trimmed: "RandomFloat",
		name: "b2RandomFloat",
		def: yb
	}, {
		trimmed: "Timer",
		name: "b2Timer",
		def: Bb
	}, {
		trimmed: "Color",
		name: "b2Color",
		def: zb
	}, {
		trimmed: "Draw",
		name: "b2Draw",
		def: Ab
	}, {
		trimmed: "ContactID",
		name: "b2ContactID",
		def: Wb
	}, {
		trimmed: "ManifoldPoint",
		name: "b2ManifoldPoint",
		def: Xb
	}, {
		trimmed: "Manifold",
		name: "b2Manifold",
		def: Yb
	}, {
		trimmed: "WorldManifold",
		name: "b2WorldManifold",
		def: Zb
	}, {
		trimmed: "GetPointStates",
		name: "b2GetPointStates",
		def: $b
	}, {
		trimmed: "ClipVertex",
		name: "b2ClipVertex",
		def: _b
	}, {
		trimmed: "RayCastInput",
		name: "b2RayCastInput",
		def: ac
	}, {
		trimmed: "RayCastOutput",
		name: "b2RayCastOutput",
		def: bc
	}, {
		trimmed: "AABB",
		name: "b2AABB",
		def: cc
	}, {
		trimmed: "CollideCircles",
		name: "b2CollideCircles",
		def: dc
	}, {
		trimmed: "CollidePolygonAndCircle",
		name: "b2CollidePolygonAndCircle",
		def: ec
	}, {
		trimmed: "FindMaxSeparation",
		name: "b2FindMaxSeparation",
		def: fc
	}, {
		trimmed: "FindIncidentEdge",
		name: "b2FindIncidentEdge",
		def: gc
	}, {
		trimmed: "CollidePolygons",
		name: "b2CollidePolygons",
		def: hc
	}, {
		trimmed: "CollideEdgeAndCircle",
		name: "b2CollideEdgeAndCircle",
		def: ic
	}, {
		trimmed: "EPAxis",
		name: "b2EPAxis",
		def: jc
	}, {
		trimmed: "TempPolygon",
		name: "b2TempPolygon",
		def: kc
	}, {
		trimmed: "ReferenceFace",
		name: "b2ReferenceFace",
		def: lc
	}, {
		trimmed: "EPCollider",
		name: "b2EPCollider",
		def: mc
	}, {
		trimmed: "CollideEdgeAndPolygon",
		name: "b2CollideEdgeAndPolygon",
		def: nc
	}, {
		trimmed: "ClipSegmentToLine",
		name: "b2ClipSegmentToLine",
		def: oc
	}, {
		trimmed: "TestShapeOverlap",
		name: "b2TestShapeOverlap",
		def: pc
	}, {
		trimmed: "TestOverlap",
		name: "b2TestOverlap",
		def: qc
	}, {
		trimmed: "Shape",
		name: "b2Shape",
		def: Db
	}, {
		trimmed: "CircleShape",
		name: "b2CircleShape",
		def: Eb
	}, {
		trimmed: "EdgeShape",
		name: "b2EdgeShape",
		def: Fb
	}, {
		trimmed: "ChainShape",
		name: "b2ChainShape",
		def: Gb
	}, {
		trimmed: "PolygonShape",
		name: "b2PolygonShape",
		def: Hb
	}, {
		trimmed: "Pair",
		name: "b2Pair",
		def: Ib
	}, {
		trimmed: "PairLessThan",
		name: "b2PairLessThan",
		def: Jb
	}, {
		trimmed: "BroadPhase",
		name: "b2BroadPhase",
		def: Kb
	}, {
		trimmed: "DistanceProxy",
		name: "b2DistanceProxy",
		def: Lb
	}, {
		trimmed: "SimplexCache",
		name: "b2SimplexCache",
		def: Mb
	}, {
		trimmed: "DistanceInput",
		name: "b2DistanceInput",
		def: Nb
	}, {
		trimmed: "DistanceOutput",
		name: "b2DistanceOutput",
		def: Ob
	}, {
		trimmed: "SimplexVertex",
		name: "b2SimplexVertex",
		def: Pb
	}, {
		trimmed: "Simplex",
		name: "b2Simplex",
		def: Qb
	}, {
		trimmed: "DistanceFunc",
		name: "b2DistanceFunc",
		def: Ub
	}, {
		trimmed: "TreeNode",
		name: "b2TreeNode",
		def: sc
	}, {
		trimmed: "DynamicTree",
		name: "b2DynamicTree",
		def: tc
	}, {
		trimmed: "TOIInput",
		name: "b2TOIInput",
		def: uc
	}, {
		trimmed: "TOIOutput",
		name: "b2TOIOutput",
		def: vc
	}, {
		trimmed: "SeparationFunction",
		name: "b2SeparationFunction",
		def: wc
	}, {
		trimmed: "TimeOfImpact",
		name: "b2TimeOfImpact",
		def: Ac
	}, {
		trimmed: "BodyDef",
		name: "b2BodyDef",
		def: Bc
	}, {
		trimmed: "Body",
		name: "b2Body",
		def: Cc
	}, {
		trimmed: "Filter",
		name: "b2Filter",
		def: Dc
	}, {
		trimmed: "FixtureDef",
		name: "b2FixtureDef",
		def: Ec
	}, {
		trimmed: "Fixture",
		name: "b2Fixture",
		def: Gc
	}, {
		trimmed: "DestructionListener",
		name: "b2DestructionListener",
		def: Hc
	}, {
		trimmed: "ContactFilter",
		name: "b2ContactFilter",
		def: Ic
	}, {
		trimmed: "ContactImpulse",
		name: "b2ContactImpulse",
		def: Jc
	}, {
		trimmed: "ContactListener",
		name: "b2ContactListener",
		def: Kc
	}, {
		trimmed: "QueryCallback",
		name: "b2QueryCallback",
		def: Lc
	}, {
		trimmed: "RayCastCallback",
		name: "b2RayCastCallback",
		def: Mc
	}, {
		trimmed: "TimeStep",
		name: "b2TimeStep",
		def: Nc
	}, {
		trimmed: "Position",
		name: "b2Position",
		def: Oc
	}, {
		trimmed: "Velocity",
		name: "b2Velocity",
		def: Pc
	}, {
		trimmed: "SolverData",
		name: "b2SolverData",
		def: Qc
	}, {
		trimmed: "World",
		name: "b2World",
		def: Wc
	}, {
		trimmed: "MixFriction",
		name: "b2MixFriction",
		def: Zc
	}, {
		trimmed: "MixRestitution",
		name: "b2MixRestitution",
		def: $c
	}, {
		trimmed: "ContactRegister",
		name: "b2ContactRegister",
		def: _c
	}, {
		trimmed: "ContactEdge",
		name: "b2ContactEdge",
		def: ad
	}, {
		trimmed: "Contact",
		name: "b2Contact",
		def: bd
	}, {
		trimmed: "CircleContact",
		name: "b2CircleContact",
		def: cd
	}, {
		trimmed: "PolygonContact",
		name: "b2PolygonContact",
		def: jd
	}, {
		trimmed: "ChainAndCircleContact",
		name: "b2ChainAndCircleContact",
		def: ed
	}, {
		trimmed: "ChainAndPolygonContact",
		name: "b2ChainAndPolygonContact",
		def: fd
	}, {
		trimmed: "EdgeAndCircleContact",
		name: "b2EdgeAndCircleContact",
		def: gd
	}, {
		trimmed: "EdgeAndPolygonContact",
		name: "b2EdgeAndPolygonContact",
		def: hd
	}, {
		trimmed: "PolygonAndCircleContact",
		name: "b2PolygonAndCircleContact",
		def: id
	}, {
		trimmed: "defaultFilter",
		name: "b2_defaultFilter",
		def: kd
	}, {
		trimmed: "defaultListener",
		name: "b2_defaultListener",
		def: ld
	}, {
		trimmed: "ContactManager",
		name: "b2ContactManager",
		def: md
	}, {
		trimmed: "VelocityConstraintPoint",
		name: "b2VelocityConstraintPoint",
		def: nd
	}, {
		trimmed: "ContactPositionConstraint",
		name: "b2ContactPositionConstraint",
		def: od
	}, {
		trimmed: "ContactVelocityConstraint",
		name: "b2ContactVelocityConstraint",
		def: pd
	}, {
		trimmed: "PositionSolverManifold",
		name: "b2PositionSolverManifold",
		def: qd
	}, {
		trimmed: "ContactSolverDef",
		name: "b2ContactSolverDef",
		def: rd
	}, {
		trimmed: "ContactSolver",
		name: "b2ContactSolver",
		def: sd
	}, {
		trimmed: "Island",
		name: "b2Island",
		def: td
	}, {
		trimmed: "Jacobian",
		name: "b2Jacobian",
		def: yd
	}, {
		trimmed: "JointEdge",
		name: "b2JointEdge",
		def: zd
	}, {
		trimmed: "JointDef",
		name: "b2JointDef",
		def: Ad
	}, {
		trimmed: "Joint",
		name: "b2Joint",
		def: Bd
	}, {
		trimmed: "RevoluteJointDef",
		name: "b2RevoluteJointDef",
		def: Cd
	}, {
		trimmed: "RevoluteJoint",
		name: "b2RevoluteJoint",
		def: Dd
	}, {
		trimmed: "MouseJointDef",
		name: "b2MouseJointDef",
		def: Ed
	}, {
		trimmed: "MouseJoint",
		name: "b2MouseJoint",
		def: Fd
	}, {
		trimmed: "DistanceJointDef",
		name: "b2DistanceJointDef",
		def: Gd
	}, {
		trimmed: "DistanceJoint",
		name: "b2DistanceJoint",
		def: Hd
	}, {
		trimmed: "PrismaticJointDef",
		name: "b2PrismaticJointDef",
		def: Id
	}, {
		trimmed: "PrismaticJoint",
		name: "b2PrismaticJoint",
		def: Jd
	}, {
		trimmed: "FrictionJointDef",
		name: "b2FrictionJointDef",
		def: Kd
	}, {
		trimmed: "FrictionJoint",
		name: "b2FrictionJoint",
		def: Ld
	}, {
		trimmed: "WeldJointDef",
		name: "b2WeldJointDef",
		def: Md
	}, {
		trimmed: "WeldJoint",
		name: "b2WeldJoint",
		def: Nd
	}, {
		trimmed: "WheelJointDef",
		name: "b2WheelJointDef",
		def: Od
	}, {
		trimmed: "WheelJoint",
		name: "b2WheelJoint",
		def: Pd
	}, {
		trimmed: "GearJointDef",
		name: "b2GearJointDef",
		def: Qd
	}, {
		trimmed: "GearJoint",
		name: "b2GearJoint",
		def: Rd
	}, {
		trimmed: "MotorJointDef",
		name: "b2MotorJointDef",
		def: Sd
	}, {
		trimmed: "MotorJoint",
		name: "b2MotorJoint",
		def: Td
	}, {
		trimmed: "PulleyJointDef",
		name: "b2PulleyJointDef",
		def: Vd
	}, {
		trimmed: "PulleyJoint",
		name: "b2PulleyJoint",
		def: Wd
	}, {
		trimmed: "RopeJointDef",
		name: "b2RopeJointDef",
		def: Xd
	}, {
		trimmed: "RopeJoint",
		name: "b2RopeJoint",
		def: Yd
	}, {
		trimmed: "RopeDef",
		name: "b2RopeDef",
		def: $d
	}, {
		trimmed: "Rope",
		name: "b2Rope",
		def: _d
	}, {
		trimmed: "maxManifoldPoints",
		name: "b2_maxManifoldPoints",
		def: e
	}, {
		trimmed: "maxPolygonVertices",
		name: "b2_maxPolygonVertices",
		def: f
	}, {
		trimmed: "aabbExtension",
		name: "b2_aabbExtension",
		def: g
	}, {
		trimmed: "aabbMultiplier",
		name: "b2_aabbMultiplier",
		def: h
	}, {
		trimmed: "linearSlop",
		name: "b2_linearSlop",
		def: i
	}, {
		trimmed: "angularSlop",
		name: "b2_angularSlop",
		def: j
	}, {
		trimmed: "polygonRadius",
		name: "b2_polygonRadius",
		def: k
	}, {
		trimmed: "maxSubSteps",
		name: "b2_maxSubSteps",
		def: l
	}, {
		trimmed: "maxTOIContacts",
		name: "b2_maxTOIContacts",
		def: m
	}, {
		trimmed: "velocityThreshold",
		name: "b2_velocityThreshold",
		def: n
	}, {
		trimmed: "maxLinearCorrection",
		name: "b2_maxLinearCorrection",
		def: o
	}, {
		trimmed: "maxAngularCorrection",
		name: "b2_maxAngularCorrection",
		def: p
	}, {
		trimmed: "maxTranslation",
		name: "b2_maxTranslation",
		def: q
	}, {
		trimmed: "maxTranslationSquared",
		name: "b2_maxTranslationSquared",
		def: r
	}, {
		trimmed: "maxRotation",
		name: "b2_maxRotation",
		def: s
	}, {
		trimmed: "maxRotationSquared",
		name: "b2_maxRotationSquared",
		def: t
	}, {
		trimmed: "baumgarte",
		name: "b2_baumgarte",
		def: u
	}, {
		trimmed: "toiBaugarte",
		name: "b2_toiBaugarte",
		def: v
	}, {
		trimmed: "timeToSleep",
		name: "b2_timeToSleep",
		def: w
	}, {
		trimmed: "linearSleepTolerance",
		name: "b2_linearSleepTolerance",
		def: x
	}, {
		trimmed: "angularSleepTolerance",
		name: "b2_angularSleepTolerance",
		def: y
	}, {
		trimmed: "epsilon",
		name: "b2_epsilon",
		def: c
	}, {
		trimmed: "JsonSerializer",
		name: "b2JsonSerializer",
		def: ae
	}, {
		trimmed: "RUBELoader",
		name: "b2RUBELoader",
		def: be
	}, {
		trimmed: "Profiler",
		name: "b2Profiler",
		def: a
	}];
	if ("undefined" !== typeof b2_compatibility && "undefined" !== typeof window) for (var de = 0; de < ce.length; ++de) window[ce[de].name] = ce[de].def; else {
		var ee = {};
		for (var de = 0; de < ce.length; ++de) ee[ce[de].trimmed] = ce[de].def;
		if ("undefined" !== typeof module) module.exports = ee; else window.b2 = ee;
	}
}();